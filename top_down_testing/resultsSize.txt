
root@a6729a1a127c:/home/hoogle_plus# python3 scripts/run_all.py
appBoth: (a -> b) -> (a -> c) -> a -> (b, c) b'running dfs on <c> . <b> . <a> . (((a -> b)) -> (((a -> c)) -> (a -> (b , c)))) at size 1\nrunning dfs on <c> . <b> . <a> . (((a -> b)) -> (((a -> c)) -> (a -> (b , c)))) at size 2\nrunning dfs on <c> . <b> . <a> . (((a -> b)) -> (((a -> c)) -> (a -> (b , c)))) at size 3\nrunning dfs on <c> . <b> . <a> . (((a -> b)) -> (((a -> c)) -> (a -> (b , c)))) at size 4\nrunning dfs on <c> . <b> . <a> . (((a -> b)) -> (((a -> c)) -> (a -> (b , c)))) at size 5\n"(4, 9)"\n"([1, 2, 3, 1, 2, 3], [3, 2, 1])"\n"(4, 9)"\n"([1, 2, 3, 1, 2, 3], [3, 2, 1])"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["\\\\x -> x + 1","\\\\x -> x * 3","3"],"output":"(4, 9)"},{"inputs":["\\\\x -> x ++ x","Data.List.reverse","[1,2,3]"],"output":"([1,2,3,1,2,3], [3,2,1])"}],"solution":"\\\\arg0 arg1 arg2 -> ((arg0 arg2) , (arg1 arg2))"}],"outDocs":[{"functionSig":"f a -> g a -> Product f g a","functionName":"Pair","functionDesc":""},{"functionSig":"(a -> b)","functionName":"arg0","functionDesc":""},{"functionSig":"(a -> c)","functionName":"arg1","functionDesc":""},{"functionSig":"a","functionName":"arg2","functionDesc":""}],"outError":""}\nComputation time: 117.423 sec\n'
119.10 OK
test: Bool -> a -> Maybe a 600.15 FAIL
both: (a -> b) -> (a, a) -> (b, b) 600.20 FAIL
firstJust: a -> [Maybe a] -> a b'running dfs on <a> . (a -> ([Maybe (a)] -> a)) at size 1\nrunning dfs on <a> . (a -> ([Maybe (a)] -> a)) at size 2\nrunning dfs on <a> . (a -> ([Maybe (a)] -> a)) at size 3\nrunning dfs on <a> . (a -> ([Maybe (a)] -> a)) at size 4\n"3"\n"_|_"\n"2"\n"3"\n"3"\n"_|_"\n"2"\n"3"\nrunning dfs on <a> . (a -> ([Maybe (a)] -> a)) at size 5\n"3"\n"3"\n"2"\n"3"\n"3"\n"3"\n"2"\n"3"\n"3"\n"_|_"\n"2"\n"3"\n"3"\n"_|_"\n"2"\n"3"\n"3"\n"_|_"\n"2"\n"3"\n"3"\n"_|_"\n"2"\n"3"\n"3"\n"_|_"\n"2"\n"3"\n"3"\n"_|_"\n"2"\n"3"\n"3"\n"_|_"\n"2"\n"3"\n"2"\n"3"\n"2"\n"3"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["3","[Nothing, Just 2, Nothing]"],"output":"2"},{"inputs":["3","[]"],"output":"3"}],"solution":"\\\\arg0 arg1 -> Data.Maybe.fromMaybe arg0 (Data.Maybe.listToMaybe (Data.Maybe.catMaybes arg1))"}],"outDocs":[{"functionSig":"[Maybe a] -> [a]","functionName":"catMaybes","functionDesc":"The catMaybes function takes a list of Maybes and\\nreturns a list of all the Just values.\\n\\nExamples\\n\\nBasic usage:\\n\\n\\n>>> catMaybes [Just 1, Nothing, Just 3]\\n[1,3]\\n\\n\\nWhen constructing a list of Maybe values, catMaybes can\\nbe used to return all of the \\"success\\" results (if the list is the\\nresult of a map, then mapMaybe would be more\\nappropriate):\\n\\n\\n>>> import Text.Read ( readMaybe )\\n\\n>>> [readMaybe x :: Maybe Int | x <- [\\"1\\", \\"Foo\\", \\"3\\"] ]\\n[Just 1,Nothing,Just 3]\\n\\n>>> catMaybes $ [readMaybe x :: Maybe Int | x <- [\\"1\\", \\"Foo\\", \\"3\\"] ]\\n[1,3]\\n\\n"},{"functionSig":"a -> Maybe a -> a","functionName":"fromMaybe","functionDesc":"The fromMaybe function takes a default value and and\\nMaybe value. If the Maybe is Nothing, it returns\\nthe default values; otherwise, it returns the value contained in the\\nMaybe.\\n\\nExamples\\n\\nBasic usage:\\n\\n\\n>>> fromMaybe \\"\\" (Just \\"Hello, World!\\")\\n\\"Hello, World!\\"\\n\\n\\n\\n>>> fromMaybe \\"\\" Nothing\\n\\"\\"\\n\\n\\nRead an integer from a string using readMaybe. If we fail to\\nparse an integer, we want to return 0 by default:\\n\\n\\n>>> import Text.Read ( readMaybe )\\n\\n>>> fromMaybe 0 (readMaybe \\"5\\")\\n5\\n\\n>>> fromMaybe 0 (readMaybe \\"\\")\\n0\\n\\n"},{"functionSig":"[a] -> Maybe a","functionName":"listToMaybe","functionDesc":"The listToMaybe function returns Nothing on an empty\\nlist or Just a where a is the first element\\nof the list.\\n\\nExamples\\n\\nBasic usage:\\n\\n\\n>>> listToMaybe []\\nNothing\\n\\n\\n\\n>>> listToMaybe [9]\\nJust 9\\n\\n\\n\\n>>> listToMaybe [1,2,3]\\nJust 1\\n\\n\\nComposing maybeToList with listToMaybe should be the\\nidentity on singleton/empty lists:\\n\\n\\n>>> maybeToList $ listToMaybe [5]\\n[5]\\n\\n>>> maybeToList $ listToMaybe []\\n[]\\n\\n\\nBut not on lists with more than one element:\\n\\n\\n>>> maybeToList $ listToMaybe [1,2,3]\\n[1]\\n\\n"},{"functionSig":"a","functionName":"arg0","functionDesc":""},{"functionSig":"[Maybe (a)]","functionName":"arg1","functionDesc":""}],"outError":""}\nComputation time: 198.648 sec\n'
207.94 OK
mapEither: (a -> Either b c) -> [a] -> ([b], [c]) 600.18 FAIL
mapMaybes: (a -> Maybe b) -> [a] -> Maybe b b'running dfs on <b> . <a> . (((a -> Maybe (b))) -> ([a] -> Maybe (b))) at size 1\nrunning dfs on <b> . <a> . (((a -> Maybe (b))) -> ([a] -> Maybe (b))) at size 2\nrunning dfs on <b> . <a> . (((a -> Maybe (b))) -> ([a] -> Maybe (b))) at size 3\n"Nothing"\n"Just 16"\n"Just 36"\n"Just 16"\nrunning dfs on <b> . <a> . (((a -> Maybe (b))) -> ([a] -> Maybe (b))) at size 4\n"Nothing"\n"Just 16"\n"Just 36"\n"Just 16"\n"Nothing"\n"Just 16"\n"Just 36"\n"Just 16"\n"Nothing"\n"Just 16"\n"Nothing"\n"Just 16"\n"Nothing"\n"Just 16"\n"Nothing"\n"Just 16"\n"Just 36"\n"Just 16"\n"Just 16"\n"Just 16"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["\\\\x -> if x < 3 then Nothing else Just (x * x)","[2,4,6]"],"output":"Just 16"}],"solution":"\\\\arg0 arg1 -> arg0 (GHC.List.head (GHC.List.tail arg1))"}],"outDocs":[{"functionSig":"[a] -> a","functionName":"head","functionDesc":"<math>. Extract the first element of a list, which must be\\nnon-empty.\\n"},{"functionSig":"[a] -> [a]","functionName":"tail","functionDesc":"<math>. Extract the elements after the head of a list, which\\nmust be non-empty.\\n"},{"functionSig":"(a -> Maybe (b))","functionName":"arg0","functionDesc":""},{"functionSig":"[a]","functionName":"arg1","functionDesc":""}],"outError":""}\nComputation time: 14.458 sec\n'
15.44 OK
mergeEither: Either a (Either a b) -> Either a b 600.18 FAIL
mbToEither: Maybe a -> b -> Either a b 600.12 FAIL
cartProduct: [a] -> [b] -> [[(a,b)]] 600.11 FAIL
multiAppPair: (a -> b, a -> c) -> a -> (b, c) 600.13 FAIL
map: (a->b)->[a]->[b] 600.16 FAIL
repl-funcs: (a->b)->Int->[a->b] 600.10 FAIL
mbAppFirst: b -> (a -> b) -> [a] -> b 600.13 FAIL
2partApp: (a->b)->(b->c)->[a]->[c] 600.17 FAIL
resolveEither: Either a b -> (a->b) -> b 600.16 FAIL
dedupe: Eq a => [a] -> [a] 600.15 FAIL
inverseMap: [a -> b] -> a -> [b] 600.12 FAIL
multiApp: (a -> b -> c) -> (a -> b) -> a -> c b'running dfs on <c> . <b> . <a> . (((a -> (b -> c))) -> (((a -> b)) -> (a -> c))) at size 1\nrunning dfs on <c> . <b> . <a> . (((a -> (b -> c))) -> (((a -> b)) -> (a -> c))) at size 2\nrunning dfs on <c> . <b> . <a> . (((a -> (b -> c))) -> (((a -> b)) -> (a -> c))) at size 3\nrunning dfs on <c> . <b> . <a> . (((a -> (b -> c))) -> (((a -> b)) -> (a -> c))) at size 4\n"12"\n"18"\n"12"\n"18"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["\\\\x y -> x + y","\\\\x -> x * x","3"],"output":"12"},{"inputs":["\\\\x y -> GHC.List.length x * GHC.List.length y","\\\\x -> x ++ x","[1,2,3]"],"output":"18"}],"solution":"\\\\arg0 arg1 arg2 -> arg0 arg2 (arg1 arg2)"}],"outDocs":[{"functionSig":"(a -> (b -> c))","functionName":"arg0","functionDesc":""},{"functionSig":"(a -> b)","functionName":"arg1","functionDesc":""},{"functionSig":"a","functionName":"arg2","functionDesc":""}],"outError":""}\nComputation time: 8.022 sec\n'
8.79 OK
singleList: a -> [a] b'running dfs on <a> . (a -> [a]) at size 1\nrunning dfs on <a> . (a -> [a]) at size 2\n"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, _"\n"[\\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\", \\"ab_, \\"a_, \\"_, _"\n"[2]"\n"[\\"abc\\"]"\nrunning dfs on <a> . (a -> [a]) at size 3\n"[2]"\n"[\\"abc\\"]"\n"[2]"\n"[\\"abc\\"]"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["2"],"output":"[2]"},{"inputs":["\\"abc\\""],"output":"[\\"abc\\"]"}],"solution":"\\\\arg0 -> arg0 : []"}],"outDocs":[{"functionSig":"","functionName":"class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s","functionDesc":"This class provides a way to attach or detach elements on the left\\nside of a structure in a flexible manner.\\n"},{"functionSig":"IntMap a","functionName":"Nil","functionDesc":""},{"functionSig":"a","functionName":"arg0","functionDesc":""}],"outError":""}\nComputation time: 2.364 sec\n'
3.72 OK
head-last: [a] -> (a,a) b'running dfs on <a> . ([a] -> (a , a)) at size 1\nrunning dfs on <a> . ([a] -> (a , a)) at size 2\nrunning dfs on <a> . ([a] -> (a , a)) at size 3\nrunning dfs on <a> . ([a] -> (a , a)) at size 4\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(4, 4)"\n"(1, 4)"\nrunning dfs on <a> . ([a] -> (a , a)) at size 5\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(4, 4)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(4, 4)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(4, 4)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(2, 2)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(4, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(2, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 1)"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"_|_"\n"(1, 4)"\n"(1, 4)"\n"(1, 4)"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["[1,2,3,4]"],"output":"(1, 4)"}],"solution":"\\\\arg0 -> GHC.List.head (GHC.List.zip arg0 (GHC.List.reverse arg0))"}],"outDocs":[{"functionSig":"[a] -> a","functionName":"head","functionDesc":"<math>. Extract the first element of a list, which must be\\nnon-empty.\\n"},{"functionSig":"[a] -> [a]","functionName":"reverse","functionDesc":"reverse xs returns the elements of xs in\\nreverse order. xs must be finite.\\n"},{"functionSig":"[a] -> [b] -> [(a, b)]","functionName":"zip","functionDesc":"<math>. zip takes two lists and returns a list of\\ncorresponding pairs.\\n\\n\\nzip [1, 2] [\'a\', \'b\'] = [(1, \'a\'), (2, \'b\')]\\n\\n\\nIf one input list is short, excess elements of the longer list are\\ndiscarded:\\n\\n\\nzip [1] [\'a\', \'b\'] = [(1, \'a\')]\\nzip [1, 2] [\'a\'] = [(1, \'a\')]\\n\\n\\nzip is right-lazy:\\n\\n\\nzip [] _|_ = []\\nzip _|_ [] = _|_\\n\\n\\nzip is capable of list fusion, but it is restricted to its\\nfirst list argument and its resulting list.\\n"},{"functionSig":"[a]","functionName":"arg0","functionDesc":""}],"outError":""}\nComputation time: 197.159 sec\n'
202.51 OK
head-rest: [a] -> (a, [a]) b'running dfs on <a> . ([a] -> (a , [a])) at size 1\nrunning dfs on <a> . ([a] -> (a , [a])) at size 2\nrunning dfs on <a> . ([a] -> (a , [a])) at size 3\n"(1, [2, 3, 4])"\n"(1, [2, 3, 4])"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["[1,2,3,4]"],"output":"(1, [2,3,4])"}],"solution":"\\\\arg0 -> Data.Maybe.fromJust (GHC.List.uncons arg0)"}],"outDocs":[{"functionSig":"HasCallStack => Maybe a -> a","functionName":"fromJust","functionDesc":"The fromJust function extracts the element out of a Just\\nand throws an error if its argument is Nothing.\\n\\nExamples\\n\\nBasic usage:\\n\\n\\n>>> fromJust (Just 1)\\n1\\n\\n\\n\\n>>> 2 * (fromJust (Just 10))\\n20\\n\\n\\n\\n>>> 2 * (fromJust Nothing)\\n*** Exception: Maybe.fromJust: Nothing\\n\\n"},{"functionSig":"[a] -> Maybe (a, [a])","functionName":"uncons","functionDesc":"<math>. Decompose a list into its head and tail. If the list is\\nempty, returns Nothing. If the list is non-empty, returns\\nJust (x, xs), where x is the head of the list\\nand xs its tail.\\n"},{"functionSig":"[a]","functionName":"arg0","functionDesc":""}],"outError":""}\nComputation time: 0.772 sec\n'
1.41 OK
pred-match: [a] -> (a -> Bool) -> Int 600.16 FAIL
splitStr: String -> Char -> [String] b'running dfs on ([Char] -> (Char -> [[Char]])) at size 1\nrunning dfs on ([Char] -> (Char -> [[Char]])) at size 2\nrunning dfs on ([Char] -> (Char -> [[Char]])) at size 3\nrunning dfs on ([Char] -> (Char -> [[Char]])) at size 4\nRESULTS:{"outCandidates":[{"outExamples":[],"solution":"\\\\arg0 arg1 -> GHC.List.repeat (arg1 : arg0)"}],"outDocs":[{"functionSig":"","functionName":"class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s","functionDesc":"This class provides a way to attach or detach elements on the left\\nside of a structure in a flexible manner.\\n"},{"functionSig":"a -> [a]","functionName":"repeat","functionDesc":"repeat x is an infinite list, with x the\\nvalue of every element.\\n"},{"functionSig":"[Char]","functionName":"arg0","functionDesc":""},{"functionSig":"Char","functionName":"arg1","functionDesc":""}],"outError":""}\nComputation time: 8.816 sec\n'
10.28 OK
splitAtFirst: a -> [a] -> ([a], [a]) 600.25 FAIL
hoogle01: (a -> b) -> [a] -> b b'running dfs on <b> . <a> . (((a -> b)) -> ([a] -> b)) at size 1\nrunning dfs on <b> . <a> . (((a -> b)) -> ([a] -> b)) at size 2\nrunning dfs on <b> . <a> . (((a -> b)) -> ([a] -> b)) at size 3\n"3"\n"[6, 6]"\n"3"\n"[6, 6]"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["\\\\xs -> GHC.List.length xs","[[1,2,3], [1,2,3,4,5,6,7]]"],"output":"3"},{"inputs":["\\\\x -> [x, x]","[6,5,4]"],"output":"[6, 6]"}],"solution":"\\\\arg0 arg1 -> arg0 (GHC.List.head arg1)"}],"outDocs":[{"functionSig":"[a] -> a","functionName":"head","functionDesc":"<math>. Extract the first element of a list, which must be\\nnon-empty.\\n"},{"functionSig":"(a -> b)","functionName":"arg0","functionDesc":""},{"functionSig":"[a]","functionName":"arg1","functionDesc":""}],"outError":""}\nComputation time: 4.530 sec\n'
5.98 OK
firstMatch: [a] -> (a -> Bool) -> a 600.11 FAIL
firstMaybe: [Maybe a] -> a b'running dfs on <a> . ([Maybe (a)] -> a) at size 1\nrunning dfs on <a> . ([Maybe (a)] -> a) at size 2\nrunning dfs on <a> . ([Maybe (a)] -> a) at size 3\n"_|_"\n"1"\n"2"\n"1"\n"1"\n"1"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["[Nothing, Just 1, Just 2]"],"output":"1"}],"solution":"\\\\arg0 -> GHC.List.head (Data.Maybe.catMaybes arg0)"}],"outDocs":[{"functionSig":"[Maybe a] -> [a]","functionName":"catMaybes","functionDesc":"The catMaybes function takes a list of Maybes and\\nreturns a list of all the Just values.\\n\\nExamples\\n\\nBasic usage:\\n\\n\\n>>> catMaybes [Just 1, Nothing, Just 3]\\n[1,3]\\n\\n\\nWhen constructing a list of Maybe values, catMaybes can\\nbe used to return all of the \\"success\\" results (if the list is the\\nresult of a map, then mapMaybe would be more\\nappropriate):\\n\\n\\n>>> import Text.Read ( readMaybe )\\n\\n>>> [readMaybe x :: Maybe Int | x <- [\\"1\\", \\"Foo\\", \\"3\\"] ]\\n[Just 1,Nothing,Just 3]\\n\\n>>> catMaybes $ [readMaybe x :: Maybe Int | x <- [\\"1\\", \\"Foo\\", \\"3\\"] ]\\n[1,3]\\n\\n"},{"functionSig":"[a] -> a","functionName":"head","functionDesc":"<math>. Extract the first element of a list, which must be\\nnon-empty.\\n"},{"functionSig":"[Maybe (a)]","functionName":"arg0","functionDesc":""}],"outError":""}\nComputation time: 1.928 sec\n'
2.60 OK
rights: [Either a b] -> Either a [b] 600.22 FAIL
firstKey: [(a,b)] -> a b'running dfs on <b> . <a> . ([(a , b)] -> a) at size 1\nrunning dfs on <b> . <a> . ([(a , b)] -> a) at size 2\nrunning dfs on <b> . <a> . ([(a , b)] -> a) at size 3\n"1"\n"1"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["[(1, [1,2,3]), (2, [2,3,4]), (4, [4,5,6])]"],"output":"1"}],"solution":"\\\\arg0 -> Data.Tuple.fst (GHC.List.head arg0)"}],"outDocs":[{"functionSig":"(a, b) -> a","functionName":"fst","functionDesc":"Extract the first component of a pair.\\n"},{"functionSig":"[a] -> a","functionName":"head","functionDesc":"<math>. Extract the first element of a list, which must be\\nnon-empty.\\n"},{"functionSig":"[(a , b)]","functionName":"arg0","functionDesc":""}],"outError":""}\nComputation time: 0.752 sec\n'
1.40 OK
firstRight: [Either a b] -> Either a b 600.22 FAIL
maybe: Maybe a -> a -> Maybe a b'running dfs on <a> . (Maybe (a) -> (a -> Maybe (a))) at size 1\nrunning dfs on <a> . (Maybe (a) -> (a -> Maybe (a))) at size 2\nrunning dfs on <a> . (Maybe (a) -> (a -> Maybe (a))) at size 3\nrunning dfs on <a> . (Maybe (a) -> (a -> Maybe (a))) at size 4\n"Just 2"\n"Just 1"\n"Just 2"\n"Just 1"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["Nothing","2"],"output":"Just 2"},{"inputs":["Just 1","2"],"output":"Just 1"}],"solution":"\\\\arg0 arg1 -> Data.Maybe.Just (Data.Maybe.fromMaybe arg1 arg0)"}],"outDocs":[{"functionSig":"a -> Maybe a","functionName":"Just","functionDesc":""},{"functionSig":"a -> Maybe a -> a","functionName":"fromMaybe","functionDesc":"The fromMaybe function takes a default value and and\\nMaybe value. If the Maybe is Nothing, it returns\\nthe default values; otherwise, it returns the value contained in the\\nMaybe.\\n\\nExamples\\n\\nBasic usage:\\n\\n\\n>>> fromMaybe \\"\\" (Just \\"Hello, World!\\")\\n\\"Hello, World!\\"\\n\\n\\n\\n>>> fromMaybe \\"\\" Nothing\\n\\"\\"\\n\\n\\nRead an integer from a string using readMaybe. If we fail to\\nparse an integer, we want to return 0 by default:\\n\\n\\n>>> import Text.Read ( readMaybe )\\n\\n>>> fromMaybe 0 (readMaybe \\"5\\")\\n5\\n\\n>>> fromMaybe 0 (readMaybe \\"\\")\\n0\\n\\n"},{"functionSig":"Maybe (a)","functionName":"arg0","functionDesc":""},{"functionSig":"a","functionName":"arg1","functionDesc":""}],"outError":""}\nComputation time: 7.299 sec\n'
8.20 OK
app3: (a -> b -> c -> d) -> a -> c -> b -> d b'running dfs on <d> . <c> . <b> . <a> . (((a -> (b -> (c -> d)))) -> (a -> (c -> (b -> d)))) at size 1\nrunning dfs on <d> . <c> . <b> . <a> . (((a -> (b -> (c -> d)))) -> (a -> (c -> (b -> d)))) at size 2\nrunning dfs on <d> . <c> . <b> . <a> . (((a -> (b -> (c -> d)))) -> (a -> (c -> (b -> d)))) at size 3\nrunning dfs on <d> . <c> . <b> . <a> . (((a -> (b -> (c -> d)))) -> (a -> (c -> (b -> d)))) at size 4\n"-20"\n"-20"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["\\\\x y z -> x + y - z","2","34","12"],"output":"-20"}],"solution":"\\\\arg0 arg1 arg2 arg3 -> arg0 arg1 arg3 arg2"}],"outDocs":[{"functionSig":"(a -> (b -> (c -> d)))","functionName":"arg0","functionDesc":""},{"functionSig":"a","functionName":"arg1","functionDesc":""},{"functionSig":"c","functionName":"arg2","functionDesc":""},{"functionSig":"b","functionName":"arg3","functionDesc":""}],"outError":""}\nComputation time: 3.396 sec\n'
4.06 OK
appendN: Int -> [a] -> [a] b'running dfs on <a> . (Int -> ([a] -> [a])) at size 1\nrunning dfs on <a> . (Int -> ([a] -> [a])) at size 2\nrunning dfs on <a> . (Int -> ([a] -> [a])) at size 3\n"[3]"\n"[1, 2, 3, 1, 2, 3]"\n"[1, 2]"\n"[1, 2, 3, 1, 2, 3]"\nrunning dfs on <a> . (Int -> ([a] -> [a])) at size 4\n"[1, 2, 3]"\n"[1, 2, 3, 1, 2, 3]"\n"[3]"\n"[1, 2, 3, 1, 2, 3]"\n"[1, 2]"\n"[1, 2, 3, 1, 2, 3]"\n"[1, 2]"\n"[1, 2, 3, 1, 2, 3]"\n"[3]"\n"[1, 2, 3, 1, 2, 3]"\n"[1, 2, 3, 1, 2, 3]"\n"[1, 2, 3, 1, 2, 3]"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["2","[1,2,3]"],"output":"[1,2,3,1,2,3]"}],"solution":"\\\\arg0 arg1 -> GHC.List.concat (GHC.List.replicate arg0 arg1)"}],"outDocs":[{"functionSig":"[[a]] -> [a]","functionName":"concat","functionDesc":"Concatenate a list of lists.\\n"},{"functionSig":"Int -> a -> [a]","functionName":"replicate","functionDesc":"replicate n x is a list of length n with\\nx the value of every element. It is an instance of the more\\ngeneral genericReplicate, in which n may be of any\\nintegral type.\\n"},{"functionSig":"Int","functionName":"arg0","functionDesc":""},{"functionSig":"[a]","functionName":"arg1","functionDesc":""}],"outError":""}\nComputation time: 18.538 sec\n'
19.94 OK
zipWithResult: (a->b)->[a]->[(a,b)] 600.15 FAIL
applyNtimes: (a->a) -> a -> Int -> a 600.20 FAIL
eitherTriple: Either a b -> Either a b -> Either a b 600.16 FAIL
pipe: [(a -> a)] -> (a -> a) 600.16 FAIL
lookup: Eq a => [(a,b)] -> a -> b b'running dfs on <b> . <a> . (@@hplusTC@@Eq (a) -> ([(a , b)] -> (a -> b))) at size 1\nrunning dfs on <b> . <a> . (@@hplusTC@@Eq (a) -> ([(a , b)] -> (a -> b))) at size 2\nrunning dfs on <b> . <a> . (@@hplusTC@@Eq (a) -> ([(a , b)] -> (a -> b))) at size 3\nrunning dfs on <b> . <a> . (@@hplusTC@@Eq (a) -> ([(a , b)] -> (a -> b))) at size 4\nrunning dfs on <b> . <a> . (@@hplusTC@@Eq (a) -> ([(a , b)] -> (a -> b))) at size 5\n"3"\n"3"\nRESULTS:{"outCandidates":[{"outExamples":[{"inputs":["[(1,2), (2,3), (4,6)]","2"],"output":"3"}],"solution":"\\\\arg0 arg1 -> Data.Maybe.fromJust (GHC.List.lookup arg1 arg0)"}],"outDocs":[{"functionSig":"HasCallStack => Maybe a -> a","functionName":"fromJust","functionDesc":"The fromJust function extracts the element out of a Just\\nand throws an error if its argument is Nothing.\\n\\nExamples\\n\\nBasic usage:\\n\\n\\n>>> fromJust (Just 1)\\n1\\n\\n\\n\\n>>> 2 * (fromJust (Just 10))\\n20\\n\\n\\n\\n>>> 2 * (fromJust Nothing)\\n*** Exception: Maybe.fromJust: Nothing\\n\\n"},{"functionSig":"Eq a => a -> [(a, b)] -> Maybe b","functionName":"lookup","functionDesc":"<math>. lookup key assocs looks up a key in an\\nassociation list.\\n\\n\\n>>> lookup 2 [(1, \\"first\\"), (2, \\"second\\"), (3, \\"third\\")]\\nJust \\"second\\"\\n\\n"},{"functionSig":"[(a , b)]","functionName":"arg0","functionDesc":""},{"functionSig":"a","functionName":"arg1","functionDesc":""},{"functionSig":"@@hplusTC@@Eq (a)","functionName":"tcarg0","functionDesc":""}],"outError":""}\nComputation time: 49.170 sec\n'
50.86 OK
mbElem: Eq a => a -> [a] -> Maybe a 600.19 FAIL
areEq: Eq a => a -> a -> Maybe a 600.15 FAIL
applyPair: (a -> b, a) -> b 600.25 FAIL
flatten: [[[a]]] -> [a] 600.28 FAIL
takeNdropM: Int -> Int -> [a] -> ([a], [a]) 600.15 FAIL
indexesOf: ([(a,Int)] -> [(a,Int)]) -> [a] -> [Int] -> [Int] 600.09 FAIL
containsEdge: [Int] -> (Int,Int) -> Bool 600.17 FAIL