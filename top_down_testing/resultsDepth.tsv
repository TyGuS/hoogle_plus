Name	Query	Time	Solution
appBoth	(a -> b) -> (a -> c) -> a -> (b, c)	16.97	\arg0 arg1 arg2 -> ((arg0 arg2) , (arg1 arg2))
test	Bool -> a -> Maybe a	599.71	-
both	(a -> b) -> (a, a) -> (b, b)	599.52	-
firstJust	a -> [Maybe a] -> a	599.44	-
mapEither	(a -> Either b c) -> [a] -> ([b], [c])	599.45	-
mapMaybes	(a -> Maybe b) -> [a] -> Maybe b	599.48	-
mergeEither	Either a (Either a b) -> Either a b	599.68	-
mbToEither	Maybe a -> b -> Either a b	599.53	-
cartProduct	[a] -> [b] -> [[(a,b)]]	599.62	-
multiAppPair	(a -> b, a -> c) -> a -> (b, c)	599.61	-
map	(a->b)->[a]->[b]	599.54	-
repl-funcs	(a->b)->Int->[a->b]	599.54	-
mbAppFirst	b -> (a -> b) -> [a] -> b	599.56	-
2partApp	(a->b)->(b->c)->[a]->[c]	599.53	-
resolveEither	Either a b -> (a->b) -> b	599.50	-
dedupe	Eq a => [a] -> [a]	599.78	-
inverseMap	[a -> b] -> a -> [b]	599.59	-
multiApp	(a -> b -> c) -> (a -> b) -> a -> c	13.75	\arg0 arg1 arg2 -> arg0 (Data.Function.const arg2 Data.ByteString.Lazy.empty) (arg1 arg2)
singleList	a -> [a]	2.21	\arg0 -> arg0 : []
head-last	[a] -> (a,a)	153.75	\arg0 -> ((GHC.List.head arg0) , (GHC.List.last arg0))
head-rest	[a] -> (a, [a])	119.56	\arg0 -> Data.Maybe.fromJust (GHC.List.uncons arg0)
pred-match	[a] -> (a -> Bool) -> Int	599.59	-
splitStr	String -> Char -> [String]	10.58	\arg0 arg1 -> (arg1 : []) : (arg0 : [])
splitAtFirst	a -> [a] -> ([a], [a])	599.46	-
hoogle01	(a -> b) -> [a] -> b	9.45	\arg0 arg1 -> arg0 (GHC.List.head arg1)
firstMatch	[a] -> (a -> Bool) -> a	599.54	-
firstMaybe	[Maybe a] -> a	20.52	\arg0 -> (Data.Maybe.catMaybes arg0) !! (GHC.List.length [])
rights	[Either a b] -> Either a [b]	599.69	-
firstKey	[(a,b)] -> a	109.83	\arg0 -> Data.Tuple.fst (GHC.List.head arg0)
firstRight	[Either a b] -> Either a b	599.58	-
maybe	Maybe a -> a -> Maybe a	184.28	\arg0 arg1 -> Data.Bool.bool (Data.Function.const arg0 Data.ByteString.Lazy.empty) (Data.Maybe.Just arg1) (Data.Maybe.isNothing arg0)
app3	(a -> b -> c -> d) -> a -> c -> b -> d	2.69	\arg0 arg1 arg2 arg3 -> arg0 arg1 arg3 arg2
appendN	Int -> [a] -> [a]	112.75	\arg0 arg1 -> (arg1 ++ arg1) ++ (GHC.List.drop arg0 [])
zipWithResult	(a->b)->[a]->[(a,b)]	599.52	-
applyNtimes	(a->a) -> a -> Int -> a	599.65	-
eitherTriple	Either a b -> Either a b -> Either a b	599.64	-
pipe	[(a -> a)] -> (a -> a)	599.58	-
lookup	Eq a => [(a,b)] -> a -> b	22.73	\arg0 arg1 -> Data.Maybe.fromJust (GHC.List.lookup arg1 arg0)
mbElem	Eq a => a -> [a] -> Maybe a	599.51	-
areEq	Eq a => a -> a -> Maybe a	599.69	-
applyPair	(a -> b, a) -> b	599.64	-
flatten	[[[a]]] -> [a]	599.69	-
takeNdropM	Int -> Int -> [a] -> ([a], [a])	599.73	-
indexesOf	([(a,Int)] -> [(a,Int)]) -> [a] -> [Int] -> [Int]	599.58	-
containsEdge	[Int] -> (Int,Int) -> Bool	599.70	-
