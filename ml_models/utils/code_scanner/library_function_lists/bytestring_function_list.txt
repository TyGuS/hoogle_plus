bytestring
Data.ByteString.Short
DataDecl () (DataType ()) Nothing (DHead () (Ident () "ShortByteString")) [] []
Data.ByteString.Short.toShort :: (ByteString -> ShortByteString)
Data.ByteString.Short.fromShort :: (ShortByteString -> ByteString)
Data.ByteString.Short.pack :: (List (Word8) -> ShortByteString)
Data.ByteString.Short.unpack :: (ShortByteString -> List (Word8))
Data.ByteString.Short.empty :: ShortByteString
Data.ByteString.Short.null :: (ShortByteString -> Bool)
Data.ByteString.Short.length :: (ShortByteString -> Int)
Data.ByteString.Short.index :: (ShortByteString -> (Int -> Word8))
Data.ByteString.Unsafe
Data.ByteString.Unsafe.unsafeHead :: (ByteString -> Word8)
Data.ByteString.Unsafe.unsafeTail :: (ByteString -> ByteString)
Data.ByteString.Unsafe.unsafeInit :: (ByteString -> ByteString)
Data.ByteString.Unsafe.unsafeLast :: (ByteString -> Word8)
Data.ByteString.Unsafe.unsafeIndex :: (ByteString -> (Int -> Word8))
Data.ByteString.Unsafe.unsafeTake :: (Int -> (ByteString -> ByteString))
Data.ByteString.Unsafe.unsafeDrop :: (Int -> (ByteString -> ByteString))
Data.ByteString.Unsafe.unsafeUseAsCString :: <a> . (ByteString -> ((CString -> IO (a)) -> IO (a)))
Data.ByteString.Unsafe.unsafeUseAsCStringLen :: <a> . (ByteString -> ((CStringLen -> IO (a)) -> IO (a)))
Data.ByteString.Unsafe.unsafePackCString :: (CString -> IO (ByteString))
Data.ByteString.Unsafe.unsafePackCStringLen :: (CStringLen -> IO (ByteString))
Data.ByteString.Unsafe.unsafePackMallocCString :: (CString -> IO (ByteString))
Data.ByteString.Unsafe.unsafePackMallocCStringLen :: (CStringLen -> IO (ByteString))
Data.ByteString.Unsafe.unsafePackAddress :: (Addr# -> IO (ByteString))
Data.ByteString.Unsafe.unsafePackAddressLen :: (Int -> (Addr# -> IO (ByteString)))
Data.ByteString.Unsafe.unsafePackCStringFinalizer :: (Ptr (Word8) -> (Int -> (IO (Unit) -> IO (ByteString))))
Data.ByteString.Unsafe.unsafeFinalize :: (ByteString -> IO (Unit))
Data.ByteString
DataDecl () (DataType ()) Nothing (DHead () (Ident () "ByteString")) [] []
Data.ByteString.empty :: ByteString
Data.ByteString.singleton :: (Word8 -> ByteString)
Data.ByteString.pack :: (List (Word8) -> ByteString)
Data.ByteString.unpack :: (ByteString -> List (Word8))
Data.ByteString.cons :: (Word8 -> (ByteString -> ByteString))
InfixDecl () (AssocRight ()) (Just 5) [VarOp () (Ident () "cons")]
Data.ByteString.snoc :: (ByteString -> (Word8 -> ByteString))
InfixDecl () (AssocLeft ()) (Just 5) [VarOp () (Ident () "snoc")]
Data.ByteString.append :: (ByteString -> (ByteString -> ByteString))
Data.ByteString.head :: (ByteString -> Word8)
Data.ByteString.uncons :: (ByteString -> Maybe (Pair (Word8) (ByteString)))
Data.ByteString.unsnoc :: (ByteString -> Maybe (Pair (ByteString) (Word8)))
Data.ByteString.last :: (ByteString -> Word8)
Data.ByteString.tail :: (ByteString -> ByteString)
Data.ByteString.init :: (ByteString -> ByteString)
Data.ByteString.null :: (ByteString -> Bool)
Data.ByteString.length :: (ByteString -> Int)
Data.ByteString.map :: ((Word8 -> Word8) -> (ByteString -> ByteString))
Data.ByteString.reverse :: (ByteString -> ByteString)
Data.ByteString.intersperse :: (Word8 -> (ByteString -> ByteString))
Data.ByteString.intercalate :: (ByteString -> (List (ByteString) -> ByteString))
Data.ByteString.transpose :: (List (ByteString) -> List (ByteString))
Data.ByteString.foldl :: <a> . ((a -> (Word8 -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.foldl' :: <a> . ((a -> (Word8 -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.foldl1 :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> Word8))
Data.ByteString.foldl1' :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> Word8))
Data.ByteString.foldr :: <a> . ((Word8 -> (a -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.foldr' :: <a> . ((Word8 -> (a -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.foldr1 :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> Word8))
Data.ByteString.foldr1' :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> Word8))
Data.ByteString.concat :: (List (ByteString) -> ByteString)
Data.ByteString.concatMap :: ((Word8 -> ByteString) -> (ByteString -> ByteString))
Data.ByteString.any :: ((Word8 -> Bool) -> (ByteString -> Bool))
Data.ByteString.all :: ((Word8 -> Bool) -> (ByteString -> Bool))
Data.ByteString.maximum :: (ByteString -> Word8)
Data.ByteString.minimum :: (ByteString -> Word8)
Data.ByteString.scanl :: ((Word8 -> (Word8 -> Word8)) -> (Word8 -> (ByteString -> ByteString)))
Data.ByteString.scanl1 :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> ByteString))
Data.ByteString.scanr :: ((Word8 -> (Word8 -> Word8)) -> (Word8 -> (ByteString -> ByteString)))
Data.ByteString.scanr1 :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> ByteString))
Data.ByteString.mapAccumL :: <acc> . ((acc -> (Word8 -> Pair (acc) (Word8))) -> (acc -> (ByteString -> Pair (acc) (ByteString))))
Data.ByteString.mapAccumR :: <acc> . ((acc -> (Word8 -> Pair (acc) (Word8))) -> (acc -> (ByteString -> Pair (acc) (ByteString))))
Data.ByteString.replicate :: (Int -> (Word8 -> ByteString))
Data.ByteString.unfoldr :: <a> . ((a -> Maybe (Pair (Word8) (a))) -> (a -> ByteString))
Data.ByteString.unfoldrN :: <a> . (Int -> ((a -> Maybe (Pair (Word8) (a))) -> (a -> Pair (ByteString) (Maybe (a)))))
Data.ByteString.take :: (Int -> (ByteString -> ByteString))
Data.ByteString.drop :: (Int -> (ByteString -> ByteString))
Data.ByteString.splitAt :: (Int -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.takeWhile :: ((Word8 -> Bool) -> (ByteString -> ByteString))
Data.ByteString.dropWhile :: ((Word8 -> Bool) -> (ByteString -> ByteString))
Data.ByteString.span :: ((Word8 -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.spanEnd :: ((Word8 -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.break :: ((Word8 -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.breakEnd :: ((Word8 -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.group :: (ByteString -> List (ByteString))
Data.ByteString.groupBy :: ((Word8 -> (Word8 -> Bool)) -> (ByteString -> List (ByteString)))
Data.ByteString.inits :: (ByteString -> List (ByteString))
Data.ByteString.tails :: (ByteString -> List (ByteString))
Data.ByteString.stripPrefix :: (ByteString -> (ByteString -> Maybe (ByteString)))
Data.ByteString.stripSuffix :: (ByteString -> (ByteString -> Maybe (ByteString)))
Data.ByteString.split :: (Word8 -> (ByteString -> List (ByteString)))
Data.ByteString.splitWith :: ((Word8 -> Bool) -> (ByteString -> List (ByteString)))
Data.ByteString.isPrefixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.isSuffixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.isInfixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.breakSubstring :: (ByteString -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.findSubstring :: (ByteString -> (ByteString -> Maybe (Int)))
Data.ByteString.findSubstrings :: (ByteString -> (ByteString -> List (Int)))
Data.ByteString.elem :: (Word8 -> (ByteString -> Bool))
Data.ByteString.notElem :: (Word8 -> (ByteString -> Bool))
Data.ByteString.find :: ((Word8 -> Bool) -> (ByteString -> Maybe (Word8)))
Data.ByteString.filter :: ((Word8 -> Bool) -> (ByteString -> ByteString))
Data.ByteString.partition :: ((Word8 -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.index :: (ByteString -> (Int -> Word8))
Data.ByteString.elemIndex :: (Word8 -> (ByteString -> Maybe (Int)))
Data.ByteString.elemIndices :: (Word8 -> (ByteString -> List (Int)))
Data.ByteString.elemIndexEnd :: (Word8 -> (ByteString -> Maybe (Int)))
Data.ByteString.findIndex :: ((Word8 -> Bool) -> (ByteString -> Maybe (Int)))
Data.ByteString.findIndices :: ((Word8 -> Bool) -> (ByteString -> List (Int)))
Data.ByteString.count :: (Word8 -> (ByteString -> Int))
Data.ByteString.zip :: (ByteString -> (ByteString -> List (Pair (Word8) (Word8))))
Data.ByteString.zipWith :: <a> . ((Word8 -> (Word8 -> a)) -> (ByteString -> (ByteString -> List (a))))
Data.ByteString.unzip :: (List (Pair (Word8) (Word8)) -> Pair (ByteString) (ByteString))
Data.ByteString.sort :: (ByteString -> ByteString)
Data.ByteString.copy :: (ByteString -> ByteString)
Data.ByteString.packCString :: (CString -> IO (ByteString))
Data.ByteString.packCStringLen :: (CStringLen -> IO (ByteString))
Data.ByteString.useAsCString :: <a> . (ByteString -> ((CString -> IO (a)) -> IO (a)))
Data.ByteString.useAsCStringLen :: <a> . (ByteString -> ((CStringLen -> IO (a)) -> IO (a)))
Data.ByteString.getLine :: IO (ByteString)
Data.ByteString.getContents :: IO (ByteString)
Data.ByteString.putStr :: (ByteString -> IO (Unit))
Data.ByteString.putStrLn :: (ByteString -> IO (Unit))
Data.ByteString.interact :: ((ByteString -> ByteString) -> IO (Unit))
Data.ByteString.readFile :: (FilePath -> IO (ByteString))
Data.ByteString.writeFile :: (FilePath -> (ByteString -> IO (Unit)))
Data.ByteString.appendFile :: (FilePath -> (ByteString -> IO (Unit)))
Data.ByteString.hGetLine :: (Handle -> IO (ByteString))
Data.ByteString.hGetContents :: (Handle -> IO (ByteString))
Data.ByteString.hGet :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.hGetSome :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.hGetNonBlocking :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.hPut :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.hPutNonBlocking :: (Handle -> (ByteString -> IO (ByteString)))
Data.ByteString.hPutStr :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.hPutStrLn :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.breakByte :: (Word8 -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Lazy
DataDecl () (DataType ()) Nothing (DHead () (Ident () "ByteString")) [] []
Data.ByteString.Lazy.empty :: ByteString
Data.ByteString.Lazy.singleton :: (Word8 -> ByteString)
Data.ByteString.Lazy.pack :: (List (Word8) -> ByteString)
Data.ByteString.Lazy.unpack :: (ByteString -> List (Word8))
Data.ByteString.Lazy.fromStrict :: (ByteString -> ByteString)
Data.ByteString.Lazy.toStrict :: (ByteString -> ByteString)
Data.ByteString.Lazy.fromChunks :: (List (ByteString) -> ByteString)
Data.ByteString.Lazy.toChunks :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.foldrChunks :: <a> . ((ByteString -> (a -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Lazy.foldlChunks :: <a> . ((a -> (ByteString -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Lazy.cons :: (Word8 -> (ByteString -> ByteString))
InfixDecl () (AssocRight ()) (Just 5) [VarOp () (Ident () "cons")]
Data.ByteString.Lazy.cons' :: (Word8 -> (ByteString -> ByteString))
InfixDecl () (AssocRight ()) (Just 5) [VarOp () (Ident () "cons'")]
Data.ByteString.Lazy.snoc :: (ByteString -> (Word8 -> ByteString))
InfixDecl () (AssocLeft ()) (Just 5) [VarOp () (Ident () "snoc")]
Data.ByteString.Lazy.append :: (ByteString -> (ByteString -> ByteString))
Data.ByteString.Lazy.head :: (ByteString -> Word8)
Data.ByteString.Lazy.uncons :: (ByteString -> Maybe (Pair (Word8) (ByteString)))
Data.ByteString.Lazy.unsnoc :: (ByteString -> Maybe (Pair (ByteString) (Word8)))
Data.ByteString.Lazy.last :: (ByteString -> Word8)
Data.ByteString.Lazy.tail :: (ByteString -> ByteString)
Data.ByteString.Lazy.init :: (ByteString -> ByteString)
Data.ByteString.Lazy.null :: (ByteString -> Bool)
Data.ByteString.Lazy.length :: (ByteString -> Int64)
Data.ByteString.Lazy.map :: ((Word8 -> Word8) -> (ByteString -> ByteString))
Data.ByteString.Lazy.reverse :: (ByteString -> ByteString)
Data.ByteString.Lazy.intersperse :: (Word8 -> (ByteString -> ByteString))
Data.ByteString.Lazy.intercalate :: (ByteString -> (List (ByteString) -> ByteString))
Data.ByteString.Lazy.transpose :: (List (ByteString) -> List (ByteString))
Data.ByteString.Lazy.foldl :: <a> . ((a -> (Word8 -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Lazy.foldl' :: <a> . ((a -> (Word8 -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Lazy.foldl1 :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> Word8))
Data.ByteString.Lazy.foldl1' :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> Word8))
Data.ByteString.Lazy.foldr :: <a> . ((Word8 -> (a -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Lazy.foldr1 :: ((Word8 -> (Word8 -> Word8)) -> (ByteString -> Word8))
Data.ByteString.Lazy.concat :: (List (ByteString) -> ByteString)
Data.ByteString.Lazy.concatMap :: ((Word8 -> ByteString) -> (ByteString -> ByteString))
Data.ByteString.Lazy.any :: ((Word8 -> Bool) -> (ByteString -> Bool))
Data.ByteString.Lazy.all :: ((Word8 -> Bool) -> (ByteString -> Bool))
Data.ByteString.Lazy.maximum :: (ByteString -> Word8)
Data.ByteString.Lazy.minimum :: (ByteString -> Word8)
Data.ByteString.Lazy.scanl :: ((Word8 -> (Word8 -> Word8)) -> (Word8 -> (ByteString -> ByteString)))
Data.ByteString.Lazy.mapAccumL :: <acc> . ((acc -> (Word8 -> Pair (acc) (Word8))) -> (acc -> (ByteString -> Pair (acc) (ByteString))))
Data.ByteString.Lazy.mapAccumR :: <acc> . ((acc -> (Word8 -> Pair (acc) (Word8))) -> (acc -> (ByteString -> Pair (acc) (ByteString))))
Data.ByteString.Lazy.repeat :: (Word8 -> ByteString)
Data.ByteString.Lazy.replicate :: (Int64 -> (Word8 -> ByteString))
Data.ByteString.Lazy.cycle :: (ByteString -> ByteString)
Data.ByteString.Lazy.iterate :: ((Word8 -> Word8) -> (Word8 -> ByteString))
Data.ByteString.Lazy.unfoldr :: <a> . ((a -> Maybe (Pair (Word8) (a))) -> (a -> ByteString))
Data.ByteString.Lazy.take :: (Int64 -> (ByteString -> ByteString))
Data.ByteString.Lazy.drop :: (Int64 -> (ByteString -> ByteString))
Data.ByteString.Lazy.splitAt :: (Int64 -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Lazy.takeWhile :: ((Word8 -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Lazy.dropWhile :: ((Word8 -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Lazy.span :: ((Word8 -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Lazy.break :: ((Word8 -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Lazy.group :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.groupBy :: ((Word8 -> (Word8 -> Bool)) -> (ByteString -> List (ByteString)))
Data.ByteString.Lazy.inits :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.tails :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.stripPrefix :: (ByteString -> (ByteString -> Maybe (ByteString)))
Data.ByteString.Lazy.stripSuffix :: (ByteString -> (ByteString -> Maybe (ByteString)))
Data.ByteString.Lazy.split :: (Word8 -> (ByteString -> List (ByteString)))
Data.ByteString.Lazy.splitWith :: ((Word8 -> Bool) -> (ByteString -> List (ByteString)))
Data.ByteString.Lazy.isPrefixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.Lazy.isSuffixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.Lazy.elem :: (Word8 -> (ByteString -> Bool))
Data.ByteString.Lazy.notElem :: (Word8 -> (ByteString -> Bool))
Data.ByteString.Lazy.find :: ((Word8 -> Bool) -> (ByteString -> Maybe (Word8)))
Data.ByteString.Lazy.filter :: ((Word8 -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Lazy.partition :: ((Word8 -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Lazy.index :: (ByteString -> (Int64 -> Word8))
Data.ByteString.Lazy.elemIndex :: (Word8 -> (ByteString -> Maybe (Int64)))
Data.ByteString.Lazy.elemIndexEnd :: (Word8 -> (ByteString -> Maybe (Int64)))
Data.ByteString.Lazy.elemIndices :: (Word8 -> (ByteString -> List (Int64)))
Data.ByteString.Lazy.findIndex :: ((Word8 -> Bool) -> (ByteString -> Maybe (Int64)))
Data.ByteString.Lazy.findIndices :: ((Word8 -> Bool) -> (ByteString -> List (Int64)))
Data.ByteString.Lazy.count :: (Word8 -> (ByteString -> Int64))
Data.ByteString.Lazy.zip :: (ByteString -> (ByteString -> List (Pair (Word8) (Word8))))
Data.ByteString.Lazy.zipWith :: <a> . ((Word8 -> (Word8 -> a)) -> (ByteString -> (ByteString -> List (a))))
Data.ByteString.Lazy.unzip :: (List (Pair (Word8) (Word8)) -> Pair (ByteString) (ByteString))
Data.ByteString.Lazy.copy :: (ByteString -> ByteString)
Data.ByteString.Lazy.getContents :: IO (ByteString)
Data.ByteString.Lazy.putStr :: (ByteString -> IO (Unit))
Data.ByteString.Lazy.putStrLn :: (ByteString -> IO (Unit))
Data.ByteString.Lazy.interact :: ((ByteString -> ByteString) -> IO (Unit))
Data.ByteString.Lazy.readFile :: (FilePath -> IO (ByteString))
Data.ByteString.Lazy.writeFile :: (FilePath -> (ByteString -> IO (Unit)))
Data.ByteString.Lazy.appendFile :: (FilePath -> (ByteString -> IO (Unit)))
Data.ByteString.Lazy.hGetContents :: (Handle -> IO (ByteString))
Data.ByteString.Lazy.hGet :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.Lazy.hGetNonBlocking :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.Lazy.hPut :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.Lazy.hPutNonBlocking :: (Handle -> (ByteString -> IO (ByteString)))
Data.ByteString.Lazy.hPutStr :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.Lazy.Char8
DataDecl () (DataType ()) Nothing (DHead () (Ident () "ByteString")) [] []
Data.ByteString.Lazy.Char8.empty :: ByteString
Data.ByteString.Lazy.Char8.singleton :: (Char -> ByteString)
Data.ByteString.Lazy.Char8.pack :: (List (Char) -> ByteString)
Data.ByteString.Lazy.Char8.unpack :: (ByteString -> List (Char))
Data.ByteString.Lazy.Char8.fromChunks :: (List (ByteString) -> ByteString)
Data.ByteString.Lazy.Char8.toChunks :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.Char8.fromStrict :: (ByteString -> ByteString)
Data.ByteString.Lazy.Char8.toStrict :: (ByteString -> ByteString)
Data.ByteString.Lazy.Char8.cons :: (Char -> (ByteString -> ByteString))
InfixDecl () (AssocRight ()) (Just 5) [VarOp () (Ident () "cons")]
Data.ByteString.Lazy.Char8.cons' :: (Char -> (ByteString -> ByteString))
InfixDecl () (AssocRight ()) (Just 5) [VarOp () (Ident () "cons'")]
Data.ByteString.Lazy.Char8.snoc :: (ByteString -> (Char -> ByteString))
InfixDecl () (AssocLeft ()) (Just 5) [VarOp () (Ident () "snoc")]
Data.ByteString.Lazy.Char8.append :: (ByteString -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.head :: (ByteString -> Char)
Data.ByteString.Lazy.Char8.uncons :: (ByteString -> Maybe (Pair (Char) (ByteString)))
Data.ByteString.Lazy.Char8.last :: (ByteString -> Char)
Data.ByteString.Lazy.Char8.tail :: (ByteString -> ByteString)
Data.ByteString.Lazy.Char8.unsnoc :: (ByteString -> Maybe (Pair (ByteString) (Char)))
Data.ByteString.Lazy.Char8.init :: (ByteString -> ByteString)
Data.ByteString.Lazy.Char8.null :: (ByteString -> Bool)
Data.ByteString.Lazy.Char8.length :: (ByteString -> Int64)
Data.ByteString.Lazy.Char8.map :: ((Char -> Char) -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.reverse :: (ByteString -> ByteString)
Data.ByteString.Lazy.Char8.intersperse :: (Char -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.intercalate :: (ByteString -> (List (ByteString) -> ByteString))
Data.ByteString.Lazy.Char8.transpose :: (List (ByteString) -> List (ByteString))
Data.ByteString.Lazy.Char8.foldl :: <a> . ((a -> (Char -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Lazy.Char8.foldl' :: <a> . ((a -> (Char -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Lazy.Char8.foldl1 :: ((Char -> (Char -> Char)) -> (ByteString -> Char))
Data.ByteString.Lazy.Char8.foldl1' :: ((Char -> (Char -> Char)) -> (ByteString -> Char))
Data.ByteString.Lazy.Char8.foldr :: <a> . ((Char -> (a -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Lazy.Char8.foldr1 :: ((Char -> (Char -> Char)) -> (ByteString -> Char))
Data.ByteString.Lazy.Char8.concat :: (List (ByteString) -> ByteString)
Data.ByteString.Lazy.Char8.concatMap :: ((Char -> ByteString) -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.any :: ((Char -> Bool) -> (ByteString -> Bool))
Data.ByteString.Lazy.Char8.all :: ((Char -> Bool) -> (ByteString -> Bool))
Data.ByteString.Lazy.Char8.maximum :: (ByteString -> Char)
Data.ByteString.Lazy.Char8.minimum :: (ByteString -> Char)
Data.ByteString.Lazy.Char8.scanl :: ((Char -> (Char -> Char)) -> (Char -> (ByteString -> ByteString)))
Data.ByteString.Lazy.Char8.mapAccumL :: <acc> . ((acc -> (Char -> Pair (acc) (Char))) -> (acc -> (ByteString -> Pair (acc) (ByteString))))
Data.ByteString.Lazy.Char8.mapAccumR :: <acc> . ((acc -> (Char -> Pair (acc) (Char))) -> (acc -> (ByteString -> Pair (acc) (ByteString))))
Data.ByteString.Lazy.Char8.repeat :: (Char -> ByteString)
Data.ByteString.Lazy.Char8.replicate :: (Int64 -> (Char -> ByteString))
Data.ByteString.Lazy.Char8.cycle :: (ByteString -> ByteString)
Data.ByteString.Lazy.Char8.iterate :: ((Char -> Char) -> (Char -> ByteString))
Data.ByteString.Lazy.Char8.unfoldr :: <a> . ((a -> Maybe (Pair (Char) (a))) -> (a -> ByteString))
Data.ByteString.Lazy.Char8.take :: (Int64 -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.drop :: (Int64 -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.splitAt :: (Int64 -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Lazy.Char8.takeWhile :: ((Char -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.dropWhile :: ((Char -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.span :: ((Char -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Lazy.Char8.break :: ((Char -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Lazy.Char8.group :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.Char8.groupBy :: ((Char -> (Char -> Bool)) -> (ByteString -> List (ByteString)))
Data.ByteString.Lazy.Char8.inits :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.Char8.tails :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.Char8.stripPrefix :: (ByteString -> (ByteString -> Maybe (ByteString)))
Data.ByteString.Lazy.Char8.stripSuffix :: (ByteString -> (ByteString -> Maybe (ByteString)))
Data.ByteString.Lazy.Char8.split :: (Char -> (ByteString -> List (ByteString)))
Data.ByteString.Lazy.Char8.splitWith :: ((Char -> Bool) -> (ByteString -> List (ByteString)))
Data.ByteString.Lazy.Char8.lines :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.Char8.words :: (ByteString -> List (ByteString))
Data.ByteString.Lazy.Char8.unlines :: (List (ByteString) -> ByteString)
Data.ByteString.Lazy.Char8.unwords :: (List (ByteString) -> ByteString)
Data.ByteString.Lazy.Char8.isPrefixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.Lazy.Char8.isSuffixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.Lazy.Char8.elem :: (Char -> (ByteString -> Bool))
Data.ByteString.Lazy.Char8.notElem :: (Char -> (ByteString -> Bool))
Data.ByteString.Lazy.Char8.find :: ((Char -> Bool) -> (ByteString -> Maybe (Char)))
Data.ByteString.Lazy.Char8.filter :: ((Char -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Lazy.Char8.index :: (ByteString -> (Int64 -> Char))
Data.ByteString.Lazy.Char8.elemIndex :: (Char -> (ByteString -> Maybe (Int64)))
Data.ByteString.Lazy.Char8.elemIndices :: (Char -> (ByteString -> List (Int64)))
Data.ByteString.Lazy.Char8.findIndex :: ((Char -> Bool) -> (ByteString -> Maybe (Int64)))
Data.ByteString.Lazy.Char8.findIndices :: ((Char -> Bool) -> (ByteString -> List (Int64)))
Data.ByteString.Lazy.Char8.count :: (Char -> (ByteString -> Int64))
Data.ByteString.Lazy.Char8.zip :: (ByteString -> (ByteString -> List (Pair (Char) (Char))))
Data.ByteString.Lazy.Char8.zipWith :: <a> . ((Char -> (Char -> a)) -> (ByteString -> (ByteString -> List (a))))
Data.ByteString.Lazy.Char8.copy :: (ByteString -> ByteString)
Data.ByteString.Lazy.Char8.readInt :: (ByteString -> Maybe (Pair (Int) (ByteString)))
Data.ByteString.Lazy.Char8.readInteger :: (ByteString -> Maybe (Pair (Integer) (ByteString)))
Data.ByteString.Lazy.Char8.getContents :: IO (ByteString)
Data.ByteString.Lazy.Char8.putStr :: (ByteString -> IO (Unit))
Data.ByteString.Lazy.Char8.putStrLn :: (ByteString -> IO (Unit))
Data.ByteString.Lazy.Char8.interact :: ((ByteString -> ByteString) -> IO (Unit))
Data.ByteString.Lazy.Char8.readFile :: (FilePath -> IO (ByteString))
Data.ByteString.Lazy.Char8.writeFile :: (FilePath -> (ByteString -> IO (Unit)))
Data.ByteString.Lazy.Char8.appendFile :: (FilePath -> (ByteString -> IO (Unit)))
Data.ByteString.Lazy.Char8.hGetContents :: (Handle -> IO (ByteString))
Data.ByteString.Lazy.Char8.hGet :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.Lazy.Char8.hGetNonBlocking :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.Lazy.Char8.hPut :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.Lazy.Char8.hPutNonBlocking :: (Handle -> (ByteString -> IO (ByteString)))
Data.ByteString.Lazy.Char8.hPutStr :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.Lazy.Char8.hPutStrLn :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.Char8
DataDecl () (DataType ()) Nothing (DHead () (Ident () "ByteString")) [] []
Data.ByteString.Char8.empty :: ByteString
Data.ByteString.Char8.singleton :: (Char -> ByteString)
Data.ByteString.Char8.pack :: (String -> ByteString)
Data.ByteString.Char8.unpack :: (ByteString -> List (Char))
Data.ByteString.Char8.cons :: (Char -> (ByteString -> ByteString))
InfixDecl () (AssocRight ()) (Just 5) [VarOp () (Ident () "cons")]
Data.ByteString.Char8.snoc :: (ByteString -> (Char -> ByteString))
InfixDecl () (AssocLeft ()) (Just 5) [VarOp () (Ident () "snoc")]
Data.ByteString.Char8.append :: (ByteString -> (ByteString -> ByteString))
Data.ByteString.Char8.head :: (ByteString -> Char)
Data.ByteString.Char8.uncons :: (ByteString -> Maybe (Pair (Char) (ByteString)))
Data.ByteString.Char8.unsnoc :: (ByteString -> Maybe (Pair (ByteString) (Char)))
Data.ByteString.Char8.last :: (ByteString -> Char)
Data.ByteString.Char8.tail :: (ByteString -> ByteString)
Data.ByteString.Char8.init :: (ByteString -> ByteString)
Data.ByteString.Char8.null :: (ByteString -> Bool)
Data.ByteString.Char8.length :: (ByteString -> Int)
Data.ByteString.Char8.map :: ((Char -> Char) -> (ByteString -> ByteString))
Data.ByteString.Char8.reverse :: (ByteString -> ByteString)
Data.ByteString.Char8.intersperse :: (Char -> (ByteString -> ByteString))
Data.ByteString.Char8.intercalate :: (ByteString -> (List (ByteString) -> ByteString))
Data.ByteString.Char8.transpose :: (List (ByteString) -> List (ByteString))
Data.ByteString.Char8.foldl :: <a> . ((a -> (Char -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Char8.foldl' :: <a> . ((a -> (Char -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Char8.foldl1 :: ((Char -> (Char -> Char)) -> (ByteString -> Char))
Data.ByteString.Char8.foldl1' :: ((Char -> (Char -> Char)) -> (ByteString -> Char))
Data.ByteString.Char8.foldr :: <a> . ((Char -> (a -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Char8.foldr' :: <a> . ((Char -> (a -> a)) -> (a -> (ByteString -> a)))
Data.ByteString.Char8.foldr1 :: ((Char -> (Char -> Char)) -> (ByteString -> Char))
Data.ByteString.Char8.foldr1' :: ((Char -> (Char -> Char)) -> (ByteString -> Char))
Data.ByteString.Char8.concat :: (List (ByteString) -> ByteString)
Data.ByteString.Char8.concatMap :: ((Char -> ByteString) -> (ByteString -> ByteString))
Data.ByteString.Char8.any :: ((Char -> Bool) -> (ByteString -> Bool))
Data.ByteString.Char8.all :: ((Char -> Bool) -> (ByteString -> Bool))
Data.ByteString.Char8.maximum :: (ByteString -> Char)
Data.ByteString.Char8.minimum :: (ByteString -> Char)
Data.ByteString.Char8.scanl :: ((Char -> (Char -> Char)) -> (Char -> (ByteString -> ByteString)))
Data.ByteString.Char8.scanl1 :: ((Char -> (Char -> Char)) -> (ByteString -> ByteString))
Data.ByteString.Char8.scanr :: ((Char -> (Char -> Char)) -> (Char -> (ByteString -> ByteString)))
Data.ByteString.Char8.scanr1 :: ((Char -> (Char -> Char)) -> (ByteString -> ByteString))
Data.ByteString.Char8.mapAccumL :: <acc> . ((acc -> (Char -> Pair (acc) (Char))) -> (acc -> (ByteString -> Pair (acc) (ByteString))))
Data.ByteString.Char8.mapAccumR :: <acc> . ((acc -> (Char -> Pair (acc) (Char))) -> (acc -> (ByteString -> Pair (acc) (ByteString))))
Data.ByteString.Char8.replicate :: (Int -> (Char -> ByteString))
Data.ByteString.Char8.unfoldr :: <a> . ((a -> Maybe (Pair (Char) (a))) -> (a -> ByteString))
Data.ByteString.Char8.unfoldrN :: <a> . (Int -> ((a -> Maybe (Pair (Char) (a))) -> (a -> Pair (ByteString) (Maybe (a)))))
Data.ByteString.Char8.take :: (Int -> (ByteString -> ByteString))
Data.ByteString.Char8.drop :: (Int -> (ByteString -> ByteString))
Data.ByteString.Char8.splitAt :: (Int -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Char8.takeWhile :: ((Char -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Char8.dropWhile :: ((Char -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Char8.span :: ((Char -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Char8.spanEnd :: ((Char -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Char8.break :: ((Char -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Char8.breakEnd :: ((Char -> Bool) -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Char8.group :: (ByteString -> List (ByteString))
Data.ByteString.Char8.groupBy :: ((Char -> (Char -> Bool)) -> (ByteString -> List (ByteString)))
Data.ByteString.Char8.inits :: (ByteString -> List (ByteString))
Data.ByteString.Char8.tails :: (ByteString -> List (ByteString))
Data.ByteString.Char8.stripPrefix :: (ByteString -> (ByteString -> Maybe (ByteString)))
Data.ByteString.Char8.stripSuffix :: (ByteString -> (ByteString -> Maybe (ByteString)))
Data.ByteString.Char8.split :: (Char -> (ByteString -> List (ByteString)))
Data.ByteString.Char8.splitWith :: ((Char -> Bool) -> (ByteString -> List (ByteString)))
Data.ByteString.Char8.lines :: (ByteString -> List (ByteString))
Data.ByteString.Char8.words :: (ByteString -> List (ByteString))
Data.ByteString.Char8.unlines :: (List (ByteString) -> ByteString)
Data.ByteString.Char8.unwords :: (List (ByteString) -> ByteString)
Data.ByteString.Char8.isPrefixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.Char8.isSuffixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.Char8.isInfixOf :: (ByteString -> (ByteString -> Bool))
Data.ByteString.Char8.breakSubstring :: (ByteString -> (ByteString -> Pair (ByteString) (ByteString)))
Data.ByteString.Char8.findSubstring :: (ByteString -> (ByteString -> Maybe (Int)))
Data.ByteString.Char8.findSubstrings :: (ByteString -> (ByteString -> List (Int)))
Data.ByteString.Char8.elem :: (Char -> (ByteString -> Bool))
Data.ByteString.Char8.notElem :: (Char -> (ByteString -> Bool))
Data.ByteString.Char8.find :: ((Char -> Bool) -> (ByteString -> Maybe (Char)))
Data.ByteString.Char8.filter :: ((Char -> Bool) -> (ByteString -> ByteString))
Data.ByteString.Char8.index :: (ByteString -> (Int -> Char))
Data.ByteString.Char8.elemIndex :: (Char -> (ByteString -> Maybe (Int)))
Data.ByteString.Char8.elemIndices :: (Char -> (ByteString -> List (Int)))
Data.ByteString.Char8.elemIndexEnd :: (Char -> (ByteString -> Maybe (Int)))
Data.ByteString.Char8.findIndex :: ((Char -> Bool) -> (ByteString -> Maybe (Int)))
Data.ByteString.Char8.findIndices :: ((Char -> Bool) -> (ByteString -> List (Int)))
Data.ByteString.Char8.count :: (Char -> (ByteString -> Int))
Data.ByteString.Char8.zip :: (ByteString -> (ByteString -> List (Pair (Char) (Char))))
Data.ByteString.Char8.zipWith :: <a> . ((Char -> (Char -> a)) -> (ByteString -> (ByteString -> List (a))))
Data.ByteString.Char8.unzip :: (List (Pair (Char) (Char)) -> Pair (ByteString) (ByteString))
Data.ByteString.Char8.sort :: (ByteString -> ByteString)
Data.ByteString.Char8.readInt :: (ByteString -> Maybe (Pair (Int) (ByteString)))
Data.ByteString.Char8.readInteger :: (ByteString -> Maybe (Pair (Integer) (ByteString)))
Data.ByteString.Char8.copy :: (ByteString -> ByteString)
Data.ByteString.Char8.packCString :: (CString -> IO (ByteString))
Data.ByteString.Char8.packCStringLen :: (CStringLen -> IO (ByteString))
Data.ByteString.Char8.useAsCString :: <a> . (ByteString -> ((CString -> IO (a)) -> IO (a)))
Data.ByteString.Char8.useAsCStringLen :: <a> . (ByteString -> ((CStringLen -> IO (a)) -> IO (a)))
Data.ByteString.Char8.getLine :: IO (ByteString)
Data.ByteString.Char8.getContents :: IO (ByteString)
Data.ByteString.Char8.putStr :: (ByteString -> IO (Unit))
Data.ByteString.Char8.putStrLn :: (ByteString -> IO (Unit))
Data.ByteString.Char8.interact :: ((ByteString -> ByteString) -> IO (Unit))
Data.ByteString.Char8.readFile :: (FilePath -> IO (ByteString))
Data.ByteString.Char8.writeFile :: (FilePath -> (ByteString -> IO (Unit)))
Data.ByteString.Char8.appendFile :: (FilePath -> (ByteString -> IO (Unit)))
Data.ByteString.Char8.hGetLine :: (Handle -> IO (ByteString))
Data.ByteString.Char8.hGetContents :: (Handle -> IO (ByteString))
Data.ByteString.Char8.hGet :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.Char8.hGetSome :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.Char8.hGetNonBlocking :: (Handle -> (Int -> IO (ByteString)))
Data.ByteString.Char8.hPut :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.Char8.hPutNonBlocking :: (Handle -> (ByteString -> IO (ByteString)))
Data.ByteString.Char8.hPutStr :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.Char8.hPutStrLn :: (Handle -> (ByteString -> IO (Unit)))
Data.ByteString.Builder.Prim
DataDecl () (DataType ()) Nothing (DHApp () (DHead () (Ident () "BoundedPrim")) (UnkindedVar () (Ident () "a"))) [] []
Data.ByteString.Builder.Prim.emptyB :: <a> . BoundedPrim (a)
Data.ByteString.Builder.Prim.>*< :: <a> . <b> . <f> . (f -> (f -> f))
InfixDecl () (AssocRight ()) (Just 5) [VarOp () (Symbol () ">*<")]
Data.ByteString.Builder.Prim.>$< :: <a> . <b> . <f> . ((b -> a) -> (f -> f))
InfixDecl () (AssocLeft ()) (Just 4) [VarOp () (Symbol () ">$<")]
Data.ByteString.Builder.Prim.eitherB :: <a> . <b> . (BoundedPrim (a) -> (BoundedPrim (b) -> BoundedPrim (Either (a)) (b)))
Data.ByteString.Builder.Prim.condB :: <a> . ((a -> Bool) -> (BoundedPrim (a) -> (BoundedPrim (a) -> BoundedPrim (a))))
Data.ByteString.Builder.Prim.primBounded :: <a> . (BoundedPrim (a) -> (a -> Builder))
Data.ByteString.Builder.Prim.primMapListBounded :: <a> . (BoundedPrim (a) -> (List (a) -> Builder))
Data.ByteString.Builder.Prim.primUnfoldrBounded :: <a> . <b> . (BoundedPrim (b) -> ((a -> Maybe (Pair (b) (a))) -> (a -> Builder)))
Data.ByteString.Builder.Prim.primMapByteStringBounded :: (BoundedPrim (Word8) -> (ByteString -> Builder))
Data.ByteString.Builder.Prim.primMapLazyByteStringBounded :: (BoundedPrim (Word8) -> (ByteString -> Builder))
DataDecl () (DataType ()) Nothing (DHApp () (DHead () (Ident () "FixedPrim")) (UnkindedVar () (Ident () "a"))) [] []
Data.ByteString.Builder.Prim.emptyF :: <a> . FixedPrim (a)
Data.ByteString.Builder.Prim.liftFixedToBounded :: <a> . (FixedPrim (a) -> BoundedPrim (a))
Data.ByteString.Builder.Prim.primFixed :: <a> . (FixedPrim (a) -> (a -> Builder))
Data.ByteString.Builder.Prim.primMapListFixed :: <a> . (FixedPrim (a) -> (List (a) -> Builder))
Data.ByteString.Builder.Prim.primUnfoldrFixed :: <a> . <b> . (FixedPrim (b) -> ((a -> Maybe (Pair (b) (a))) -> (a -> Builder)))
Data.ByteString.Builder.Prim.primMapByteStringFixed :: (FixedPrim (Word8) -> (ByteString -> Builder))
Data.ByteString.Builder.Prim.primMapLazyByteStringFixed :: (FixedPrim (Word8) -> (ByteString -> Builder))
Data.ByteString.Builder.Prim.int8 :: FixedPrim (Int8)
Data.ByteString.Builder.Prim.word8 :: FixedPrim (Word8)
Data.ByteString.Builder.Prim.int16BE :: FixedPrim (Int16)
Data.ByteString.Builder.Prim.int32BE :: FixedPrim (Int32)
Data.ByteString.Builder.Prim.int64BE :: FixedPrim (Int64)
Data.ByteString.Builder.Prim.word16BE :: FixedPrim (Word16)
Data.ByteString.Builder.Prim.word32BE :: FixedPrim (Word32)
Data.ByteString.Builder.Prim.word64BE :: FixedPrim (Word64)
Data.ByteString.Builder.Prim.floatBE :: FixedPrim (Float)
Data.ByteString.Builder.Prim.doubleBE :: FixedPrim (Double)
Data.ByteString.Builder.Prim.int16LE :: FixedPrim (Int16)
Data.ByteString.Builder.Prim.int32LE :: FixedPrim (Int32)
Data.ByteString.Builder.Prim.int64LE :: FixedPrim (Int64)
Data.ByteString.Builder.Prim.word16LE :: FixedPrim (Word16)
Data.ByteString.Builder.Prim.word32LE :: FixedPrim (Word32)
Data.ByteString.Builder.Prim.word64LE :: FixedPrim (Word64)
Data.ByteString.Builder.Prim.floatLE :: FixedPrim (Float)
Data.ByteString.Builder.Prim.doubleLE :: FixedPrim (Double)
Data.ByteString.Builder.Prim.intHost :: FixedPrim (Int)
Data.ByteString.Builder.Prim.int16Host :: FixedPrim (Int16)
Data.ByteString.Builder.Prim.int32Host :: FixedPrim (Int32)
Data.ByteString.Builder.Prim.int64Host :: FixedPrim (Int64)
Data.ByteString.Builder.Prim.wordHost :: FixedPrim (Word)
Data.ByteString.Builder.Prim.word16Host :: FixedPrim (Word16)
Data.ByteString.Builder.Prim.word32Host :: FixedPrim (Word32)
Data.ByteString.Builder.Prim.word64Host :: FixedPrim (Word64)
Data.ByteString.Builder.Prim.floatHost :: FixedPrim (Float)
Data.ByteString.Builder.Prim.doubleHost :: FixedPrim (Double)
Data.ByteString.Builder.Prim.char7 :: FixedPrim (Char)
Data.ByteString.Builder.Prim.int8Dec :: BoundedPrim (Int8)
Data.ByteString.Builder.Prim.int16Dec :: BoundedPrim (Int16)
Data.ByteString.Builder.Prim.int32Dec :: BoundedPrim (Int32)
Data.ByteString.Builder.Prim.int64Dec :: BoundedPrim (Int64)
Data.ByteString.Builder.Prim.intDec :: BoundedPrim (Int)
Data.ByteString.Builder.Prim.word8Dec :: BoundedPrim (Word8)
Data.ByteString.Builder.Prim.word16Dec :: BoundedPrim (Word16)
Data.ByteString.Builder.Prim.word32Dec :: BoundedPrim (Word32)
Data.ByteString.Builder.Prim.word64Dec :: BoundedPrim (Word64)
Data.ByteString.Builder.Prim.wordDec :: BoundedPrim (Word)
Data.ByteString.Builder.Prim.word8Hex :: BoundedPrim (Word8)
Data.ByteString.Builder.Prim.word16Hex :: BoundedPrim (Word16)
Data.ByteString.Builder.Prim.word32Hex :: BoundedPrim (Word32)
Data.ByteString.Builder.Prim.word64Hex :: BoundedPrim (Word64)
Data.ByteString.Builder.Prim.wordHex :: BoundedPrim (Word)
Data.ByteString.Builder.Prim.int8HexFixed :: FixedPrim (Int8)
Data.ByteString.Builder.Prim.int16HexFixed :: FixedPrim (Int16)
Data.ByteString.Builder.Prim.int32HexFixed :: FixedPrim (Int32)
Data.ByteString.Builder.Prim.int64HexFixed :: FixedPrim (Int64)
Data.ByteString.Builder.Prim.word8HexFixed :: FixedPrim (Word8)
Data.ByteString.Builder.Prim.word16HexFixed :: FixedPrim (Word16)
Data.ByteString.Builder.Prim.word32HexFixed :: FixedPrim (Word32)
Data.ByteString.Builder.Prim.word64HexFixed :: FixedPrim (Word64)
Data.ByteString.Builder.Prim.floatHexFixed :: FixedPrim (Float)
Data.ByteString.Builder.Prim.doubleHexFixed :: FixedPrim (Double)
Data.ByteString.Builder.Prim.char8 :: FixedPrim (Char)
Data.ByteString.Builder.Prim.charUtf8 :: BoundedPrim (Char)
Data.ByteString.Builder.Extra
Data.ByteString.Builder.Extra.toLazyByteStringWith :: (AllocationStrategy -> (ByteString -> (Builder -> ByteString)))
DataDecl () (DataType ()) Nothing (DHead () (Ident () "AllocationStrategy")) [] []
Data.ByteString.Builder.Extra.safeStrategy :: (Int -> (Int -> AllocationStrategy))
Data.ByteString.Builder.Extra.untrimmedStrategy :: (Int -> (Int -> AllocationStrategy))
Data.ByteString.Builder.Extra.smallChunkSize :: Int
Data.ByteString.Builder.Extra.defaultChunkSize :: Int
Data.ByteString.Builder.Extra.byteStringCopy :: (ByteString -> Builder)
Data.ByteString.Builder.Extra.byteStringInsert :: (ByteString -> Builder)
Data.ByteString.Builder.Extra.byteStringThreshold :: (Int -> (ByteString -> Builder))
Data.ByteString.Builder.Extra.lazyByteStringCopy :: (ByteString -> Builder)
Data.ByteString.Builder.Extra.lazyByteStringInsert :: (ByteString -> Builder)
Data.ByteString.Builder.Extra.lazyByteStringThreshold :: (Int -> (ByteString -> Builder))
Data.ByteString.Builder.Extra.flush :: Builder
Data.ByteString.Builder.Extra.BufferWriterToPtrToIntToIO :: (BufferWriter -> (Ptr (Word8) -> (Int -> IO (Pair (Int) (Next)))))
DataDecl () (DataType ()) Nothing (DHead () (Ident () "Next")) [] []
Data.ByteString.Builder.Extra.Done :: Next
Data.ByteString.Builder.Extra.More :: (Int -> (BufferWriter -> Next))
Data.ByteString.Builder.Extra.Chunk :: (ByteString -> (BufferWriter -> Next))
Data.ByteString.Builder.Extra.runBuilder :: (Builder -> BufferWriter)
Data.ByteString.Builder.Extra.intHost :: (Int -> Builder)
Data.ByteString.Builder.Extra.int16Host :: (Int16 -> Builder)
Data.ByteString.Builder.Extra.int32Host :: (Int32 -> Builder)
Data.ByteString.Builder.Extra.int64Host :: (Int64 -> Builder)
Data.ByteString.Builder.Extra.wordHost :: (Word -> Builder)
Data.ByteString.Builder.Extra.word16Host :: (Word16 -> Builder)
Data.ByteString.Builder.Extra.word32Host :: (Word32 -> Builder)
Data.ByteString.Builder.Extra.word64Host :: (Word64 -> Builder)
Data.ByteString.Builder.Extra.floatHost :: (Float -> Builder)
Data.ByteString.Builder.Extra.doubleHost :: (Double -> Builder)
Data.ByteString.Lazy.Builder.Extras
Data.ByteString.Builder
DataDecl () (DataType ()) Nothing (DHead () (Ident () "Builder")) [] []
Data.ByteString.Builder.toLazyByteString :: (Builder -> ByteString)
Data.ByteString.Builder.hPutBuilder :: (Handle -> (Builder -> IO (Unit)))
Data.ByteString.Builder.byteString :: (ByteString -> Builder)
Data.ByteString.Builder.lazyByteString :: (ByteString -> Builder)
Data.ByteString.Builder.shortByteString :: (ShortByteString -> Builder)
Data.ByteString.Builder.int8 :: (Int8 -> Builder)
Data.ByteString.Builder.word8 :: (Word8 -> Builder)
Data.ByteString.Builder.int16BE :: (Int16 -> Builder)
Data.ByteString.Builder.int32BE :: (Int32 -> Builder)
Data.ByteString.Builder.int64BE :: (Int64 -> Builder)
Data.ByteString.Builder.word16BE :: (Word16 -> Builder)
Data.ByteString.Builder.word32BE :: (Word32 -> Builder)
Data.ByteString.Builder.word64BE :: (Word64 -> Builder)
Data.ByteString.Builder.floatBE :: (Float -> Builder)
Data.ByteString.Builder.doubleBE :: (Double -> Builder)
Data.ByteString.Builder.int16LE :: (Int16 -> Builder)
Data.ByteString.Builder.int32LE :: (Int32 -> Builder)
Data.ByteString.Builder.int64LE :: (Int64 -> Builder)
Data.ByteString.Builder.word16LE :: (Word16 -> Builder)
Data.ByteString.Builder.word32LE :: (Word32 -> Builder)
Data.ByteString.Builder.word64LE :: (Word64 -> Builder)
Data.ByteString.Builder.floatLE :: (Float -> Builder)
Data.ByteString.Builder.doubleLE :: (Double -> Builder)
Data.ByteString.Builder.char7 :: (Char -> Builder)
Data.ByteString.Builder.string7 :: (String -> Builder)
Data.ByteString.Builder.char8 :: (Char -> Builder)
Data.ByteString.Builder.string8 :: (String -> Builder)
Data.ByteString.Builder.charUtf8 :: (Char -> Builder)
Data.ByteString.Builder.stringUtf8 :: (String -> Builder)
Data.ByteString.Builder.int8Dec :: (Int8 -> Builder)
Data.ByteString.Builder.int16Dec :: (Int16 -> Builder)
Data.ByteString.Builder.int32Dec :: (Int32 -> Builder)
Data.ByteString.Builder.int64Dec :: (Int64 -> Builder)
Data.ByteString.Builder.intDec :: (Int -> Builder)
Data.ByteString.Builder.integerDec :: (Integer -> Builder)
Data.ByteString.Builder.word8Dec :: (Word8 -> Builder)
Data.ByteString.Builder.word16Dec :: (Word16 -> Builder)
Data.ByteString.Builder.word32Dec :: (Word32 -> Builder)
Data.ByteString.Builder.word64Dec :: (Word64 -> Builder)
Data.ByteString.Builder.wordDec :: (Word -> Builder)
Data.ByteString.Builder.floatDec :: (Float -> Builder)
Data.ByteString.Builder.doubleDec :: (Double -> Builder)
Data.ByteString.Builder.word8Hex :: (Word8 -> Builder)
Data.ByteString.Builder.word16Hex :: (Word16 -> Builder)
Data.ByteString.Builder.word32Hex :: (Word32 -> Builder)
Data.ByteString.Builder.word64Hex :: (Word64 -> Builder)
Data.ByteString.Builder.wordHex :: (Word -> Builder)
Data.ByteString.Builder.int8HexFixed :: (Int8 -> Builder)
Data.ByteString.Builder.int16HexFixed :: (Int16 -> Builder)
Data.ByteString.Builder.int32HexFixed :: (Int32 -> Builder)
Data.ByteString.Builder.int64HexFixed :: (Int64 -> Builder)
Data.ByteString.Builder.word8HexFixed :: (Word8 -> Builder)
Data.ByteString.Builder.word16HexFixed :: (Word16 -> Builder)
Data.ByteString.Builder.word32HexFixed :: (Word32 -> Builder)
Data.ByteString.Builder.word64HexFixed :: (Word64 -> Builder)
Data.ByteString.Builder.floatHexFixed :: (Float -> Builder)
Data.ByteString.Builder.doubleHexFixed :: (Double -> Builder)
Data.ByteString.Builder.byteStringHex :: (ByteString -> Builder)
Data.ByteString.Builder.lazyByteStringHex :: (ByteString -> Builder)
InstDecl () Nothing (IRule () Nothing Nothing (IHApp () (IHCon () (Qual () (ModuleName () "Data.String") (Ident () "IsString"))) (TyCon () (Qual () (ModuleName () "Data.ByteString.Builder.Internal") (Ident () "Builder"))))) Nothing
Data.ByteString.Lazy.Builder.ASCII
Data.ByteString.Lazy.Builder.ASCII.byteStringHexFixed :: (ByteString -> Builder)
Data.ByteString.Lazy.Builder.ASCII.lazyByteStringHexFixed :: (ByteString -> Builder)
Data.ByteString.Lazy.Builder
