- name: extractEitherValues
  query: "es: [Either b b] -> [b]"
  solution: "\\es -> GHC.List.map (Data.Either.either Data.Function.id Data.Function.id) es"
  source: "GitHub"

- name: filterMultiple
  query: "Eq a => xs: [a] -> ys: [a] -> [a]"
  solution: "\\xs -> GHC.List.filter (Data.Function.flip GHC.List.elem xs) ys"
  source: "StackOverflow"

- name: flipFilter
  query: "p: (a -> Bool) -> xs: [a] -> [a]"
  solution: "\\p xs -> GHC.List.filter ((Data.Function..) Data.Bool.not p) xs"
  source: "StackOverflow"

- name: nextIsGreater
  query: "Ord a => [a] -> Bool"
  solution: "\\xs -> GHC.List.all (Data.Ord.<) (GHC.List.zip (GHC.List.init xs) (GHC.List.tail xs))"
  source: "StackOverflow"

- name: multipleNth
  query: "[a] -> [Int] -> [a]"
  solution: "\\xs indices -> GHC.List.map (GHC.List.!! xs) indices"
  source: "StackOverflow"

- name: elemFreqByFirstOcc
  query: "Eq a => [a] -> [(a, Int)]"
  solution: "\\xs -> GHC.List.map GHC.List.length (Data.List.group (Data.List.sort xs))"
  source: "StackOverflow"

- name: doubleMap
  query: "(a -> b) -> [[a]] -> [[b]]"
  solution: "\\f xss -> map (map f) xss"
  source: "StackOverflow"

- name: sumTuples
  query: "[(a, [b])] -> Int"
  solution: "\\ps -> GHC.List.sum (GHC.List.map ((Data.Function..) GHC.List.length Data.Tuple.snd) xs)"
  source: "StackOverflow"

- name: moreThanNTimes
  query: "Eq a => Int -> a -> [a] -> Bool"
  solution: "\\n x xs -> Data.Bool.not (GHC.List.null (GHC.List.drop n (GHC.List.filter ((Data.Eq.==) x) xs)))"
  source: "StackOverflow"

- name: groupByFirst
  query: "Eq a => [(a, b)] -> [[(a, b)]]"
  solution: "\\xs -> Data.List.groupBy (Data.Function.on (Data.Eq.==) Data.Tuple.fst) (Data.List.sortOn Data.Tuple.fst xs)"
  source: "StackOverflow"

- name: mySortBy
  query: "(a -> a -> Comparing) -> [(a, b)] -> [(a, b)]"
  solution: "\\cmp xs -> Data.List.sortBy (Data.Function.on cmp Data.Tuple.fst) xs"
  source: "StackOverflow"

- name: transposeAndCompress
  query: "[[a]] -> [a]"
  solution: "\\xs -> GHC.List.concat (GHC.List.foldr (GHC.List.zipWith (:)) (GHC.List.repeat []) xs)"
  source: "StackOverflow"

- name: partition
  query: "(a -> Bool) -> [a] -> ([a], [a])"
  solution: "\\p xs -> (GHC.List.filter p xs, GHC.List.filter ((Data.Function..) Data.Bool.not p) xs)"
  source: "StackOverflow"

- name: matchedKeys
  query: "(b -> Bool) -> [(a, b)] -> [a]"
  solution: "\\p xs -> GHC.List.map Data.Tuple.fst (GHC.List.filter ((Data.Function..) p Data.Tuple.snd) xs)"
  source: "StackOverflow"

- name: filterPairs
  query: "(a -> b -> Bool) -> [a] -> [b] -> [(a, b)]"
  solution: "\\p xs ys -> GHC.List.filter (Data.Tuple.uncurry f) (GHC.List.zip xs ys)"
  source: "StackOverflow"

- name: applyNthNTimes
  query: "(a -> a) -> [a] -> [a]"
  solution: "\\xs -> GHC.List.zipWith ($) (GHC.List.iterate ((Data.Function..) f) f) xs"
  source: "StackOverflow"

- name: removeMax
  query: "Ord a => [a] -> [a]"
  solution: "\\xs -> GHC.List.foldr (Data.Function.const (Data.List.delete (GHC.List.maximum xs))) xs xs"
  source: "StackOverflow"

- name: allSameLength
  query: "[a] -> [[a]] -> Bool"
  solution: "\\xs xss -> GHC.List.all (Data.Function.on (Data.Eq.==) GHC.List.length xs) xss"
  source: "StackOverflow"

- name: mostFrequent
  query: "Eq a => [a] -> a"
  solution: "\\xs -> GHC.List.head (Data.List.maximumBy (Data.Function.on Data.Ord.compare GHC.List.length) (Data.List.group xs))"
  source: "StackOverflow"