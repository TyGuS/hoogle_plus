module Control.Monad.State.Lazy

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s m | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: * -> *) a
StateT :: (s -> m (a, s)) -> StateT s m a
runStateT :: StateT s m a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
-- execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: () => m (a, s) -> n (b, s) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: () => s -> s -> StateT s m a -> StateT s m a

module Data.Char
data Char
type String = [Char] 

module Control.Applicative
class Functor f => Applicative f
class Applicative f => Alternative f

module Data.Traversable
class (Functor t, Foldable t) => Traversable t
-- instance Traversable []

module Data.Foldable
class Foldable t
-- instance Foldable []

module Control.Monad
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b
class Applicative m => Monad m
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b
(>>) :: forall a b. Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
-- fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>
class (Alternative m, Monad m) => MonadPlus m
mzero :: MonadPlus m => m a
mplus :: MonadPlus m => m a -> m a -> m a
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
-- mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
-- forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
-- sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
-- (=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>
-- (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<
-- forever :: Applicative f => f a -> f b
-- void :: Functor f => f a -> f ()
join :: Monad m => m (m a) -> m a
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
-- mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]
-- mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
-- zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
-- foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()
replicateM :: Applicative m => Int -> m a -> m [a]
-- replicateM_ :: Applicative m => Int -> m a -> m ()
guard :: Alternative f => Bool -> f ()
-- when :: Applicative f => Bool -> f () -> f ()
-- unless :: Applicative f => Bool -> f () -> f ()
liftM :: Monad m => (a1 -> r) -> m a1 -> m r
-- liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
-- liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
-- liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
-- liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
-- ap :: Monad m => m (a -> b) -> m a -> m b
-- (<$!>) :: Monad m => (a -> b) -> m a -> m b

-- instance Monad []
instance Monad Maybe

instance MonadPlus Maybe
-- instance MonadPlus []

-- some other functions that are used in the benchmarks
module Data.List
map :: (a -> b) -> [a] -> [b]
zip :: [a] -> [b] -> [(a, b)]
lines :: String -> [String]

module Data.Either
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b
either :: (a -> c) -> (b -> c) -> Either a b -> c

module Data.Maybe
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
fromMaybe :: a -> Maybe a -> a
listToMaybe :: [a] -> Maybe a
maybe :: b -> (a -> b) -> Maybe a -> b

module Data.Tuple
fst :: (a, b) -> a
snd :: (a, b) -> b

module Data.Function
(.) :: (b -> c) -> (a -> b) -> a -> c
id :: a -> a

module Control.Monad.Trans.Maybe

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT m a
MaybeT :: m (Maybe a) -> MaybeT m a