@package base
@version 4.12.0.0
module GHC.Maybe
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Maybe.Maybe a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Maybe.Maybe a)
module GHC.Natural
data Natural
NatS# :: GmpLimb# -> Natural
NatJ# :: {-# UNPACK #-} !BigNat -> Natural
mkNatural :: [Word] -> Natural
isValidNatural :: Natural -> Bool
plusNatural :: Natural -> Natural -> Natural
minusNatural :: Natural -> Natural -> Natural
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural
timesNatural :: Natural -> Natural -> Natural
negateNatural :: Natural -> Natural
signumNatural :: Natural -> Natural
quotRemNatural :: Natural -> Natural -> (Natural, Natural)
quotNatural :: Natural -> Natural -> Natural
remNatural :: Natural -> Natural -> Natural
gcdNatural :: Natural -> Natural -> Natural
lcmNatural :: Natural -> Natural -> Natural
andNatural :: Natural -> Natural -> Natural
orNatural :: Natural -> Natural -> Natural
xorNatural :: Natural -> Natural -> Natural
bitNatural :: Int# -> Natural
testBitNatural :: Natural -> Int -> Bool
popCountNatural :: Natural -> Int
shiftLNatural :: Natural -> Int -> Natural
shiftRNatural :: Natural -> Int -> Natural
naturalToInteger :: Natural -> Integer
naturalToWord :: Natural -> Word
naturalToInt :: Natural -> Int
naturalFromInteger :: Integer -> Natural
wordToNatural :: Word -> Natural
intToNatural :: Int -> Natural
naturalToWordMaybe :: Natural -> Maybe Word
wordToNatural# :: Word# -> Natural
wordToNaturalBase :: Word# -> Natural
powModNatural :: Natural -> Natural -> Natural -> Natural
instance GHC.Classes.Ord GHC.Natural.Natural
instance GHC.Classes.Eq GHC.Natural.Natural
module GHC.Profiling
stopProfTimer :: IO ()
startProfTimer :: IO ()
module GHC.IO.Encoding.CodePage
module GHC.Constants
module GHC.ConsoleHandler
module Data.Tuple
-- fst :: (a, b) -> a
-- snd :: (a, b) -> b
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
swap :: (a, b) -> (b, a)
module Data.Maybe
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
maybe :: b -> (a -> b) -> Maybe a -> b
isJust :: Maybe a -> Bool
isNothing :: Maybe a -> Bool
fromMaybe :: a -> Maybe a -> a
listToMaybe :: [a] -> Maybe a
maybeToList :: Maybe a -> [a]
catMaybes :: [Maybe a] -> [a]
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
-- temporary customize
instance Control.Monad.Monad Data.Maybe.Maybe
module GHC.List
map :: (a -> b) -> [a] -> [b]
(++) :: [a] -> [a] -> [a]
infixr 5 ++
filter :: (a -> Bool) -> [a] -> [a]
concat :: [[a]] -> [a]
uncons :: [a] -> Maybe (a, [a])
null :: [a] -> Bool
length :: [a] -> Int
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b
scanl :: (b -> a -> b) -> b -> [a] -> [b]
foldr :: (a -> b -> b) -> b -> [a] -> b
scanr :: (a -> b -> b) -> b -> [a] -> [b]
iterate :: (a -> a) -> a -> [a]
replicate :: Int -> a -> [a]
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
break :: (a -> Bool) -> [a] -> ([a], [a])
reverse :: [a] -> [a]
and :: [Bool] -> Bool
or :: [Bool] -> Bool
all :: (a -> Bool) -> [a] -> Bool
elem :: Eq a => a -> [a] -> Bool
lookup :: Eq a => a -> [(a, b)] -> Maybe b
concatMap :: (a -> [b]) -> [a] -> [b]
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
-- errorEmptyList :: String -> a
module GHC.Char
chr :: Int -> Char
eqChar :: Char -> Char -> Bool
neChar :: Char -> Char -> Bool
module Data.Functor
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$
($>) :: Functor f => f a -> b -> f b
infixl 4 $>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>
void :: Functor f => f a -> f ()
module Data.Function
id :: a -> a
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
module Data.Eq
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=
module Data.Coerce
coerce :: Coercible a b => a -> b
class a ~R# b => Coercible (a :: k0) (b :: k0)
module Data.Bool
data Bool
False :: Bool
True :: Bool
(&&) :: Bool -> Bool -> Bool
infixr 3 &&
(||) :: Bool -> Bool -> Bool
infixr 2 ||
not :: Bool -> Bool
otherwise :: Bool
bool :: a -> a -> Bool -> a
module Data.Type.Bool
type family If cond tru fls
type family a && b
infixr 3 &&
type family a || b
infixr 2 ||
type family Not a = res | res -> a
module Data.Bits
class Eq a => Bits a
(.&.) :: Bits a => a -> a -> a
(.|.) :: Bits a => a -> a -> a
xor :: Bits a => a -> a -> a
complement :: Bits a => a -> a
shift :: Bits a => a -> Int -> a
rotate :: Bits a => a -> Int -> a
zeroBits :: Bits a => a
bit :: Bits a => Int -> a
setBit :: Bits a => a -> Int -> a
clearBit :: Bits a => a -> Int -> a
complementBit :: Bits a => a -> Int -> a
testBit :: Bits a => a -> Int -> Bool
bitSizeMaybe :: Bits a => a -> Maybe Int
bitSize :: Bits a => a -> Int
isSigned :: Bits a => a -> Bool
shiftL :: Bits a => a -> Int -> a
unsafeShiftL :: Bits a => a -> Int -> a
shiftR :: Bits a => a -> Int -> a
unsafeShiftR :: Bits a => a -> Int -> a
rotateL :: Bits a => a -> Int -> a
rotateR :: Bits a => a -> Int -> a
popCount :: Bits a => a -> Int
infixl 7 .&.
infixl 5 .|.
infixl 6 `xor`
infixl 8 `shift`
infixl 8 `rotate`
infixl 8 `shiftL`
infixl 8 `shiftR`
infixl 8 `rotateL`
infixl 8 `rotateR`
class Bits b => FiniteBits b
finiteBitSize :: FiniteBits b => b -> Int
countLeadingZeros :: FiniteBits b => b -> Int
countTrailingZeros :: FiniteBits b => b -> Int
bitDefault :: (Bits a, Num a) => Int -> a
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool
popCountDefault :: (Bits a, Num a) => a -> Int
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b
instance Data.Bits.FiniteBits GHC.Types.Bool
instance Data.Bits.Bits GHC.Types.Int
instance Data.Bits.FiniteBits GHC.Types.Int
instance Data.Bits.Bits GHC.Types.Word
instance Data.Bits.FiniteBits GHC.Types.Word
instance Data.Bits.Bits GHC.Types.Bool
instance Data.Bits.Bits GHC.Integer.Type.Integer
instance Data.Bits.Bits GHC.Natural.Natural
module Control.Monad.Fail
class Monad m => MonadFail m
fail :: MonadFail m => String -> m a
instance Control.Monad.Fail.MonadFail GHC.Maybe.Maybe
instance Control.Monad.Fail.MonadFail []
instance Control.Monad.Fail.MonadFail GHC.Types.IO
module Numeric.Natural
data Natural
module Text.ParserCombinators.ReadP
data ReadP a
get :: ReadP Char
look :: ReadP String
(+++) :: ReadP a -> ReadP a -> ReadP a
infixr 5 +++
(<++) :: ReadP a -> ReadP a -> ReadP a
infixr 5 <++
gather :: ReadP a -> ReadP (String, a)
pfail :: ReadP a
eof :: ReadP ()
satisfy :: (Char -> Bool) -> ReadP Char
char :: Char -> ReadP Char
string :: String -> ReadP String
munch :: (Char -> Bool) -> ReadP String
munch1 :: (Char -> Bool) -> ReadP String
skipSpaces :: ReadP ()
choice :: [ReadP a] -> ReadP a
count :: Int -> ReadP a -> ReadP [a]
between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
option :: a -> ReadP a -> ReadP a
optional :: ReadP a -> ReadP ()
many :: ReadP a -> ReadP [a]
many1 :: ReadP a -> ReadP [a]
skipMany :: ReadP a -> ReadP ()
skipMany1 :: ReadP a -> ReadP ()
sepBy :: ReadP a -> ReadP sep -> ReadP [a]
sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
endBy :: ReadP a -> ReadP sep -> ReadP [a]
endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
manyTill :: ReadP a -> ReadP end -> ReadP [a]
type ReadS a = String -> [(a, String)]
readP_to_S :: ReadP a -> ReadS a
readS_to_P :: ReadS a -> ReadP a
instance GHC.Base.Functor Text.ParserCombinators.ReadP.P
instance GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.P
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P
instance GHC.Base.Monad Text.ParserCombinators.ReadP.P
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.P
module Text.ParserCombinators.ReadPrec
data ReadPrec a
type Prec = Int
minPrec :: Prec
lift :: ReadP a -> ReadPrec a
prec :: Prec -> ReadPrec a -> ReadPrec a
step :: ReadPrec a -> ReadPrec a
reset :: ReadPrec a -> ReadPrec a
get :: ReadPrec Char
look :: ReadPrec String
(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
pfail :: ReadPrec a
choice :: [ReadPrec a] -> ReadPrec a
readPrec_to_P :: ReadPrec a -> Int -> ReadP a
readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
readPrec_to_S :: ReadPrec a -> Int -> ReadS a
readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a
instance GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec
module Text.Read.Lex
data Lexeme
Char :: Char -> Lexeme
String :: String -> Lexeme
Punc :: String -> Lexeme
Ident :: String -> Lexeme
Symbol :: String -> Lexeme
Number :: Number -> Lexeme
EOF :: Lexeme
data Number
numberToInteger :: Number -> Maybe Integer
numberToFixed :: Integer -> Number -> Maybe (Integer, Integer)
numberToRational :: Number -> Rational
numberToRangedRational :: (Int, Int) -> Number -> Maybe Rational
lex :: ReadP Lexeme
expect :: Lexeme -> ReadP ()
hsLex :: ReadP String
lexChar :: ReadP Char
readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
readOctP :: (Eq a, Num a) => ReadP a
readDecP :: (Eq a, Num a) => ReadP a
readHexP :: (Eq a, Num a) => ReadP a
isSymbolChar :: Char -> Bool
instance GHC.Show.Show Text.Read.Lex.Lexeme
instance GHC.Classes.Eq Text.Read.Lex.Lexeme
instance GHC.Show.Show Text.Read.Lex.Number
instance GHC.Classes.Eq Text.Read.Lex.Number
module Numeric
showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
showIntAtBase :: (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
showInt :: Integral a => a -> ShowS
showHex :: (Integral a, Show a) => a -> ShowS
showOct :: (Integral a, Show a) => a -> ShowS
showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
showGFloat :: RealFloat a => Maybe Int -> a -> ShowS
showFFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS
showGFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS
showFloat :: RealFloat a => a -> ShowS
showHFloat :: RealFloat a => a -> ShowS
floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
readSigned :: Real a => ReadS a -> ReadS a
readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
readDec :: (Eq a, Num a) => ReadS a
readOct :: (Eq a, Num a) => ReadS a
readHex :: (Eq a, Num a) => ReadS a
readFloat :: RealFrac a => ReadS a
lexDigits :: ReadS String
fromRat :: RealFloat a => Rational -> a
class (Fractional a) => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
log1p :: Floating a => a -> a
expm1 :: Floating a => a -> a
log1pexp :: Floating a => a -> a
log1mexp :: Floating a => a -> a
infixr 8 **
module Foreign.StablePtr
data {-# CTYPE "HsStablePtr" #-} StablePtr a
newStablePtr :: a -> IO (StablePtr a)
deRefStablePtr :: StablePtr a -> IO a
freeStablePtr :: StablePtr a -> IO ()
castStablePtrToPtr :: StablePtr a -> Ptr ()
castPtrToStablePtr :: Ptr () -> StablePtr a
module GHC.Fingerprint.Type
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
instance GHC.Classes.Ord GHC.Fingerprint.Type.Fingerprint
instance GHC.Classes.Eq GHC.Fingerprint.Type.Fingerprint
instance GHC.Show.Show GHC.Fingerprint.Type.Fingerprint
module Foreign.Storable
class Storable a
sizeOf :: Storable a => a -> Int
alignment :: Storable a => a -> Int
peekElemOff :: Storable a => Ptr a -> Int -> IO a
pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
peekByteOff :: Storable a => Ptr b -> Int -> IO a
pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
peek :: Storable a => Ptr a -> IO a
poke :: Storable a => Ptr a -> a -> IO ()
instance Foreign.Storable.Storable ()
instance Foreign.Storable.Storable GHC.Types.Bool
instance Foreign.Storable.Storable GHC.Types.Char
instance Foreign.Storable.Storable GHC.Types.Int
instance Foreign.Storable.Storable GHC.Types.Word
instance Foreign.Storable.Storable (GHC.Ptr.Ptr a)
instance Foreign.Storable.Storable (GHC.Ptr.FunPtr a)
instance Foreign.Storable.Storable (GHC.Stable.StablePtr a)
instance Foreign.Storable.Storable GHC.Types.Float
instance Foreign.Storable.Storable GHC.Types.Double
instance Foreign.Storable.Storable GHC.Word.Word8
instance Foreign.Storable.Storable GHC.Word.Word16
instance Foreign.Storable.Storable GHC.Word.Word32
instance Foreign.Storable.Storable GHC.Word.Word64
instance Foreign.Storable.Storable GHC.Int.Int8
instance Foreign.Storable.Storable GHC.Int.Int16
instance Foreign.Storable.Storable GHC.Int.Int32
instance Foreign.Storable.Storable GHC.Int.Int64
instance (Foreign.Storable.Storable a, GHC.Real.Integral a) => Foreign.Storable.Storable (GHC.Real.Ratio a)
instance Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint
module Data.Int
data Int
data {-# CTYPE "HsInt8" #-} Int8
data {-# CTYPE "HsInt16" #-} Int16
data {-# CTYPE "HsInt32" #-} Int32
data {-# CTYPE "HsInt64" #-} Int64
module Foreign.Ptr
data Ptr a
nullPtr :: Ptr a
castPtr :: Ptr a -> Ptr b
plusPtr :: Ptr a -> Int -> Ptr b
alignPtr :: Ptr a -> Int -> Ptr a
minusPtr :: Ptr a -> Ptr b -> Int
data FunPtr a
nullFunPtr :: FunPtr a
castFunPtr :: FunPtr a -> FunPtr b
castFunPtrToPtr :: FunPtr a -> Ptr b
castPtrToFunPtr :: Ptr a -> FunPtr b
freeHaskellFunPtr :: FunPtr a -> IO ()
newtype IntPtr
IntPtr :: Int -> IntPtr
ptrToIntPtr :: Ptr a -> IntPtr
intPtrToPtr :: IntPtr -> Ptr a
newtype WordPtr
WordPtr :: Word -> WordPtr
ptrToWordPtr :: Ptr a -> WordPtr
wordPtrToPtr :: WordPtr -> Ptr a
instance GHC.Show.Show Foreign.Ptr.IntPtr
instance GHC.Read.Read Foreign.Ptr.IntPtr
instance Data.Bits.FiniteBits Foreign.Ptr.IntPtr
instance Data.Bits.Bits Foreign.Ptr.IntPtr
instance GHC.Real.Integral Foreign.Ptr.IntPtr
instance GHC.Enum.Bounded Foreign.Ptr.IntPtr
instance GHC.Real.Real Foreign.Ptr.IntPtr
instance Foreign.Storable.Storable Foreign.Ptr.IntPtr
instance GHC.Enum.Enum Foreign.Ptr.IntPtr
instance GHC.Num.Num Foreign.Ptr.IntPtr
instance GHC.Classes.Ord Foreign.Ptr.IntPtr
instance GHC.Classes.Eq Foreign.Ptr.IntPtr
instance GHC.Show.Show Foreign.Ptr.WordPtr
instance GHC.Read.Read Foreign.Ptr.WordPtr
instance Data.Bits.FiniteBits Foreign.Ptr.WordPtr
instance Data.Bits.Bits Foreign.Ptr.WordPtr
instance GHC.Real.Integral Foreign.Ptr.WordPtr
instance GHC.Enum.Bounded Foreign.Ptr.WordPtr
instance GHC.Real.Real Foreign.Ptr.WordPtr
instance Foreign.Storable.Storable Foreign.Ptr.WordPtr
instance GHC.Enum.Enum Foreign.Ptr.WordPtr
instance GHC.Num.Num Foreign.Ptr.WordPtr
instance GHC.Classes.Ord Foreign.Ptr.WordPtr
instance GHC.Classes.Eq Foreign.Ptr.WordPtr
module Data.Word
data Word
data {-# CTYPE "HsWord8" #-} Word8
data {-# CTYPE "HsWord16" #-} Word16
data {-# CTYPE "HsWord32" #-} Word32
data {-# CTYPE "HsWord64" #-} Word64
byteSwap16 :: Word16 -> Word16
byteSwap32 :: Word32 -> Word32
byteSwap64 :: Word64 -> Word64
module GHC.Clock
getMonotonicTime :: IO Double
getMonotonicTimeNSec :: IO Word64
module Foreign.C.Types
newtype CChar
CChar :: Int8 -> CChar
newtype CSChar
CSChar :: Int8 -> CSChar
newtype CUChar
CUChar :: Word8 -> CUChar
newtype CShort
CShort :: Int16 -> CShort
newtype CUShort
CUShort :: Word16 -> CUShort
newtype CInt
CInt :: Int32 -> CInt
newtype CUInt
CUInt :: Word32 -> CUInt
newtype CLong
CLong :: Int64 -> CLong
newtype CULong
CULong :: Word64 -> CULong
newtype CPtrdiff
CPtrdiff :: Int64 -> CPtrdiff
newtype CSize
CSize :: Word64 -> CSize
newtype CWchar
CWchar :: Int32 -> CWchar
newtype CSigAtomic
CSigAtomic :: Int32 -> CSigAtomic
newtype CLLong
CLLong :: Int64 -> CLLong
newtype CULLong
CULLong :: Word64 -> CULLong
newtype {-# CTYPE "bool" #-} CBool
CBool :: Word8 -> CBool
newtype CIntPtr
CIntPtr :: Int64 -> CIntPtr
newtype CUIntPtr
CUIntPtr :: Word64 -> CUIntPtr
newtype CIntMax
CIntMax :: Int64 -> CIntMax
newtype CUIntMax
CUIntMax :: Word64 -> CUIntMax
newtype CClock
CClock :: Int64 -> CClock
newtype CTime
CTime :: Int64 -> CTime
newtype CUSeconds
CUSeconds :: Word32 -> CUSeconds
newtype CSUSeconds
CSUSeconds :: Int64 -> CSUSeconds
newtype CFloat
CFloat :: Float -> CFloat
newtype CDouble
CDouble :: Double -> CDouble
data CFile
data CFpos
data CJmpBuf
instance GHC.Show.Show Foreign.C.Types.CUIntMax
instance GHC.Read.Read Foreign.C.Types.CUIntMax
instance Data.Bits.FiniteBits Foreign.C.Types.CUIntMax
instance Data.Bits.Bits Foreign.C.Types.CUIntMax
instance GHC.Real.Integral Foreign.C.Types.CUIntMax
instance GHC.Enum.Bounded Foreign.C.Types.CUIntMax
instance GHC.Real.Real Foreign.C.Types.CUIntMax
instance Foreign.Storable.Storable Foreign.C.Types.CUIntMax
instance GHC.Enum.Enum Foreign.C.Types.CUIntMax
instance GHC.Num.Num Foreign.C.Types.CUIntMax
instance GHC.Classes.Ord Foreign.C.Types.CUIntMax
instance GHC.Classes.Eq Foreign.C.Types.CUIntMax
instance GHC.Show.Show Foreign.C.Types.CIntMax
instance GHC.Read.Read Foreign.C.Types.CIntMax
instance Data.Bits.FiniteBits Foreign.C.Types.CIntMax
instance Data.Bits.Bits Foreign.C.Types.CIntMax
instance GHC.Real.Integral Foreign.C.Types.CIntMax
instance GHC.Enum.Bounded Foreign.C.Types.CIntMax
instance GHC.Real.Real Foreign.C.Types.CIntMax
instance Foreign.Storable.Storable Foreign.C.Types.CIntMax
instance GHC.Enum.Enum Foreign.C.Types.CIntMax
instance GHC.Num.Num Foreign.C.Types.CIntMax
instance GHC.Classes.Ord Foreign.C.Types.CIntMax
instance GHC.Classes.Eq Foreign.C.Types.CIntMax
instance GHC.Show.Show Foreign.C.Types.CUIntPtr
instance GHC.Read.Read Foreign.C.Types.CUIntPtr
instance Data.Bits.FiniteBits Foreign.C.Types.CUIntPtr
instance Data.Bits.Bits Foreign.C.Types.CUIntPtr
instance GHC.Real.Integral Foreign.C.Types.CUIntPtr
instance GHC.Enum.Bounded Foreign.C.Types.CUIntPtr
instance GHC.Real.Real Foreign.C.Types.CUIntPtr
instance Foreign.Storable.Storable Foreign.C.Types.CUIntPtr
instance GHC.Enum.Enum Foreign.C.Types.CUIntPtr
instance GHC.Num.Num Foreign.C.Types.CUIntPtr
instance GHC.Classes.Ord Foreign.C.Types.CUIntPtr
instance GHC.Classes.Eq Foreign.C.Types.CUIntPtr
instance GHC.Show.Show Foreign.C.Types.CIntPtr
instance GHC.Read.Read Foreign.C.Types.CIntPtr
instance Data.Bits.FiniteBits Foreign.C.Types.CIntPtr
instance Data.Bits.Bits Foreign.C.Types.CIntPtr
instance GHC.Real.Integral Foreign.C.Types.CIntPtr
instance GHC.Enum.Bounded Foreign.C.Types.CIntPtr
instance GHC.Real.Real Foreign.C.Types.CIntPtr
instance Foreign.Storable.Storable Foreign.C.Types.CIntPtr
instance GHC.Enum.Enum Foreign.C.Types.CIntPtr
instance GHC.Num.Num Foreign.C.Types.CIntPtr
instance GHC.Classes.Ord Foreign.C.Types.CIntPtr
instance GHC.Classes.Eq Foreign.C.Types.CIntPtr
instance GHC.Show.Show Foreign.C.Types.CSUSeconds
instance GHC.Read.Read Foreign.C.Types.CSUSeconds
instance GHC.Real.Real Foreign.C.Types.CSUSeconds
instance Foreign.Storable.Storable Foreign.C.Types.CSUSeconds
instance GHC.Enum.Enum Foreign.C.Types.CSUSeconds
instance GHC.Num.Num Foreign.C.Types.CSUSeconds
instance GHC.Classes.Ord Foreign.C.Types.CSUSeconds
instance GHC.Classes.Eq Foreign.C.Types.CSUSeconds
instance GHC.Show.Show Foreign.C.Types.CUSeconds
instance GHC.Read.Read Foreign.C.Types.CUSeconds
instance GHC.Real.Real Foreign.C.Types.CUSeconds
instance Foreign.Storable.Storable Foreign.C.Types.CUSeconds
instance GHC.Enum.Enum Foreign.C.Types.CUSeconds
instance GHC.Num.Num Foreign.C.Types.CUSeconds
instance GHC.Classes.Ord Foreign.C.Types.CUSeconds
instance GHC.Classes.Eq Foreign.C.Types.CUSeconds
instance GHC.Show.Show Foreign.C.Types.CTime
instance GHC.Read.Read Foreign.C.Types.CTime
instance GHC.Real.Real Foreign.C.Types.CTime
instance Foreign.Storable.Storable Foreign.C.Types.CTime
instance GHC.Enum.Enum Foreign.C.Types.CTime
instance GHC.Num.Num Foreign.C.Types.CTime
instance GHC.Classes.Ord Foreign.C.Types.CTime
instance GHC.Classes.Eq Foreign.C.Types.CTime
instance GHC.Show.Show Foreign.C.Types.CClock
instance GHC.Read.Read Foreign.C.Types.CClock
instance GHC.Real.Real Foreign.C.Types.CClock
instance Foreign.Storable.Storable Foreign.C.Types.CClock
instance GHC.Enum.Enum Foreign.C.Types.CClock
instance GHC.Num.Num Foreign.C.Types.CClock
instance GHC.Classes.Ord Foreign.C.Types.CClock
instance GHC.Classes.Eq Foreign.C.Types.CClock
instance GHC.Show.Show Foreign.C.Types.CSigAtomic
instance GHC.Read.Read Foreign.C.Types.CSigAtomic
instance Data.Bits.FiniteBits Foreign.C.Types.CSigAtomic
instance Data.Bits.Bits Foreign.C.Types.CSigAtomic
instance GHC.Real.Integral Foreign.C.Types.CSigAtomic
instance GHC.Enum.Bounded Foreign.C.Types.CSigAtomic
instance GHC.Real.Real Foreign.C.Types.CSigAtomic
instance Foreign.Storable.Storable Foreign.C.Types.CSigAtomic
instance GHC.Enum.Enum Foreign.C.Types.CSigAtomic
instance GHC.Num.Num Foreign.C.Types.CSigAtomic
instance GHC.Classes.Ord Foreign.C.Types.CSigAtomic
instance GHC.Classes.Eq Foreign.C.Types.CSigAtomic
instance GHC.Show.Show Foreign.C.Types.CWchar
instance GHC.Read.Read Foreign.C.Types.CWchar
instance Data.Bits.FiniteBits Foreign.C.Types.CWchar
instance Data.Bits.Bits Foreign.C.Types.CWchar
instance GHC.Real.Integral Foreign.C.Types.CWchar
instance GHC.Enum.Bounded Foreign.C.Types.CWchar
instance GHC.Real.Real Foreign.C.Types.CWchar
instance Foreign.Storable.Storable Foreign.C.Types.CWchar
instance GHC.Enum.Enum Foreign.C.Types.CWchar
instance GHC.Num.Num Foreign.C.Types.CWchar
instance GHC.Classes.Ord Foreign.C.Types.CWchar
instance GHC.Classes.Eq Foreign.C.Types.CWchar
instance GHC.Show.Show Foreign.C.Types.CSize
instance GHC.Read.Read Foreign.C.Types.CSize
instance Data.Bits.FiniteBits Foreign.C.Types.CSize
instance Data.Bits.Bits Foreign.C.Types.CSize
instance GHC.Real.Integral Foreign.C.Types.CSize
instance GHC.Enum.Bounded Foreign.C.Types.CSize
instance GHC.Real.Real Foreign.C.Types.CSize
instance Foreign.Storable.Storable Foreign.C.Types.CSize
instance GHC.Enum.Enum Foreign.C.Types.CSize
instance GHC.Num.Num Foreign.C.Types.CSize
instance GHC.Classes.Ord Foreign.C.Types.CSize
instance GHC.Classes.Eq Foreign.C.Types.CSize
instance GHC.Show.Show Foreign.C.Types.CPtrdiff
instance GHC.Read.Read Foreign.C.Types.CPtrdiff
instance Data.Bits.FiniteBits Foreign.C.Types.CPtrdiff
instance Data.Bits.Bits Foreign.C.Types.CPtrdiff
instance GHC.Real.Integral Foreign.C.Types.CPtrdiff
instance GHC.Enum.Bounded Foreign.C.Types.CPtrdiff
instance GHC.Real.Real Foreign.C.Types.CPtrdiff
instance Foreign.Storable.Storable Foreign.C.Types.CPtrdiff
instance GHC.Enum.Enum Foreign.C.Types.CPtrdiff
instance GHC.Num.Num Foreign.C.Types.CPtrdiff
instance GHC.Classes.Ord Foreign.C.Types.CPtrdiff
instance GHC.Classes.Eq Foreign.C.Types.CPtrdiff
instance GHC.Show.Show Foreign.C.Types.CDouble
instance GHC.Read.Read Foreign.C.Types.CDouble
instance GHC.Float.RealFloat Foreign.C.Types.CDouble
instance GHC.Real.RealFrac Foreign.C.Types.CDouble
instance GHC.Float.Floating Foreign.C.Types.CDouble
instance GHC.Real.Fractional Foreign.C.Types.CDouble
instance GHC.Real.Real Foreign.C.Types.CDouble
instance Foreign.Storable.Storable Foreign.C.Types.CDouble
instance GHC.Enum.Enum Foreign.C.Types.CDouble
instance GHC.Num.Num Foreign.C.Types.CDouble
instance GHC.Classes.Ord Foreign.C.Types.CDouble
instance GHC.Classes.Eq Foreign.C.Types.CDouble
instance GHC.Show.Show Foreign.C.Types.CFloat
instance GHC.Read.Read Foreign.C.Types.CFloat
instance GHC.Float.RealFloat Foreign.C.Types.CFloat
instance GHC.Real.RealFrac Foreign.C.Types.CFloat
instance GHC.Float.Floating Foreign.C.Types.CFloat
instance GHC.Real.Fractional Foreign.C.Types.CFloat
instance GHC.Real.Real Foreign.C.Types.CFloat
instance Foreign.Storable.Storable Foreign.C.Types.CFloat
instance GHC.Enum.Enum Foreign.C.Types.CFloat
instance GHC.Num.Num Foreign.C.Types.CFloat
instance GHC.Classes.Ord Foreign.C.Types.CFloat
instance GHC.Classes.Eq Foreign.C.Types.CFloat
instance GHC.Show.Show Foreign.C.Types.CBool
instance GHC.Read.Read Foreign.C.Types.CBool
instance Data.Bits.FiniteBits Foreign.C.Types.CBool
instance Data.Bits.Bits Foreign.C.Types.CBool
instance GHC.Real.Integral Foreign.C.Types.CBool
instance GHC.Enum.Bounded Foreign.C.Types.CBool
instance GHC.Real.Real Foreign.C.Types.CBool
instance Foreign.Storable.Storable Foreign.C.Types.CBool
instance GHC.Enum.Enum Foreign.C.Types.CBool
instance GHC.Num.Num Foreign.C.Types.CBool
instance GHC.Classes.Ord Foreign.C.Types.CBool
instance GHC.Classes.Eq Foreign.C.Types.CBool
instance GHC.Show.Show Foreign.C.Types.CULLong
instance GHC.Read.Read Foreign.C.Types.CULLong
instance Data.Bits.FiniteBits Foreign.C.Types.CULLong
instance Data.Bits.Bits Foreign.C.Types.CULLong
instance GHC.Real.Integral Foreign.C.Types.CULLong
instance GHC.Enum.Bounded Foreign.C.Types.CULLong
instance GHC.Real.Real Foreign.C.Types.CULLong
instance Foreign.Storable.Storable Foreign.C.Types.CULLong
instance GHC.Enum.Enum Foreign.C.Types.CULLong
instance GHC.Num.Num Foreign.C.Types.CULLong
instance GHC.Classes.Ord Foreign.C.Types.CULLong
instance GHC.Classes.Eq Foreign.C.Types.CULLong
instance GHC.Show.Show Foreign.C.Types.CLLong
instance GHC.Read.Read Foreign.C.Types.CLLong
instance Data.Bits.FiniteBits Foreign.C.Types.CLLong
instance Data.Bits.Bits Foreign.C.Types.CLLong
instance GHC.Real.Integral Foreign.C.Types.CLLong
instance GHC.Enum.Bounded Foreign.C.Types.CLLong
instance GHC.Real.Real Foreign.C.Types.CLLong
instance Foreign.Storable.Storable Foreign.C.Types.CLLong
instance GHC.Enum.Enum Foreign.C.Types.CLLong
instance GHC.Num.Num Foreign.C.Types.CLLong
instance GHC.Classes.Ord Foreign.C.Types.CLLong
instance GHC.Classes.Eq Foreign.C.Types.CLLong
instance GHC.Show.Show Foreign.C.Types.CULong
instance GHC.Read.Read Foreign.C.Types.CULong
instance Data.Bits.FiniteBits Foreign.C.Types.CULong
instance Data.Bits.Bits Foreign.C.Types.CULong
instance GHC.Real.Integral Foreign.C.Types.CULong
instance GHC.Enum.Bounded Foreign.C.Types.CULong
instance GHC.Real.Real Foreign.C.Types.CULong
instance Foreign.Storable.Storable Foreign.C.Types.CULong
instance GHC.Enum.Enum Foreign.C.Types.CULong
instance GHC.Num.Num Foreign.C.Types.CULong
instance GHC.Classes.Ord Foreign.C.Types.CULong
instance GHC.Classes.Eq Foreign.C.Types.CULong
instance GHC.Show.Show Foreign.C.Types.CLong
instance GHC.Read.Read Foreign.C.Types.CLong
instance Data.Bits.FiniteBits Foreign.C.Types.CLong
instance Data.Bits.Bits Foreign.C.Types.CLong
instance GHC.Real.Integral Foreign.C.Types.CLong
instance GHC.Enum.Bounded Foreign.C.Types.CLong
instance GHC.Real.Real Foreign.C.Types.CLong
instance Foreign.Storable.Storable Foreign.C.Types.CLong
instance GHC.Enum.Enum Foreign.C.Types.CLong
instance GHC.Num.Num Foreign.C.Types.CLong
instance GHC.Classes.Ord Foreign.C.Types.CLong
instance GHC.Classes.Eq Foreign.C.Types.CLong
instance GHC.Show.Show Foreign.C.Types.CUInt
instance GHC.Read.Read Foreign.C.Types.CUInt
instance Data.Bits.FiniteBits Foreign.C.Types.CUInt
instance Data.Bits.Bits Foreign.C.Types.CUInt
instance GHC.Real.Integral Foreign.C.Types.CUInt
instance GHC.Enum.Bounded Foreign.C.Types.CUInt
instance GHC.Real.Real Foreign.C.Types.CUInt
instance Foreign.Storable.Storable Foreign.C.Types.CUInt
instance GHC.Enum.Enum Foreign.C.Types.CUInt
instance GHC.Num.Num Foreign.C.Types.CUInt
instance GHC.Classes.Ord Foreign.C.Types.CUInt
instance GHC.Classes.Eq Foreign.C.Types.CUInt
instance GHC.Show.Show Foreign.C.Types.CInt
instance GHC.Read.Read Foreign.C.Types.CInt
instance Data.Bits.FiniteBits Foreign.C.Types.CInt
instance Data.Bits.Bits Foreign.C.Types.CInt
instance GHC.Real.Integral Foreign.C.Types.CInt
instance GHC.Enum.Bounded Foreign.C.Types.CInt
instance GHC.Real.Real Foreign.C.Types.CInt
instance Foreign.Storable.Storable Foreign.C.Types.CInt
instance GHC.Enum.Enum Foreign.C.Types.CInt
instance GHC.Num.Num Foreign.C.Types.CInt
instance GHC.Classes.Ord Foreign.C.Types.CInt
instance GHC.Classes.Eq Foreign.C.Types.CInt
instance GHC.Show.Show Foreign.C.Types.CUShort
instance GHC.Read.Read Foreign.C.Types.CUShort
instance Data.Bits.FiniteBits Foreign.C.Types.CUShort
instance Data.Bits.Bits Foreign.C.Types.CUShort
instance GHC.Real.Integral Foreign.C.Types.CUShort
instance GHC.Enum.Bounded Foreign.C.Types.CUShort
instance GHC.Real.Real Foreign.C.Types.CUShort
instance Foreign.Storable.Storable Foreign.C.Types.CUShort
instance GHC.Enum.Enum Foreign.C.Types.CUShort
instance GHC.Num.Num Foreign.C.Types.CUShort
instance GHC.Classes.Ord Foreign.C.Types.CUShort
instance GHC.Classes.Eq Foreign.C.Types.CUShort
instance GHC.Show.Show Foreign.C.Types.CShort
instance GHC.Read.Read Foreign.C.Types.CShort
instance Data.Bits.FiniteBits Foreign.C.Types.CShort
instance Data.Bits.Bits Foreign.C.Types.CShort
instance GHC.Real.Integral Foreign.C.Types.CShort
instance GHC.Enum.Bounded Foreign.C.Types.CShort
instance GHC.Real.Real Foreign.C.Types.CShort
instance Foreign.Storable.Storable Foreign.C.Types.CShort
instance GHC.Enum.Enum Foreign.C.Types.CShort
instance GHC.Num.Num Foreign.C.Types.CShort
instance GHC.Classes.Ord Foreign.C.Types.CShort
instance GHC.Classes.Eq Foreign.C.Types.CShort
instance GHC.Show.Show Foreign.C.Types.CUChar
instance GHC.Read.Read Foreign.C.Types.CUChar
instance Data.Bits.FiniteBits Foreign.C.Types.CUChar
instance Data.Bits.Bits Foreign.C.Types.CUChar
instance GHC.Real.Integral Foreign.C.Types.CUChar
instance GHC.Enum.Bounded Foreign.C.Types.CUChar
instance GHC.Real.Real Foreign.C.Types.CUChar
instance Foreign.Storable.Storable Foreign.C.Types.CUChar
instance GHC.Enum.Enum Foreign.C.Types.CUChar
instance GHC.Num.Num Foreign.C.Types.CUChar
instance GHC.Classes.Ord Foreign.C.Types.CUChar
instance GHC.Classes.Eq Foreign.C.Types.CUChar
instance GHC.Show.Show Foreign.C.Types.CSChar
instance GHC.Read.Read Foreign.C.Types.CSChar
instance Data.Bits.FiniteBits Foreign.C.Types.CSChar
instance Data.Bits.Bits Foreign.C.Types.CSChar
instance GHC.Real.Integral Foreign.C.Types.CSChar
instance GHC.Enum.Bounded Foreign.C.Types.CSChar
instance GHC.Real.Real Foreign.C.Types.CSChar
instance Foreign.Storable.Storable Foreign.C.Types.CSChar
instance GHC.Enum.Enum Foreign.C.Types.CSChar
instance GHC.Num.Num Foreign.C.Types.CSChar
instance GHC.Classes.Ord Foreign.C.Types.CSChar
instance GHC.Classes.Eq Foreign.C.Types.CSChar
instance GHC.Show.Show Foreign.C.Types.CChar
instance GHC.Read.Read Foreign.C.Types.CChar
instance Data.Bits.FiniteBits Foreign.C.Types.CChar
instance Data.Bits.Bits Foreign.C.Types.CChar
instance GHC.Real.Integral Foreign.C.Types.CChar
instance GHC.Enum.Bounded Foreign.C.Types.CChar
instance GHC.Real.Real Foreign.C.Types.CChar
instance Foreign.Storable.Storable Foreign.C.Types.CChar
instance GHC.Enum.Enum Foreign.C.Types.CChar
instance GHC.Num.Num Foreign.C.Types.CChar
instance GHC.Classes.Ord Foreign.C.Types.CChar
instance GHC.Classes.Eq Foreign.C.Types.CChar
module Data.Type.Equality
data a :~: b
[Refl] :: a :~: a
infix 4 :~:
class a ~# b => (~~) (a :: k0) (b :: k1)
data (a :: k1) :~~: (b :: k2)
[HRefl] :: a :~~: a
infix 4 :~~:
sym :: (a :~: b) -> b :~: a
trans :: (a :~: b) -> (b :~: c) -> a :~: c
castWith :: (a :~: b) -> a -> b
gcastWith :: (a :~: b) -> (a ~ b => r) -> r
apply :: (f :~: g) -> (a :~: b) -> f a :~: g b
inner :: (f a :~: g b) -> a :~: b
outer :: (f a :~: g b) -> f :~: g
class TestEquality f
testEquality :: TestEquality f => f a -> f b -> Maybe (a :~: b)
type family (a :: k) == (b :: k) :: Bool
infix 4 ==
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). GHC.Show.Show (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). (a Data.Type.Equality.~ b) => GHC.Read.Read (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). (a Data.Type.Equality.~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~: b)
instance forall k2 k1 (a :: k1) (b :: k2). GHC.Classes.Eq (a Data.Type.Equality.:~~: b)
instance forall k2 k1 (a :: k1) (b :: k2). GHC.Show.Show (a Data.Type.Equality.:~~: b)
instance forall k2 k1 (a :: k1) (b :: k2). GHC.Classes.Ord (a Data.Type.Equality.:~~: b)
instance forall k2 k1 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Read.Read (a Data.Type.Equality.:~~: b)
instance forall k2 k1 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~~: b)
instance forall k (a :: k). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a)
instance forall k k1 (a :: k1). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a)
instance forall k2 k1 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~~: b)
instance forall k (a :: k) (b :: k). (a Data.Type.Equality.~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). (a ~ b) => a Data.Type.Equality.~ b
module Data.Type.Coercion
data Coercion a b
[Coercion] :: Coercible a b => Coercion a b
coerceWith :: Coercion a b -> a -> b
gcoerceWith :: Coercion a b -> (Coercible a b => r) -> r
sym :: Coercion a b -> Coercion b a
trans :: Coercion a b -> Coercion b c -> Coercion a c
repr :: (a :~: b) -> Coercion a b
class TestCoercion f
testCoercion :: TestCoercion f => f a -> f b -> Maybe (Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Show.Show (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Read.Read (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a)
instance forall k k1 (a :: k1). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a)
instance forall k (a :: k). Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Enum.Enum (Data.Type.Coercion.Coercion a b)
module Control.Category
class Category cat
id :: Category cat => cat a a
(.) :: Category cat => cat b c -> cat a b -> cat a c
infixr 9 .
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>
instance Control.Category.Category (->)
instance Control.Category.Category (Data.Type.Equality.:~:)
instance Control.Category.Category (Data.Type.Equality.:~~:)
instance Control.Category.Category Data.Type.Coercion.Coercion
module Data.Proxy
data Proxy t
Proxy :: Proxy t
asProxyTypeOf :: a -> proxy a -> a
data KProxy (t :: Type)
KProxy :: KProxy
instance forall k (t :: k). GHC.Read.Read (Data.Proxy.Proxy t)
instance forall k (t :: k). GHC.Enum.Bounded (Data.Proxy.Proxy t)
instance forall k (s :: k). GHC.Classes.Eq (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Classes.Ord (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Show.Show (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Enum.Enum (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Arr.Ix (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Base.Semigroup (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Base.Monoid (Data.Proxy.Proxy s)
instance GHC.Base.Functor Data.Proxy.Proxy
instance GHC.Base.Applicative Data.Proxy.Proxy
instance GHC.Base.Alternative Data.Proxy.Proxy
instance GHC.Base.Monad Data.Proxy.Proxy
instance GHC.Base.MonadPlus Data.Proxy.Proxy
module Data.Ord
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <=
infix 4 >=
infix 4 <
infix 4 >
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
newtype Down a
Down :: a -> Down a
comparing :: Ord a => (b -> a) -> b -> b -> Ordering
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Ord.Down a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Ord.Down a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Ord.Down a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Ord.Down a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Ord.Down a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Ord.Down a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Ord.Down a)
instance GHC.Base.Functor Data.Ord.Down
instance GHC.Base.Applicative Data.Ord.Down
instance GHC.Base.Monad Data.Ord.Down
module Data.Either
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b
either :: (a -> c) -> (b -> c) -> Either a b -> c
lefts :: [Either a b] -> [a]
rights :: [Either a b] -> [b]
isLeft :: Either a b -> Bool
isRight :: Either a b -> Bool
-- fromLeft :: a -> Either a b -> a
-- fromRight :: b -> Either a b -> b
partitionEithers :: [Either a b] -> ([a], [b])
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Either.Either a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Either.Either a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Either.Either a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Either.Either a b)
instance GHC.Base.Functor (Data.Either.Either a)
instance GHC.Base.Semigroup (Data.Either.Either a b)
instance GHC.Base.Applicative (Data.Either.Either e)
instance GHC.Base.Monad (Data.Either.Either e)
module Text.Read
class Read a
readsPrec :: Read a => Int -> ReadS a
readList :: Read a => ReadS [a]
readPrec :: Read a => ReadPrec a
readListPrec :: Read a => ReadPrec [a]
type ReadS a = String -> [(a, String)]
reads :: Read a => ReadS a
read :: Read a => String -> a
readParen :: Bool -> ReadS a -> ReadS a
lex :: ReadS String
data Lexeme
Char :: Char -> Lexeme
String :: String -> Lexeme
Punc :: String -> Lexeme
Ident :: String -> Lexeme
Symbol :: String -> Lexeme
Number :: Number -> Lexeme
EOF :: Lexeme
lexP :: ReadPrec Lexeme
parens :: ReadPrec a -> ReadPrec a
readListDefault :: Read a => ReadS [a]
readListPrecDefault :: Read a => ReadPrec [a]
readEither :: Read a => String -> Either String a
readMaybe :: Read a => String -> Maybe a
module Data.Char
data Char
isControl :: Char -> Bool
isSpace :: Char -> Bool
isLower :: Char -> Bool
isUpper :: Char -> Bool
isAlpha :: Char -> Bool
isAlphaNum :: Char -> Bool
isPrint :: Char -> Bool
isDigit :: Char -> Bool
isOctDigit :: Char -> Bool
isHexDigit :: Char -> Bool
isLetter :: Char -> Bool
isMark :: Char -> Bool
isNumber :: Char -> Bool
isPunctuation :: Char -> Bool
isSymbol :: Char -> Bool
isSeparator :: Char -> Bool
isAscii :: Char -> Bool
isLatin1 :: Char -> Bool
isAsciiUpper :: Char -> Bool
isAsciiLower :: Char -> Bool
data GeneralCategory
UppercaseLetter :: GeneralCategory
LowercaseLetter :: GeneralCategory
TitlecaseLetter :: GeneralCategory
ModifierLetter :: GeneralCategory
OtherLetter :: GeneralCategory
NonSpacingMark :: GeneralCategory
SpacingCombiningMark :: GeneralCategory
EnclosingMark :: GeneralCategory
DecimalNumber :: GeneralCategory
LetterNumber :: GeneralCategory
OtherNumber :: GeneralCategory
ConnectorPunctuation :: GeneralCategory
DashPunctuation :: GeneralCategory
OpenPunctuation :: GeneralCategory
ClosePunctuation :: GeneralCategory
InitialQuote :: GeneralCategory
FinalQuote :: GeneralCategory
OtherPunctuation :: GeneralCategory
MathSymbol :: GeneralCategory
CurrencySymbol :: GeneralCategory
ModifierSymbol :: GeneralCategory
OtherSymbol :: GeneralCategory
Space :: GeneralCategory
LineSeparator :: GeneralCategory
ParagraphSeparator :: GeneralCategory
Control :: GeneralCategory
Format :: GeneralCategory
Surrogate :: GeneralCategory
PrivateUse :: GeneralCategory
NotAssigned :: GeneralCategory
generalCategory :: Char -> GeneralCategory
toUpper :: Char -> Char
toLower :: Char -> Char
toTitle :: Char -> Char
digitToInt :: Char -> Int
intToDigit :: Int -> Char
ord :: Char -> Int
chr :: Int -> Char
showLitChar :: Char -> ShowS
lexLitChar :: ReadS String
readLitChar :: ReadS Char
module GHC.OldList
(++) :: [a] -> [a] -> [a]
infixr 5 ++
uncons :: [a] -> Maybe (a, [a])
null :: [a] -> Bool
length :: [a] -> Int
map :: (a -> b) -> [a] -> [b]
reverse :: [a] -> [a]
intersperse :: a -> [a] -> [a]
intercalate :: [a] -> [[a]] -> [a]
transpose :: [[a]] -> [[a]]
subsequences :: [a] -> [[a]]
permutations :: [a] -> [[a]]
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b
foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b
foldl1 :: (a -> a -> a) -> [a] -> a
foldl1' :: (a -> a -> a) -> [a] -> a
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr1 :: (a -> a -> a) -> [a] -> a
concat :: [[a]] -> [a]
concatMap :: (a -> [b]) -> [a] -> [b]
and :: [Bool] -> Bool
or :: [Bool] -> Bool
any :: (a -> Bool) -> [a] -> Bool
all :: (a -> Bool) -> [a] -> Bool
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl' :: (b -> a -> b) -> b -> [a] -> [b]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
iterate :: (a -> a) -> a -> [a]
iterate' :: (a -> a) -> a -> [a]
replicate :: Int -> a -> [a]
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhileEnd :: (a -> Bool) -> [a] -> [a]
span :: (a -> Bool) -> [a] -> ([a], [a])
break :: (a -> Bool) -> [a] -> ([a], [a])
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
group :: Eq a => [a] -> [[a]]
inits :: [a] -> [[a]]
tails :: [a] -> [[a]]
isPrefixOf :: Eq a => [a] -> [a] -> Bool
isSuffixOf :: Eq a => [a] -> [a] -> Bool
isInfixOf :: Eq a => [a] -> [a] -> Bool
elem :: Eq a => a -> [a] -> Bool
infix 4 `elem`
notElem :: Eq a => a -> [a] -> Bool
infix 4 `notElem`
lookup :: Eq a => a -> [(a, b)] -> Maybe b
find :: (a -> Bool) -> [a] -> Maybe a
filter :: (a -> Bool) -> [a] -> [a]
partition :: (a -> Bool) -> [a] -> ([a], [a])
elemIndex :: Eq a => a -> [a] -> Maybe Int
elemIndices :: Eq a => a -> [a] -> [Int]
findIndex :: (a -> Bool) -> [a] -> Maybe Int
findIndices :: (a -> Bool) -> [a] -> [Int]
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
lines :: String -> [String]
words :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
nub :: Eq a => [a] -> [a]
delete :: Eq a => a -> [a] -> [a]
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\
union :: Eq a => [a] -> [a] -> [a]
intersect :: Eq a => [a] -> [a] -> [a]
sort :: Ord a => [a] -> [a]
sortOn :: Ord b => (a -> b) -> [a] -> [a]
insert :: Ord a => a -> [a] -> [a]
nubBy :: (a -> a -> Bool) -> [a] -> [a]
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
sortBy :: (a -> a -> Ordering) -> [a] -> [a]
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
maximumBy :: (a -> a -> Ordering) -> [a] -> a
minimumBy :: (a -> a -> Ordering) -> [a] -> a
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])
genericIndex :: Integral i => [a] -> i -> a
genericReplicate :: Integral i => i -> a -> [a]
module Text.Show
type ShowS = String -> String
class Show a
showsPrec :: Show a => Int -> a -> ShowS
show :: Show a => a -> String
showList :: Show a => [a] -> ShowS
shows :: Show a => a -> ShowS
showChar :: Char -> ShowS
showString :: String -> ShowS
showParen :: Bool -> ShowS -> ShowS
showListWith :: (a -> ShowS) -> [a] -> ShowS
module Unsafe.Coerce
unsafeCoerce :: a -> b
module GHC.TypeNats
data Nat
class KnownNat (n :: Nat)
natVal :: forall n proxy. KnownNat n => proxy n -> Natural
natVal' :: forall n. KnownNat n => Proxy# n -> Natural
data SomeNat
SomeNat :: Proxy n -> SomeNat
someNatVal :: Natural -> SomeNat
sameNat :: (KnownNat a, KnownNat b) => Proxy a -> Proxy b -> Maybe (a :~: b)
type x <= y = (x <=? y) ~  'True
infix 4 <=
type family (m :: Nat) <=? (n :: Nat) :: Bool
infix 4 <=?
type family (m :: Nat) + (n :: Nat) :: Nat
infixl 6 +
type family (m :: Nat) * (n :: Nat) :: Nat
infixl 7 *
type family (m :: Nat) ^ (n :: Nat) :: Nat
infixr 8 ^
type family (m :: Nat) - (n :: Nat) :: Nat
infixl 6 -
type family CmpNat (m :: Nat) (n :: Nat) :: Ordering
type family Div (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Div`
type family Mod (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Mod`
type family Log2 (m :: Nat) :: Nat
instance GHC.Classes.Eq GHC.TypeNats.SomeNat
instance GHC.Classes.Ord GHC.TypeNats.SomeNat
instance GHC.Show.Show GHC.TypeNats.SomeNat
instance GHC.Read.Read GHC.TypeNats.SomeNat
module GHC.TypeLits
data Nat
data Symbol
class KnownNat (n :: Nat)
natVal :: forall n proxy. KnownNat n => proxy n -> Integer
natVal' :: forall n. KnownNat n => Proxy# n -> Integer
class KnownSymbol (n :: Symbol)
symbolVal :: forall n proxy. KnownSymbol n => proxy n -> String
symbolVal' :: forall n. KnownSymbol n => Proxy# n -> String
data SomeNat
SomeNat :: Proxy n -> SomeNat
data SomeSymbol
SomeSymbol :: Proxy n -> SomeSymbol
someNatVal :: Integer -> Maybe SomeNat
someSymbolVal :: String -> SomeSymbol
sameNat :: (KnownNat a, KnownNat b) => Proxy a -> Proxy b -> Maybe (a :~: b)
sameSymbol :: (KnownSymbol a, KnownSymbol b) => Proxy a -> Proxy b -> Maybe (a :~: b)
type x <= y = (x <=? y) ~  'True
infix 4 <=
type family (m :: Nat) <=? (n :: Nat) :: Bool
infix 4 <=?
type family (m :: Nat) + (n :: Nat) :: Nat
infixl 6 +
type family (m :: Nat) * (n :: Nat) :: Nat
infixl 7 *
type family (m :: Nat) ^ (n :: Nat) :: Nat
infixr 8 ^
type family (m :: Nat) - (n :: Nat) :: Nat
infixl 6 -
type family Div (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Div`
type family Mod (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Mod`
type family Log2 (m :: Nat) :: Nat
type family AppendSymbol (m :: Symbol) (n :: Symbol) :: Symbol
type family CmpNat (m :: Nat) (n :: Nat) :: Ordering
type family CmpSymbol (m :: Symbol) (n :: Symbol) :: Ordering
type family TypeError (a :: ErrorMessage) :: b
data ErrorMessage
Text :: Symbol -> ErrorMessage
ShowType :: t -> ErrorMessage
(:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
(:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
infixl 6 :<>:
infixl 5 :$$:
instance GHC.Classes.Eq GHC.TypeLits.SomeSymbol
instance GHC.Classes.Ord GHC.TypeLits.SomeSymbol
instance GHC.Show.Show GHC.TypeLits.SomeSymbol
instance GHC.Read.Read GHC.TypeLits.SomeSymbol
module GHC.Generics
data V1 (p :: k)
data U1 (p :: k)
U1 :: U1
newtype Par1 p
Par1 :: p -> Par1 p
[unPar1] :: Par1 p -> p
newtype Rec1 (f :: k -> Type) (p :: k)
Rec1 :: f p -> Rec1
[unRec1] :: Rec1 -> f p
newtype K1 (i :: Type) c (p :: k)
K1 :: c -> K1 c
[unK1] :: K1 c -> c
newtype M1 (i :: Type) (c :: Meta) (f :: k -> Type) (p :: k)
M1 :: f p -> M1
[unM1] :: M1 -> f p
data (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
L1 :: f p -> (:+:)
R1 :: g p -> (:+:)
infixr 5 :+:
data (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
(:*:) :: f p -> g p -> (:*:)
infixr 6 :*:
infixr 6 :*:
newtype (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1)
Comp1 :: f (g p) -> (:.:)
[unComp1] :: (:.:) -> f (g p)
infixr 7 :.:
data family URec (a :: Type) (p :: k)
type UAddr = URec (Ptr ())
type UChar = URec Char
type UDouble = URec Double
type UFloat = URec Float
type UInt = URec Int
type UWord = URec Word
type Rec0 = K1 R
data R
type D1 = M1 D
type C1 = M1 C
type S1 = M1 S
data D
data C
data S
class Datatype d
datatypeName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]
moduleName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]
packageName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]
isNewtype :: Datatype d => t d (f :: k -> Type) (a :: k) -> Bool
class Constructor c
conName :: Constructor c => t c (f :: k -> Type) (a :: k) -> [Char]
conFixity :: Constructor c => t c (f :: k -> Type) (a :: k) -> Fixity
conIsRecord :: Constructor c => t c (f :: k -> Type) (a :: k) -> Bool
class Selector s
selName :: Selector s => t s (f :: k -> Type) (a :: k) -> [Char]
selSourceUnpackedness :: Selector s => t s (f :: k -> Type) (a :: k) -> SourceUnpackedness
selSourceStrictness :: Selector s => t s (f :: k -> Type) (a :: k) -> SourceStrictness
selDecidedStrictness :: Selector s => t s (f :: k -> Type) (a :: k) -> DecidedStrictness
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity
data FixityI
PrefixI :: FixityI
InfixI :: Associativity -> Nat -> FixityI
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity
prec :: Fixity -> Int
data SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness
data SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness
data Meta
MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
MetaCons :: Symbol -> FixityI -> Bool -> Meta
MetaSel :: Maybe Symbol -> SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> Meta
class Generic a where {

    type family Rep a :: Type -> Type;
}
from :: Generic a => a -> Rep a x
to :: Generic a => Rep a x -> a
class Generic1 (f :: k -> Type) where {

    type family Rep1 f :: k -> Type;
}
from1 :: Generic1 f => f a -> Rep1 f a
to1 :: Generic1 f => Rep1 f a -> f a
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.M1 i c f)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.M1 i c f p)
instance GHC.Base.Functor f => GHC.Base.Functor (GHC.Generics.M1 i c f)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.M1 i c f p)
instance GHC.Generics.Generic1 GHC.Generics.V1
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.V1 p)
instance GHC.Base.Functor GHC.Generics.V1
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.V1 p)
instance GHC.Generics.Generic1 GHC.Generics.U1
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.U1 p)
instance GHC.Generics.Generic1 GHC.Generics.Par1
instance GHC.Generics.Generic (GHC.Generics.Par1 p)
instance GHC.Base.Functor GHC.Generics.Par1
instance GHC.Show.Show p => GHC.Show.Show (GHC.Generics.Par1 p)
instance GHC.Read.Read p => GHC.Read.Read (GHC.Generics.Par1 p)
instance GHC.Classes.Ord p => GHC.Classes.Ord (GHC.Generics.Par1 p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (GHC.Generics.Par1 p)
instance forall k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.Rec1 f p)
instance GHC.Base.Functor f => GHC.Base.Functor (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.Rec1 f p)
instance GHC.Generics.Generic1 (GHC.Generics.K1 i c)
instance forall i c k (p :: k). GHC.Generics.Generic (GHC.Generics.K1 i c p)
instance GHC.Base.Functor (GHC.Generics.K1 i c)
instance forall i c k (p :: k). GHC.Show.Show c => GHC.Show.Show (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Read.Read c => GHC.Read.Read (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Classes.Ord c => GHC.Classes.Ord (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Classes.Eq c => GHC.Classes.Eq (GHC.Generics.K1 i c p)
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:+:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:*:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:*:) f g p)
instance forall (f :: * -> *) k (g :: k -> *). GHC.Base.Functor f => GHC.Generics.Generic1 (f GHC.Generics.:.: g)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Generics.Generic ((GHC.Generics.:.:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:.: g)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Show.Show (f (g p)) => GHC.Show.Show ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Read.Read (f (g p)) => GHC.Read.Read ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Ord (f (g p)) => GHC.Classes.Ord ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Eq (f (g p)) => GHC.Classes.Eq ((GHC.Generics.:.:) f g p)
instance GHC.Generics.Generic GHC.Generics.Fixity
instance GHC.Read.Read GHC.Generics.Fixity
instance GHC.Classes.Ord GHC.Generics.Fixity
instance GHC.Show.Show GHC.Generics.Fixity
instance GHC.Classes.Eq GHC.Generics.Fixity
instance GHC.Generics.Generic GHC.Generics.Associativity
instance GHC.Arr.Ix GHC.Generics.Associativity
instance GHC.Enum.Bounded GHC.Generics.Associativity
instance GHC.Enum.Enum GHC.Generics.Associativity
instance GHC.Read.Read GHC.Generics.Associativity
instance GHC.Classes.Ord GHC.Generics.Associativity
instance GHC.Show.Show GHC.Generics.Associativity
instance GHC.Classes.Eq GHC.Generics.Associativity
instance GHC.Generics.Generic GHC.Generics.SourceUnpackedness
instance GHC.Arr.Ix GHC.Generics.SourceUnpackedness
instance GHC.Enum.Bounded GHC.Generics.SourceUnpackedness
instance GHC.Enum.Enum GHC.Generics.SourceUnpackedness
instance GHC.Read.Read GHC.Generics.SourceUnpackedness
instance GHC.Classes.Ord GHC.Generics.SourceUnpackedness
instance GHC.Show.Show GHC.Generics.SourceUnpackedness
instance GHC.Classes.Eq GHC.Generics.SourceUnpackedness
instance GHC.Generics.Generic GHC.Generics.SourceStrictness
instance GHC.Arr.Ix GHC.Generics.SourceStrictness
instance GHC.Enum.Bounded GHC.Generics.SourceStrictness
instance GHC.Enum.Enum GHC.Generics.SourceStrictness
instance GHC.Read.Read GHC.Generics.SourceStrictness
instance GHC.Classes.Ord GHC.Generics.SourceStrictness
instance GHC.Show.Show GHC.Generics.SourceStrictness
instance GHC.Classes.Eq GHC.Generics.SourceStrictness
instance GHC.Generics.Generic GHC.Generics.DecidedStrictness
instance GHC.Arr.Ix GHC.Generics.DecidedStrictness
instance GHC.Enum.Bounded GHC.Generics.DecidedStrictness
instance GHC.Enum.Enum GHC.Generics.DecidedStrictness
instance GHC.Read.Read GHC.Generics.DecidedStrictness
instance GHC.Classes.Ord GHC.Generics.DecidedStrictness
instance GHC.Show.Show GHC.Generics.DecidedStrictness
instance GHC.Classes.Eq GHC.Generics.DecidedStrictness
instance GHC.Generics.Generic1 (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance GHC.Base.Functor (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Char)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Char p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Char)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Char p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Double)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Double p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Double)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Double p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Float)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Float p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Float)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Float p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Int)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Int p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Int)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Int p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Word)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Word p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Word)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.U1 p)
instance GHC.Base.Semigroup p => GHC.Base.Semigroup (GHC.Generics.Par1 p)
instance GHC.Base.Monoid p => GHC.Base.Monoid (GHC.Generics.Par1 p)
instance GHC.Base.Applicative f => GHC.Base.Applicative (GHC.Generics.Rec1 f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (GHC.Generics.Rec1 f)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.Rec1 f p)
instance forall k c i (p :: k). GHC.Base.Semigroup c => GHC.Base.Semigroup (GHC.Generics.K1 i c p)
instance forall k c i (p :: k). GHC.Base.Monoid c => GHC.Base.Monoid (GHC.Generics.K1 i c p)
instance GHC.Base.Applicative f => GHC.Base.Applicative (GHC.Generics.M1 i c f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (GHC.Generics.M1 i c f)
instance GHC.Base.Monad f => GHC.Base.Monad (GHC.Generics.M1 i c f)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.M1 i c f p)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.M1 i c f p)
instance forall k1 k2 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Semigroup (f (g p)) => GHC.Base.Semigroup ((GHC.Generics.:.:) f g p)
instance forall k1 k2 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Monoid (f (g p)) => GHC.Base.Monoid ((GHC.Generics.:.:) f g p)
instance GHC.Generics.Generic [a]
instance GHC.Generics.Generic (GHC.Base.NonEmpty a)
instance GHC.Generics.Generic (GHC.Maybe.Maybe a)
instance GHC.Generics.Generic (Data.Either.Either a b)
instance GHC.Generics.Generic GHC.Types.Bool
instance GHC.Generics.Generic GHC.Types.Ordering
instance forall k (t :: k). GHC.Generics.Generic (Data.Proxy.Proxy t)
instance GHC.Generics.Generic ()
instance GHC.Generics.Generic (a, b)
instance GHC.Generics.Generic (a, b, c)
instance GHC.Generics.Generic (a, b, c, d)
instance GHC.Generics.Generic (a, b, c, d, e)
instance GHC.Generics.Generic (a, b, c, d, e, f)
instance GHC.Generics.Generic (a, b, c, d, e, f, g)
instance GHC.Generics.Generic (Data.Ord.Down a)
instance GHC.Generics.Generic1 []
instance GHC.Generics.Generic1 GHC.Base.NonEmpty
instance GHC.Generics.Generic1 GHC.Maybe.Maybe
instance GHC.Generics.Generic1 (Data.Either.Either a)
instance GHC.Generics.Generic1 Data.Proxy.Proxy
instance GHC.Generics.Generic1 ((,) a)
instance GHC.Generics.Generic1 ((,,) a b)
instance GHC.Generics.Generic1 ((,,,) a b c)
instance GHC.Generics.Generic1 ((,,,,) a b c d)
instance GHC.Generics.Generic1 ((,,,,,) a b c d e)
instance GHC.Generics.Generic1 ((,,,,,,) a b c d e f)
instance GHC.Generics.Generic1 Data.Ord.Down
instance (GHC.TypeLits.KnownSymbol n, GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol p, GHC.Generics.SingI nt) => GHC.Generics.Datatype ('GHC.Generics.MetaData n m p nt)
instance (GHC.TypeLits.KnownSymbol n, GHC.Generics.SingI f, GHC.Generics.SingI r) => GHC.Generics.Constructor ('GHC.Generics.MetaCons n f r)
instance (GHC.Generics.SingI mn, GHC.Generics.SingI su, GHC.Generics.SingI ss, GHC.Generics.SingI ds) => GHC.Generics.Selector ('GHC.Generics.MetaSel mn su ss ds)
instance GHC.Generics.SingKind GHC.Types.Symbol
instance GHC.Generics.SingKind GHC.Types.Bool
instance GHC.Generics.SingKind a => GHC.Generics.SingKind (GHC.Maybe.Maybe a)
instance GHC.Generics.SingKind GHC.Generics.FixityI
instance GHC.Generics.SingKind GHC.Generics.Associativity
instance GHC.Generics.SingKind GHC.Generics.SourceUnpackedness
instance GHC.Generics.SingKind GHC.Generics.SourceStrictness
instance GHC.Generics.SingKind GHC.Generics.DecidedStrictness
instance GHC.TypeLits.KnownSymbol a => GHC.Generics.SingI a
instance GHC.Generics.SingI 'GHC.Types.True
instance GHC.Generics.SingI 'GHC.Types.False
instance GHC.Generics.SingI 'GHC.Maybe.Nothing
instance forall a1 (a2 :: a1). GHC.Generics.SingI a2 => GHC.Generics.SingI ('GHC.Maybe.Just a2)
instance GHC.Generics.SingI 'GHC.Generics.PrefixI
instance (GHC.Generics.SingI a, GHC.TypeNats.KnownNat n) => GHC.Generics.SingI ('GHC.Generics.InfixI a n)
instance GHC.Generics.SingI 'GHC.Generics.LeftAssociative
instance GHC.Generics.SingI 'GHC.Generics.RightAssociative
instance GHC.Generics.SingI 'GHC.Generics.NotAssociative
instance GHC.Generics.SingI 'GHC.Generics.NoSourceUnpackedness
instance GHC.Generics.SingI 'GHC.Generics.SourceNoUnpack
instance GHC.Generics.SingI 'GHC.Generics.SourceUnpack
instance GHC.Generics.SingI 'GHC.Generics.NoSourceStrictness
instance GHC.Generics.SingI 'GHC.Generics.SourceLazy
instance GHC.Generics.SingI 'GHC.Generics.SourceStrict
instance GHC.Generics.SingI 'GHC.Generics.DecidedLazy
instance GHC.Generics.SingI 'GHC.Generics.DecidedStrict
instance GHC.Generics.SingI 'GHC.Generics.DecidedUnpack
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.U1 p)
instance GHC.Base.Functor GHC.Generics.U1
instance GHC.Base.Applicative GHC.Generics.U1
instance GHC.Base.Alternative GHC.Generics.U1
instance GHC.Base.Monad GHC.Generics.U1
instance GHC.Base.MonadPlus GHC.Generics.U1
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Base.Monoid (GHC.Generics.U1 p)
instance GHC.Base.Applicative GHC.Generics.Par1
instance GHC.Base.Monad GHC.Generics.Par1
instance GHC.Base.Monad f => GHC.Base.Monad (GHC.Generics.Rec1 f)
instance GHC.Base.Monoid c => GHC.Base.Applicative (GHC.Generics.K1 i c)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (f GHC.Generics.:*: g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (f GHC.Generics.:*: g)
instance (GHC.Base.Monad f, GHC.Base.Monad g) => GHC.Base.Monad (f GHC.Generics.:*: g)
instance (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) => GHC.Base.MonadPlus (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Semigroup (f p), GHC.Base.Semigroup (g p)) => GHC.Base.Semigroup ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Monoid (f p), GHC.Base.Monoid (g p)) => GHC.Base.Monoid ((GHC.Generics.:*:) f g p)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (f GHC.Generics.:.: g)
instance (GHC.Base.Alternative f, GHC.Base.Applicative g) => GHC.Base.Alternative (f GHC.Generics.:.: g)
module Data.Monoid
class Semigroup a => Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a
newtype All
All :: Bool -> All
[getAll] :: All -> Bool
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a
newtype Alt f a
Alt :: f a -> Alt f a
[getAlt] :: Alt f a -> f a
newtype Ap f a
Ap :: f a -> Ap f a
[getAp] :: Ap f a -> f a
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Monoid.Ap f a)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (Data.Monoid.Ap f)
instance Control.Monad.Fail.MonadFail f => Control.Monad.Fail.MonadFail (Data.Monoid.Ap f)
instance GHC.Base.Monad f => GHC.Base.Monad (Data.Monoid.Ap f)
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Data.Monoid.Ap f)
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Data.Monoid.Ap f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Monoid.Ap f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Enum.Enum (f a) => GHC.Enum.Enum (Data.Monoid.Ap f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Monoid.Ap f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Monoid.Ap f)
instance GHC.Base.Monad Data.Monoid.Last
instance GHC.Base.Applicative Data.Monoid.Last
instance GHC.Base.Functor Data.Monoid.Last
instance GHC.Generics.Generic1 Data.Monoid.Last
instance GHC.Generics.Generic (Data.Monoid.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Last a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Last a)
instance GHC.Base.Monad Data.Monoid.First
instance GHC.Base.Applicative Data.Monoid.First
instance GHC.Base.Functor Data.Monoid.First
instance GHC.Generics.Generic1 Data.Monoid.First
instance GHC.Generics.Generic (Data.Monoid.First a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.First a)
instance (GHC.Base.Applicative f, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Enum.Bounded a) => GHC.Enum.Bounded (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Num.Num a) => GHC.Num.Num (Data.Monoid.Ap f a)
instance GHC.Base.Semigroup (Data.Monoid.Last a)
instance GHC.Base.Monoid (Data.Monoid.Last a)
instance GHC.Base.Semigroup (Data.Monoid.First a)
instance GHC.Base.Monoid (Data.Monoid.First a)
module Data.Foldable
class Foldable t
fold :: (Foldable t, Monoid m) => t m -> m
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
toList :: Foldable t => t a -> [a]
null :: Foldable t => t a -> Bool
length :: Foldable t => t a -> Int
elem :: (Foldable t, Eq a) => a -> t a -> Bool
sum :: (Foldable t, Num a) => t a -> a
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
asum :: (Foldable t, Alternative f) => t (f a) -> f a
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
concat :: Foldable t => t [a] -> [a]
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
and :: Foldable t => t Bool -> Bool
or :: Foldable t => t Bool -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
all :: Foldable t => (a -> Bool) -> t a -> Bool
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
instance Data.Foldable.Foldable GHC.Generics.V1
instance Data.Foldable.Foldable GHC.Generics.Par1
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (GHC.Generics.Rec1 f)
instance Data.Foldable.Foldable (GHC.Generics.K1 i c)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (GHC.Generics.M1 i c f)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:+: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:*: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:.: g)
instance Data.Foldable.Foldable (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Char)
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Double)
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Float)
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Int)
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Word)
instance Data.Foldable.Foldable Data.Ord.Down
instance Data.Foldable.Foldable GHC.Maybe.Maybe
instance Data.Foldable.Foldable []
instance Data.Foldable.Foldable GHC.Base.NonEmpty
instance Data.Foldable.Foldable (Data.Either.Either a)
instance Data.Foldable.Foldable ((,) a)
instance Data.Foldable.Foldable (GHC.Arr.Array i)
instance Data.Foldable.Foldable Data.Proxy.Proxy
instance Data.Foldable.Foldable Data.Semigroup.Internal.Dual
instance Data.Foldable.Foldable Data.Semigroup.Internal.Sum
instance Data.Foldable.Foldable Data.Semigroup.Internal.Product
instance Data.Foldable.Foldable Data.Monoid.First
instance Data.Foldable.Foldable Data.Monoid.Last
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Semigroup.Internal.Alt f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Monoid.Ap f)
instance Data.Foldable.Foldable GHC.Generics.U1
module Data.Functor.Const
newtype Const a b
Const :: a -> Const a b
[getConst] :: Const a b -> a
instance forall a k (b :: k). Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Real a => GHC.Real.Real (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Num.Num a => GHC.Num.Num (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Arr.Ix a => GHC.Arr.Ix (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Const.Const a b)
instance GHC.Generics.Generic1 (Data.Functor.Const.Const a)
instance forall a k (b :: k). GHC.Generics.Generic (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Const.Const a b)
instance forall a k (b :: k). Data.Bits.FiniteBits a => Data.Bits.FiniteBits (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Const.Const a b)
instance forall a k (b :: k). Data.Bits.Bits a => Data.Bits.Bits (Data.Functor.Const.Const a b)
instance forall k a (b :: k). GHC.Read.Read a => GHC.Read.Read (Data.Functor.Const.Const a b)
instance forall k a (b :: k). GHC.Show.Show a => GHC.Show.Show (Data.Functor.Const.Const a b)
instance Data.Foldable.Foldable (Data.Functor.Const.Const m)
instance GHC.Base.Functor (Data.Functor.Const.Const m)
instance GHC.Base.Monoid m => GHC.Base.Applicative (Data.Functor.Const.Const m)
module Type.Reflection
class Typeable (a :: k)
typeRep :: Typeable a => TypeRep a
withTypeable :: forall k (a :: k) rep (r :: TYPE rep). () => TypeRep a -> (Typeable a => r) -> r
data a :~: b
[Refl] :: a :~: a
infix 4 :~:
data (a :: k1) :~~: (b :: k2)
[HRefl] :: a :~~: a
infix 4 :~~:
data TypeRep (a :: k)
typeOf :: Typeable a => a -> TypeRep a
typeRepTyCon :: TypeRep a -> TyCon
rnfTypeRep :: TypeRep a -> ()
eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> Maybe (a :~~: b)
typeRepKind :: TypeRep (a :: k) -> TypeRep k
splitApps :: TypeRep a -> (TyCon, [SomeTypeRep])
data SomeTypeRep
[SomeTypeRep] :: forall k (a :: k). !TypeRep a -> SomeTypeRep
someTypeRep :: forall proxy a. Typeable a => proxy a -> SomeTypeRep
someTypeRepTyCon :: SomeTypeRep -> TyCon
rnfSomeTypeRep :: SomeTypeRep -> ()
data TyCon
tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String
rnfTyCon :: TyCon -> ()
data Module
moduleName :: Module -> String
modulePackage :: Module -> String
rnfModule :: Module -> ()
module Data.Typeable
class Typeable (a :: k)
typeOf :: forall a. Typeable a => a -> TypeRep
typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep
data a :~: b
[Refl] :: a :~: a
infix 4 :~:
data (a :: k1) :~~: (b :: k2)
[HRefl] :: a :~~: a
infix 4 :~~:
cast :: forall a b. (Typeable a, Typeable b) => a -> Maybe b
eqT :: forall a b. (Typeable a, Typeable b) => Maybe (a :~: b)
gcast :: forall a b c. (Typeable a, Typeable b) => c a -> Maybe (c b)
gcast1 :: forall c t t' a. (Typeable t, Typeable t') => c (t a) -> Maybe (c (t' a))
gcast2 :: forall c t t' a b. (Typeable t, Typeable t') => c (t a b) -> Maybe (c (t' a b))
data Proxy t
Proxy :: Proxy t
type TypeRep = SomeTypeRep
rnfTypeRep :: TypeRep -> ()
showsTypeRep :: TypeRep -> ShowS
mkFunTy :: TypeRep -> TypeRep -> TypeRep
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
typeRepArgs :: TypeRep -> [TypeRep]
typeRepTyCon :: TypeRep -> TyCon
typeRepFingerprint :: TypeRep -> Fingerprint
data TyCon
tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String
rnfTyCon :: TyCon -> ()
tyConFingerprint :: TyCon -> Fingerprint
typeOf1 :: forall t (a :: Type). Typeable t => t a -> TypeRep
typeOf2 :: forall t (a :: Type) (b :: Type). Typeable t => t a b -> TypeRep
typeOf3 :: forall t (a :: Type) (b :: Type) (c :: Type). Typeable t => t a b c -> TypeRep
typeOf4 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type). Typeable t => t a b c d -> TypeRep
typeOf5 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type). Typeable t => t a b c d e -> TypeRep
typeOf6 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type) (f :: Type). Typeable t => t a b c d e f -> TypeRep
typeOf7 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type) (f :: Type) (g :: Type). Typeable t => t a b c d e f g -> TypeRep
module Foreign.ForeignPtr.Unsafe
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
module Foreign.ForeignPtr.Safe
data ForeignPtr a
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
finalizeForeignPtr :: ForeignPtr a -> IO ()
touchForeignPtr :: ForeignPtr a -> IO ()
castForeignPtr :: ForeignPtr a -> ForeignPtr b
mallocForeignPtr :: Storable a => IO (ForeignPtr a)
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)
module Foreign.ForeignPtr
data ForeignPtr a
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
finalizeForeignPtr :: ForeignPtr a -> IO ()
touchForeignPtr :: ForeignPtr a -> IO ()
castForeignPtr :: ForeignPtr a -> ForeignPtr b
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b
mallocForeignPtr :: Storable a => IO (ForeignPtr a)
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)
module GHC.IO.Buffer
data Buffer e
Buffer :: !RawBuffer e -> BufferState -> !Int -> !Int -> !Int -> Buffer e
[bufRaw] :: Buffer e -> !RawBuffer e
[bufState] :: Buffer e -> BufferState
[bufSize] :: Buffer e -> !Int
[bufL] :: Buffer e -> !Int
[bufR] :: Buffer e -> !Int
data BufferState
ReadBuffer :: BufferState
WriteBuffer :: BufferState
type CharBuffer = Buffer Char
type CharBufElem = Char
newByteBuffer :: Int -> BufferState -> IO (Buffer Word8)
newCharBuffer :: Int -> BufferState -> IO CharBuffer
newBuffer :: Int -> Int -> BufferState -> IO (Buffer e)
emptyBuffer :: RawBuffer e -> Int -> BufferState -> Buffer e
bufferRemove :: Int -> Buffer e -> Buffer e
bufferAdd :: Int -> Buffer e -> Buffer e
slideContents :: Buffer Word8 -> IO (Buffer Word8)
bufferAdjustL :: Int -> Buffer e -> Buffer e
isEmptyBuffer :: Buffer e -> Bool
isFullBuffer :: Buffer e -> Bool
isFullCharBuffer :: Buffer e -> Bool
isWriteBuffer :: Buffer e -> Bool
bufferElems :: Buffer e -> Int
bufferAvailable :: Buffer e -> Int
summaryBuffer :: Buffer a -> String
withBuffer :: Buffer e -> (Ptr e -> IO a) -> IO a
withRawBuffer :: RawBuffer e -> (Ptr e -> IO a) -> IO a
checkBuffer :: Buffer a -> IO ()
type RawBuffer e = ForeignPtr e
readWord8Buf :: RawBuffer Word8 -> Int -> IO Word8
writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
type RawCharBuffer = RawBuffer CharBufElem
peekCharBuf :: RawCharBuffer -> Int -> IO Char
readCharBuf :: RawCharBuffer -> Int -> IO (Char, Int)
writeCharBuf :: RawCharBuffer -> Int -> Char -> IO Int
readCharBufPtr :: Ptr CharBufElem -> Int -> IO (Char, Int)
writeCharBufPtr :: Ptr CharBufElem -> Int -> Char -> IO Int
charSize :: Int
instance GHC.Classes.Eq GHC.IO.Buffer.BufferState
module GHC.IO.Encoding.Types
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state
[encode] :: BufferCodec from to state -> CodeBuffer from to
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)
[close] :: BufferCodec from to state -> IO ()
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding
[textEncodingName] :: TextEncoding -> String
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state
type CodeBuffer from to = Buffer from -> Buffer to -> IO (CodingProgress, Buffer from, Buffer to)
type EncodeBuffer = CodeBuffer Char Word8
type DecodeBuffer = CodeBuffer Word8 Char
data CodingProgress
InputUnderflow :: CodingProgress
OutputUnderflow :: CodingProgress
InvalidSequence :: CodingProgress
instance GHC.Show.Show GHC.IO.Encoding.Types.CodingProgress
instance GHC.Classes.Eq GHC.IO.Encoding.Types.CodingProgress
instance GHC.Show.Show GHC.IO.Encoding.Types.TextEncoding
module Data.IORef
data IORef a
newIORef :: a -> IO (IORef a)
readIORef :: IORef a -> IO a
writeIORef :: IORef a -> a -> IO ()
modifyIORef :: IORef a -> (a -> a) -> IO ()
modifyIORef' :: IORef a -> (a -> a) -> IO ()
atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> IO b
atomicWriteIORef :: IORef a -> a -> IO ()
mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))
module GHC.IO.Device
class RawIO a
read :: RawIO a => a -> Ptr Word8 -> Int -> IO Int
readNonBlocking :: RawIO a => a -> Ptr Word8 -> Int -> IO (Maybe Int)
write :: RawIO a => a -> Ptr Word8 -> Int -> IO ()
writeNonBlocking :: RawIO a => a -> Ptr Word8 -> Int -> IO Int
class IODevice a
ready :: IODevice a => a -> Bool -> Int -> IO Bool
close :: IODevice a => a -> IO ()
isTerminal :: IODevice a => a -> IO Bool
isSeekable :: IODevice a => a -> IO Bool
seek :: IODevice a => a -> SeekMode -> Integer -> IO ()
tell :: IODevice a => a -> IO Integer
getSize :: IODevice a => a -> IO Integer
setSize :: IODevice a => a -> Integer -> IO ()
setEcho :: IODevice a => a -> Bool -> IO ()
getEcho :: IODevice a => a -> IO Bool
setRaw :: IODevice a => a -> Bool -> IO ()
devType :: IODevice a => a -> IO IODeviceType
dup :: IODevice a => a -> IO a
dup2 :: IODevice a => a -> a -> IO a
data IODeviceType
Directory :: IODeviceType
Stream :: IODeviceType
RegularFile :: IODeviceType
RawDevice :: IODeviceType
data SeekMode
AbsoluteSeek :: SeekMode
RelativeSeek :: SeekMode
SeekFromEnd :: SeekMode
instance GHC.Show.Show GHC.IO.Device.SeekMode
instance GHC.Read.Read GHC.IO.Device.SeekMode
instance GHC.Enum.Enum GHC.IO.Device.SeekMode
instance GHC.Arr.Ix GHC.IO.Device.SeekMode
instance GHC.Classes.Ord GHC.IO.Device.SeekMode
instance GHC.Classes.Eq GHC.IO.Device.SeekMode
instance GHC.Classes.Eq GHC.IO.Device.IODeviceType
module GHC.IO.BufferedIO
class BufferedIO dev
newBuffer :: BufferedIO dev => dev -> BufferState -> IO (Buffer Word8)
fillReadBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
fillReadBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)
emptyWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
flushWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
flushWriteBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)
writeBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
writeBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
module GHC.IO.Encoding.Failure
data CodingFailureMode
ErrorOnCodingFailure :: CodingFailureMode
IgnoreCodingFailure :: CodingFailureMode
TransliterateCodingFailure :: CodingFailureMode
RoundtripFailure :: CodingFailureMode
codingFailureModeSuffix :: CodingFailureMode -> String
isSurrogate :: Char -> Bool
recoverDecode :: CodingFailureMode -> Buffer Word8 -> Buffer Char -> IO (Buffer Word8, Buffer Char)
recoverEncode :: CodingFailureMode -> Buffer Char -> Buffer Word8 -> IO (Buffer Char, Buffer Word8)
instance GHC.Show.Show GHC.IO.Encoding.Failure.CodingFailureMode
module GHC.IO.Encoding.UTF8
utf8 :: TextEncoding
mkUTF8 :: CodingFailureMode -> TextEncoding
utf8_bom :: TextEncoding
mkUTF8_bom :: CodingFailureMode -> TextEncoding
module GHC.IO.Encoding.UTF32
utf32 :: TextEncoding
mkUTF32 :: CodingFailureMode -> TextEncoding
utf32_decode :: IORef (Maybe DecodeBuffer) -> DecodeBuffer
utf32_encode :: IORef Bool -> EncodeBuffer
utf32be :: TextEncoding
mkUTF32be :: CodingFailureMode -> TextEncoding
utf32be_decode :: DecodeBuffer
utf32be_encode :: EncodeBuffer
utf32le :: TextEncoding
mkUTF32le :: CodingFailureMode -> TextEncoding
utf32le_decode :: DecodeBuffer
utf32le_encode :: EncodeBuffer
module GHC.IO.Encoding.UTF16
utf16 :: TextEncoding
mkUTF16 :: CodingFailureMode -> TextEncoding
utf16_decode :: IORef (Maybe DecodeBuffer) -> DecodeBuffer
utf16_encode :: IORef Bool -> EncodeBuffer
utf16be :: TextEncoding
mkUTF16be :: CodingFailureMode -> TextEncoding
utf16be_decode :: DecodeBuffer
utf16be_encode :: EncodeBuffer
utf16le :: TextEncoding
mkUTF16le :: CodingFailureMode -> TextEncoding
utf16le_decode :: DecodeBuffer
utf16le_encode :: EncodeBuffer
module GHC.IO.Encoding.Latin1
latin1 :: TextEncoding
mkLatin1 :: CodingFailureMode -> TextEncoding
latin1_checked :: TextEncoding
mkLatin1_checked :: CodingFailureMode -> TextEncoding
ascii :: TextEncoding
mkAscii :: CodingFailureMode -> TextEncoding
latin1_decode :: DecodeBuffer
ascii_decode :: DecodeBuffer
latin1_encode :: EncodeBuffer
latin1_checked_encode :: EncodeBuffer
ascii_encode :: EncodeBuffer
module Foreign.Marshal.Error
throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a
throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
void :: IO a -> IO ()
module Foreign.Marshal.Alloc
alloca :: forall a b. Storable a => (Ptr a -> IO b) -> IO b
allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
allocaBytesAligned :: Int -> Int -> (Ptr a -> IO b) -> IO b
malloc :: forall a. Storable a => IO (Ptr a)
mallocBytes :: Int -> IO (Ptr a)
calloc :: forall a. Storable a => IO (Ptr a)
callocBytes :: Int -> IO (Ptr a)
realloc :: forall a b. Storable b => Ptr a -> IO (Ptr b)
reallocBytes :: Ptr a -> Int -> IO (Ptr a)
free :: Ptr a -> IO ()
finalizerFree :: FinalizerPtr a
module Foreign.Marshal.Utils
with :: Storable a => a -> (Ptr a -> IO b) -> IO b
new :: Storable a => a -> IO (Ptr a)
fromBool :: Num a => Bool -> a
toBool :: (Eq a, Num a) => a -> Bool
maybeNew :: (a -> IO (Ptr b)) -> Maybe a -> IO (Ptr b)
maybeWith :: (a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c
maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
copyBytes :: Ptr a -> Ptr a -> Int -> IO ()
moveBytes :: Ptr a -> Ptr a -> Int -> IO ()
fillBytes :: Ptr a -> Word8 -> Int -> IO ()
module Foreign.Marshal.Array
mallocArray :: Storable a => Int -> IO (Ptr a)
mallocArray0 :: Storable a => Int -> IO (Ptr a)
allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)
reallocArray0 :: Storable a => Ptr a -> Int -> IO (Ptr a)
callocArray :: Storable a => Int -> IO (Ptr a)
callocArray0 :: Storable a => Int -> IO (Ptr a)
peekArray :: Storable a => Int -> Ptr a -> IO [a]
peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
pokeArray :: Storable a => Ptr a -> [a] -> IO ()
pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
newArray :: Storable a => [a] -> IO (Ptr a)
newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b
copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
advancePtr :: Storable a => Ptr a -> Int -> Ptr a
module GHC.Foreign
peekCString :: TextEncoding -> CString -> IO String
peekCStringLen :: TextEncoding -> CStringLen -> IO String
newCString :: TextEncoding -> String -> IO CString
newCStringLen :: TextEncoding -> String -> IO CStringLen
withCString :: TextEncoding -> String -> (CString -> IO a) -> IO a
withCStringLen :: TextEncoding -> String -> (CStringLen -> IO a) -> IO a
withCStringsLen :: TextEncoding -> [String] -> (Int -> Ptr CString -> IO a) -> IO a
charIsRepresentable :: TextEncoding -> Char -> IO Bool
module Foreign.C.String
type CString = Ptr CChar
type CStringLen = (Ptr CChar, Int)
peekCString :: CString -> IO String
peekCStringLen :: CStringLen -> IO String
newCString :: String -> IO CString
newCStringLen :: String -> IO CStringLen
withCString :: String -> (CString -> IO a) -> IO a
withCStringLen :: String -> (CStringLen -> IO a) -> IO a
charIsRepresentable :: Char -> IO Bool
castCharToCChar :: Char -> CChar
castCCharToChar :: CChar -> Char
castCharToCUChar :: Char -> CUChar
castCUCharToChar :: CUChar -> Char
castCharToCSChar :: Char -> CSChar
castCSCharToChar :: CSChar -> Char
peekCAString :: CString -> IO String
peekCAStringLen :: CStringLen -> IO String
newCAString :: String -> IO CString
newCAStringLen :: String -> IO CStringLen
withCAString :: String -> (CString -> IO a) -> IO a
withCAStringLen :: String -> (CStringLen -> IO a) -> IO a
type CWString = Ptr CWchar
type CWStringLen = (Ptr CWchar, Int)
peekCWString :: CWString -> IO String
peekCWStringLen :: CWStringLen -> IO String
newCWString :: String -> IO CWString
newCWStringLen :: String -> IO CWStringLen
withCWString :: String -> (CWString -> IO a) -> IO a
withCWStringLen :: String -> (CWStringLen -> IO a) -> IO a
module Foreign.Marshal.Unsafe
unsafeLocalState :: IO a -> a
module Foreign.Concurrent
newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
module Foreign.C.Error
newtype Errno
Errno :: CInt -> Errno
eOK :: Errno
e2BIG :: Errno
eACCES :: Errno
eADDRINUSE :: Errno
eADDRNOTAVAIL :: Errno
eADV :: Errno
eAFNOSUPPORT :: Errno
eAGAIN :: Errno
eALREADY :: Errno
eBADF :: Errno
eBADMSG :: Errno
eBADRPC :: Errno
eBUSY :: Errno
eCHILD :: Errno
eCOMM :: Errno
eCONNABORTED :: Errno
eCONNREFUSED :: Errno
eCONNRESET :: Errno
eDEADLK :: Errno
eDESTADDRREQ :: Errno
eDIRTY :: Errno
eDOM :: Errno
eDQUOT :: Errno
eEXIST :: Errno
eFAULT :: Errno
eFBIG :: Errno
eFTYPE :: Errno
eHOSTDOWN :: Errno
eHOSTUNREACH :: Errno
eIDRM :: Errno
eILSEQ :: Errno
eINPROGRESS :: Errno
eINTR :: Errno
eINVAL :: Errno
eIO :: Errno
eISCONN :: Errno
eISDIR :: Errno
eLOOP :: Errno
eMFILE :: Errno
eMLINK :: Errno
eMSGSIZE :: Errno
eMULTIHOP :: Errno
eNAMETOOLONG :: Errno
eNETDOWN :: Errno
eNETRESET :: Errno
eNETUNREACH :: Errno
eNFILE :: Errno
eNOBUFS :: Errno
eNODATA :: Errno
eNODEV :: Errno
eNOENT :: Errno
eNOEXEC :: Errno
eNOLCK :: Errno
eNOLINK :: Errno
eNOMEM :: Errno
eNOMSG :: Errno
eNONET :: Errno
eNOPROTOOPT :: Errno
eNOSPC :: Errno
eNOSR :: Errno
eNOSTR :: Errno
eNOSYS :: Errno
eNOTBLK :: Errno
eNOTCONN :: Errno
eNOTDIR :: Errno
eNOTEMPTY :: Errno
eNOTSOCK :: Errno
eNOTSUP :: Errno
eNOTTY :: Errno
eNXIO :: Errno
eOPNOTSUPP :: Errno
ePERM :: Errno
ePFNOSUPPORT :: Errno
ePIPE :: Errno
ePROCLIM :: Errno
ePROCUNAVAIL :: Errno
ePROGMISMATCH :: Errno
ePROGUNAVAIL :: Errno
ePROTO :: Errno
ePROTONOSUPPORT :: Errno
ePROTOTYPE :: Errno
eRANGE :: Errno
eREMCHG :: Errno
eREMOTE :: Errno
eROFS :: Errno
eRPCMISMATCH :: Errno
eRREMOTE :: Errno
eSHUTDOWN :: Errno
eSOCKTNOSUPPORT :: Errno
eSPIPE :: Errno
eSRCH :: Errno
eSRMNT :: Errno
eSTALE :: Errno
eTIME :: Errno
eTIMEDOUT :: Errno
eTOOMANYREFS :: Errno
eTXTBSY :: Errno
eUSERS :: Errno
eWOULDBLOCK :: Errno
eXDEV :: Errno
isValidErrno :: Errno -> Bool
getErrno :: IO Errno
resetErrno :: IO ()
errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError
throwErrno :: String -> IO a
throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a
throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
throwErrnoIfMinus1 :: (Eq a, Num a) => String -> IO a -> IO a
throwErrnoIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()
throwErrnoIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a
throwErrnoIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()
throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)
throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a
throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
throwErrnoIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO a -> IO b -> IO a
throwErrnoIfMinus1RetryMayBlock_ :: (Eq a, Num a) => String -> IO a -> IO b -> IO ()
throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)
throwErrnoPath :: String -> FilePath -> IO a
throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
throwErrnoPathIf_ :: (a -> Bool) -> String -> FilePath -> IO a -> IO ()
throwErrnoPathIfNull :: String -> FilePath -> IO (Ptr a) -> IO (Ptr a)
throwErrnoPathIfMinus1 :: (Eq a, Num a) => String -> FilePath -> IO a -> IO a
throwErrnoPathIfMinus1_ :: (Eq a, Num a) => String -> FilePath -> IO a -> IO ()
instance GHC.Classes.Eq Foreign.C.Error.Errno
module Foreign.C
module Foreign.Marshal.Pool
data Pool
newPool :: IO Pool
freePool :: Pool -> IO ()
withPool :: (Pool -> IO b) -> IO b
pooledMalloc :: Storable a => Pool -> IO (Ptr a)
pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
pooledRealloc :: Storable a => Pool -> Ptr a -> IO (Ptr a)
pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)
pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)
pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)
pooledNew :: Storable a => Pool -> a -> IO (Ptr a)
pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)
pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)
module Foreign.Marshal.Safe
module Foreign.Marshal
module Foreign.Safe
module Foreign
module System.Posix.Types
newtype CDev
CDev :: Word64 -> CDev
newtype CIno
CIno :: Word64 -> CIno
newtype {-# CTYPE "mode_t" #-} CMode
CMode :: Word32 -> CMode
newtype COff
COff :: Int64 -> COff
newtype CPid
CPid :: Int32 -> CPid
newtype CSsize
CSsize :: Int64 -> CSsize
newtype CGid
CGid :: Word32 -> CGid
newtype CNlink
CNlink :: Word64 -> CNlink
newtype CUid
CUid :: Word32 -> CUid
newtype CCc
CCc :: Word8 -> CCc
newtype CSpeed
CSpeed :: Word32 -> CSpeed
newtype CTcflag
CTcflag :: Word32 -> CTcflag
newtype CRLim
CRLim :: Word64 -> CRLim
newtype {-# CTYPE "blksize_t" #-} CBlkSize
CBlkSize :: Int64 -> CBlkSize
newtype {-# CTYPE "blkcnt_t" #-} CBlkCnt
CBlkCnt :: Int64 -> CBlkCnt
newtype {-# CTYPE "clockid_t" #-} CClockId
CClockId :: Int32 -> CClockId
newtype {-# CTYPE "fsblkcnt_t" #-} CFsBlkCnt
CFsBlkCnt :: Word64 -> CFsBlkCnt
newtype {-# CTYPE "fsfilcnt_t" #-} CFsFilCnt
CFsFilCnt :: Word64 -> CFsFilCnt
newtype {-# CTYPE "id_t" #-} CId
CId :: Word32 -> CId
newtype {-# CTYPE "key_t" #-} CKey
CKey :: Int32 -> CKey
newtype {-# CTYPE "timer_t" #-} CTimer
CTimer :: Ptr () -> CTimer
newtype Fd
Fd :: CInt -> Fd
type LinkCount = CNlink
type UserID = CUid
type GroupID = CGid
type ByteCount = CSize
type ClockTick = CClock
type EpochTime = CTime
type FileOffset = COff
type ProcessID = CPid
type ProcessGroupID = CPid
type DeviceID = CDev
type FileID = CIno
type FileMode = CMode
type Limit = CLong
instance GHC.Show.Show System.Posix.Types.Fd
instance GHC.Read.Read System.Posix.Types.Fd
instance Data.Bits.FiniteBits System.Posix.Types.Fd
instance Data.Bits.Bits System.Posix.Types.Fd
instance GHC.Real.Integral System.Posix.Types.Fd
instance GHC.Enum.Bounded System.Posix.Types.Fd
instance GHC.Real.Real System.Posix.Types.Fd
instance Foreign.Storable.Storable System.Posix.Types.Fd
instance GHC.Enum.Enum System.Posix.Types.Fd
instance GHC.Num.Num System.Posix.Types.Fd
instance GHC.Classes.Ord System.Posix.Types.Fd
instance GHC.Classes.Eq System.Posix.Types.Fd
instance GHC.Show.Show System.Posix.Types.CTimer
instance Foreign.Storable.Storable System.Posix.Types.CTimer
instance GHC.Classes.Ord System.Posix.Types.CTimer
instance GHC.Classes.Eq System.Posix.Types.CTimer
instance GHC.Show.Show System.Posix.Types.CKey
instance GHC.Read.Read System.Posix.Types.CKey
instance Data.Bits.FiniteBits System.Posix.Types.CKey
instance Data.Bits.Bits System.Posix.Types.CKey
instance GHC.Real.Integral System.Posix.Types.CKey
instance GHC.Enum.Bounded System.Posix.Types.CKey
instance GHC.Real.Real System.Posix.Types.CKey
instance Foreign.Storable.Storable System.Posix.Types.CKey
instance GHC.Enum.Enum System.Posix.Types.CKey
instance GHC.Num.Num System.Posix.Types.CKey
instance GHC.Classes.Ord System.Posix.Types.CKey
instance GHC.Classes.Eq System.Posix.Types.CKey
instance GHC.Show.Show System.Posix.Types.CId
instance GHC.Read.Read System.Posix.Types.CId
instance Data.Bits.FiniteBits System.Posix.Types.CId
instance Data.Bits.Bits System.Posix.Types.CId
instance GHC.Real.Integral System.Posix.Types.CId
instance GHC.Enum.Bounded System.Posix.Types.CId
instance GHC.Real.Real System.Posix.Types.CId
instance Foreign.Storable.Storable System.Posix.Types.CId
instance GHC.Enum.Enum System.Posix.Types.CId
instance GHC.Num.Num System.Posix.Types.CId
instance GHC.Classes.Ord System.Posix.Types.CId
instance GHC.Classes.Eq System.Posix.Types.CId
instance GHC.Show.Show System.Posix.Types.CFsFilCnt
instance GHC.Read.Read System.Posix.Types.CFsFilCnt
instance Data.Bits.FiniteBits System.Posix.Types.CFsFilCnt
instance Data.Bits.Bits System.Posix.Types.CFsFilCnt
instance GHC.Real.Integral System.Posix.Types.CFsFilCnt
instance GHC.Enum.Bounded System.Posix.Types.CFsFilCnt
instance GHC.Real.Real System.Posix.Types.CFsFilCnt
instance Foreign.Storable.Storable System.Posix.Types.CFsFilCnt
instance GHC.Enum.Enum System.Posix.Types.CFsFilCnt
instance GHC.Num.Num System.Posix.Types.CFsFilCnt
instance GHC.Classes.Ord System.Posix.Types.CFsFilCnt
instance GHC.Classes.Eq System.Posix.Types.CFsFilCnt
instance GHC.Show.Show System.Posix.Types.CFsBlkCnt
instance GHC.Read.Read System.Posix.Types.CFsBlkCnt
instance Data.Bits.FiniteBits System.Posix.Types.CFsBlkCnt
instance Data.Bits.Bits System.Posix.Types.CFsBlkCnt
instance GHC.Real.Integral System.Posix.Types.CFsBlkCnt
instance GHC.Enum.Bounded System.Posix.Types.CFsBlkCnt
instance GHC.Real.Real System.Posix.Types.CFsBlkCnt
instance Foreign.Storable.Storable System.Posix.Types.CFsBlkCnt
instance GHC.Enum.Enum System.Posix.Types.CFsBlkCnt
instance GHC.Num.Num System.Posix.Types.CFsBlkCnt
instance GHC.Classes.Ord System.Posix.Types.CFsBlkCnt
instance GHC.Classes.Eq System.Posix.Types.CFsBlkCnt
instance GHC.Show.Show System.Posix.Types.CClockId
instance GHC.Read.Read System.Posix.Types.CClockId
instance Data.Bits.FiniteBits System.Posix.Types.CClockId
instance Data.Bits.Bits System.Posix.Types.CClockId
instance GHC.Real.Integral System.Posix.Types.CClockId
instance GHC.Enum.Bounded System.Posix.Types.CClockId
instance GHC.Real.Real System.Posix.Types.CClockId
instance Foreign.Storable.Storable System.Posix.Types.CClockId
instance GHC.Enum.Enum System.Posix.Types.CClockId
instance GHC.Num.Num System.Posix.Types.CClockId
instance GHC.Classes.Ord System.Posix.Types.CClockId
instance GHC.Classes.Eq System.Posix.Types.CClockId
instance GHC.Show.Show System.Posix.Types.CBlkCnt
instance GHC.Read.Read System.Posix.Types.CBlkCnt
instance Data.Bits.FiniteBits System.Posix.Types.CBlkCnt
instance Data.Bits.Bits System.Posix.Types.CBlkCnt
instance GHC.Real.Integral System.Posix.Types.CBlkCnt
instance GHC.Enum.Bounded System.Posix.Types.CBlkCnt
instance GHC.Real.Real System.Posix.Types.CBlkCnt
instance Foreign.Storable.Storable System.Posix.Types.CBlkCnt
instance GHC.Enum.Enum System.Posix.Types.CBlkCnt
instance GHC.Num.Num System.Posix.Types.CBlkCnt
instance GHC.Classes.Ord System.Posix.Types.CBlkCnt
instance GHC.Classes.Eq System.Posix.Types.CBlkCnt
instance GHC.Show.Show System.Posix.Types.CBlkSize
instance GHC.Read.Read System.Posix.Types.CBlkSize
instance Data.Bits.FiniteBits System.Posix.Types.CBlkSize
instance Data.Bits.Bits System.Posix.Types.CBlkSize
instance GHC.Real.Integral System.Posix.Types.CBlkSize
instance GHC.Enum.Bounded System.Posix.Types.CBlkSize
instance GHC.Real.Real System.Posix.Types.CBlkSize
instance Foreign.Storable.Storable System.Posix.Types.CBlkSize
instance GHC.Enum.Enum System.Posix.Types.CBlkSize
instance GHC.Num.Num System.Posix.Types.CBlkSize
instance GHC.Classes.Ord System.Posix.Types.CBlkSize
instance GHC.Classes.Eq System.Posix.Types.CBlkSize
instance GHC.Show.Show System.Posix.Types.CRLim
instance GHC.Read.Read System.Posix.Types.CRLim
instance Data.Bits.FiniteBits System.Posix.Types.CRLim
instance Data.Bits.Bits System.Posix.Types.CRLim
instance GHC.Real.Integral System.Posix.Types.CRLim
instance GHC.Enum.Bounded System.Posix.Types.CRLim
instance GHC.Real.Real System.Posix.Types.CRLim
instance Foreign.Storable.Storable System.Posix.Types.CRLim
instance GHC.Enum.Enum System.Posix.Types.CRLim
instance GHC.Num.Num System.Posix.Types.CRLim
instance GHC.Classes.Ord System.Posix.Types.CRLim
instance GHC.Classes.Eq System.Posix.Types.CRLim
instance GHC.Show.Show System.Posix.Types.CTcflag
instance GHC.Read.Read System.Posix.Types.CTcflag
instance Data.Bits.FiniteBits System.Posix.Types.CTcflag
instance Data.Bits.Bits System.Posix.Types.CTcflag
instance GHC.Real.Integral System.Posix.Types.CTcflag
instance GHC.Enum.Bounded System.Posix.Types.CTcflag
instance GHC.Real.Real System.Posix.Types.CTcflag
instance Foreign.Storable.Storable System.Posix.Types.CTcflag
instance GHC.Enum.Enum System.Posix.Types.CTcflag
instance GHC.Num.Num System.Posix.Types.CTcflag
instance GHC.Classes.Ord System.Posix.Types.CTcflag
instance GHC.Classes.Eq System.Posix.Types.CTcflag
instance GHC.Show.Show System.Posix.Types.CSpeed
instance GHC.Read.Read System.Posix.Types.CSpeed
instance GHC.Real.Real System.Posix.Types.CSpeed
instance Foreign.Storable.Storable System.Posix.Types.CSpeed
instance GHC.Enum.Enum System.Posix.Types.CSpeed
instance GHC.Num.Num System.Posix.Types.CSpeed
instance GHC.Classes.Ord System.Posix.Types.CSpeed
instance GHC.Classes.Eq System.Posix.Types.CSpeed
instance GHC.Show.Show System.Posix.Types.CCc
instance GHC.Read.Read System.Posix.Types.CCc
instance GHC.Real.Real System.Posix.Types.CCc
instance Foreign.Storable.Storable System.Posix.Types.CCc
instance GHC.Enum.Enum System.Posix.Types.CCc
instance GHC.Num.Num System.Posix.Types.CCc
instance GHC.Classes.Ord System.Posix.Types.CCc
instance GHC.Classes.Eq System.Posix.Types.CCc
instance GHC.Show.Show System.Posix.Types.CUid
instance GHC.Read.Read System.Posix.Types.CUid
instance Data.Bits.FiniteBits System.Posix.Types.CUid
instance Data.Bits.Bits System.Posix.Types.CUid
instance GHC.Real.Integral System.Posix.Types.CUid
instance GHC.Enum.Bounded System.Posix.Types.CUid
instance GHC.Real.Real System.Posix.Types.CUid
instance Foreign.Storable.Storable System.Posix.Types.CUid
instance GHC.Enum.Enum System.Posix.Types.CUid
instance GHC.Num.Num System.Posix.Types.CUid
instance GHC.Classes.Ord System.Posix.Types.CUid
instance GHC.Classes.Eq System.Posix.Types.CUid
instance GHC.Show.Show System.Posix.Types.CNlink
instance GHC.Read.Read System.Posix.Types.CNlink
instance Data.Bits.FiniteBits System.Posix.Types.CNlink
instance Data.Bits.Bits System.Posix.Types.CNlink
instance GHC.Real.Integral System.Posix.Types.CNlink
instance GHC.Enum.Bounded System.Posix.Types.CNlink
instance GHC.Real.Real System.Posix.Types.CNlink
instance Foreign.Storable.Storable System.Posix.Types.CNlink
instance GHC.Enum.Enum System.Posix.Types.CNlink
instance GHC.Num.Num System.Posix.Types.CNlink
instance GHC.Classes.Ord System.Posix.Types.CNlink
instance GHC.Classes.Eq System.Posix.Types.CNlink
instance GHC.Show.Show System.Posix.Types.CGid
instance GHC.Read.Read System.Posix.Types.CGid
instance Data.Bits.FiniteBits System.Posix.Types.CGid
instance Data.Bits.Bits System.Posix.Types.CGid
instance GHC.Real.Integral System.Posix.Types.CGid
instance GHC.Enum.Bounded System.Posix.Types.CGid
instance GHC.Real.Real System.Posix.Types.CGid
instance Foreign.Storable.Storable System.Posix.Types.CGid
instance GHC.Enum.Enum System.Posix.Types.CGid
instance GHC.Num.Num System.Posix.Types.CGid
instance GHC.Classes.Ord System.Posix.Types.CGid
instance GHC.Classes.Eq System.Posix.Types.CGid
instance GHC.Show.Show System.Posix.Types.CSsize
instance GHC.Read.Read System.Posix.Types.CSsize
instance Data.Bits.FiniteBits System.Posix.Types.CSsize
instance Data.Bits.Bits System.Posix.Types.CSsize
instance GHC.Real.Integral System.Posix.Types.CSsize
instance GHC.Enum.Bounded System.Posix.Types.CSsize
instance GHC.Real.Real System.Posix.Types.CSsize
instance Foreign.Storable.Storable System.Posix.Types.CSsize
instance GHC.Enum.Enum System.Posix.Types.CSsize
instance GHC.Num.Num System.Posix.Types.CSsize
instance GHC.Classes.Ord System.Posix.Types.CSsize
instance GHC.Classes.Eq System.Posix.Types.CSsize
instance GHC.Show.Show System.Posix.Types.CPid
instance GHC.Read.Read System.Posix.Types.CPid
instance Data.Bits.FiniteBits System.Posix.Types.CPid
instance Data.Bits.Bits System.Posix.Types.CPid
instance GHC.Real.Integral System.Posix.Types.CPid
instance GHC.Enum.Bounded System.Posix.Types.CPid
instance GHC.Real.Real System.Posix.Types.CPid
instance Foreign.Storable.Storable System.Posix.Types.CPid
instance GHC.Enum.Enum System.Posix.Types.CPid
instance GHC.Num.Num System.Posix.Types.CPid
instance GHC.Classes.Ord System.Posix.Types.CPid
instance GHC.Classes.Eq System.Posix.Types.CPid
instance GHC.Show.Show System.Posix.Types.COff
instance GHC.Read.Read System.Posix.Types.COff
instance Data.Bits.FiniteBits System.Posix.Types.COff
instance Data.Bits.Bits System.Posix.Types.COff
instance GHC.Real.Integral System.Posix.Types.COff
instance GHC.Enum.Bounded System.Posix.Types.COff
instance GHC.Real.Real System.Posix.Types.COff
instance Foreign.Storable.Storable System.Posix.Types.COff
instance GHC.Enum.Enum System.Posix.Types.COff
instance GHC.Num.Num System.Posix.Types.COff
instance GHC.Classes.Ord System.Posix.Types.COff
instance GHC.Classes.Eq System.Posix.Types.COff
instance GHC.Show.Show System.Posix.Types.CMode
instance GHC.Read.Read System.Posix.Types.CMode
instance Data.Bits.FiniteBits System.Posix.Types.CMode
instance Data.Bits.Bits System.Posix.Types.CMode
instance GHC.Real.Integral System.Posix.Types.CMode
instance GHC.Enum.Bounded System.Posix.Types.CMode
instance GHC.Real.Real System.Posix.Types.CMode
instance Foreign.Storable.Storable System.Posix.Types.CMode
instance GHC.Enum.Enum System.Posix.Types.CMode
instance GHC.Num.Num System.Posix.Types.CMode
instance GHC.Classes.Ord System.Posix.Types.CMode
instance GHC.Classes.Eq System.Posix.Types.CMode
instance GHC.Show.Show System.Posix.Types.CIno
instance GHC.Read.Read System.Posix.Types.CIno
instance Data.Bits.FiniteBits System.Posix.Types.CIno
instance Data.Bits.Bits System.Posix.Types.CIno
instance GHC.Real.Integral System.Posix.Types.CIno
instance GHC.Enum.Bounded System.Posix.Types.CIno
instance GHC.Real.Real System.Posix.Types.CIno
instance Foreign.Storable.Storable System.Posix.Types.CIno
instance GHC.Enum.Enum System.Posix.Types.CIno
instance GHC.Num.Num System.Posix.Types.CIno
instance GHC.Classes.Ord System.Posix.Types.CIno
instance GHC.Classes.Eq System.Posix.Types.CIno
instance GHC.Show.Show System.Posix.Types.CDev
instance GHC.Read.Read System.Posix.Types.CDev
instance Data.Bits.FiniteBits System.Posix.Types.CDev
instance Data.Bits.Bits System.Posix.Types.CDev
instance GHC.Real.Integral System.Posix.Types.CDev
instance GHC.Enum.Bounded System.Posix.Types.CDev
instance GHC.Real.Real System.Posix.Types.CDev
instance Foreign.Storable.Storable System.Posix.Types.CDev
instance GHC.Enum.Enum System.Posix.Types.CDev
instance GHC.Num.Num System.Posix.Types.CDev
instance GHC.Classes.Ord System.Posix.Types.CDev
instance GHC.Classes.Eq System.Posix.Types.CDev
module Data.Dynamic
data Dynamic
[Dynamic] :: forall a. TypeRep a -> a -> Dynamic
toDyn :: Typeable a => a -> Dynamic
fromDyn :: Typeable a => Dynamic -> a -> a
fromDynamic :: forall a. Typeable a => Dynamic -> Maybe a
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
dynApp :: Dynamic -> Dynamic -> Dynamic
dynTypeRep :: Dynamic -> SomeTypeRep
class Typeable (a :: k)
instance GHC.Show.Show Data.Dynamic.Dynamic
instance GHC.Exception.Type.Exception Data.Dynamic.Dynamic
module GHC.Conc.Sync
data ThreadId
ThreadId :: ThreadId# -> ThreadId
forkIO :: IO () -> IO ThreadId
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId
forkOn :: Int -> IO () -> IO ThreadId
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId
numCapabilities :: Int
getNumCapabilities :: IO Int
setNumCapabilities :: Int -> IO ()
getNumProcessors :: IO Int
numSparks :: IO Int
childHandler :: SomeException -> IO ()
myThreadId :: IO ThreadId
killThread :: ThreadId -> IO ()
throwTo :: Exception e => ThreadId -> e -> IO ()
par :: a -> b -> b
infixr 0 `par`
pseq :: a -> b -> b
infixr 0 `pseq`
runSparks :: IO ()
yield :: IO ()
labelThread :: ThreadId -> String -> IO ()
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)
data ThreadStatus
ThreadRunning :: ThreadStatus
ThreadFinished :: ThreadStatus
ThreadBlocked :: BlockReason -> ThreadStatus
ThreadDied :: ThreadStatus
data BlockReason
BlockedOnMVar :: BlockReason
BlockedOnBlackHole :: BlockReason
BlockedOnException :: BlockReason
BlockedOnSTM :: BlockReason
BlockedOnForeignCall :: BlockReason
BlockedOnOther :: BlockReason
threadStatus :: ThreadId -> IO ThreadStatus
threadCapability :: ThreadId -> IO (Int, Bool)
newStablePtrPrimMVar :: MVar () -> IO (StablePtr PrimMVar)
data PrimMVar
setAllocationCounter :: Int64 -> IO ()
getAllocationCounter :: IO Int64
enableAllocationLimit :: IO ()
disableAllocationLimit :: IO ()
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a
atomically :: STM a -> IO a
retry :: STM a
orElse :: STM a -> STM a -> STM a
throwSTM :: Exception e => e -> STM a
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a
data TVar a
TVar :: TVar# RealWorld a -> TVar a
newTVar :: a -> STM (TVar a)
newTVarIO :: a -> IO (TVar a)
readTVar :: TVar a -> STM a
readTVarIO :: TVar a -> IO a
writeTVar :: TVar a -> a -> STM ()
unsafeIOToSTM :: IO a -> STM a
withMVar :: MVar a -> (a -> IO b) -> IO b
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()
reportHeapOverflow :: IO ()
sharedCAF :: a -> (Ptr a -> IO (Ptr a)) -> IO a
instance GHC.Show.Show GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadStatus
instance GHC.Show.Show GHC.Conc.Sync.BlockReason
instance GHC.Classes.Ord GHC.Conc.Sync.BlockReason
instance GHC.Classes.Eq GHC.Conc.Sync.BlockReason
instance GHC.Classes.Eq (GHC.Conc.Sync.TVar a)
instance GHC.Base.Functor GHC.Conc.Sync.STM
instance GHC.Base.Applicative GHC.Conc.Sync.STM
instance GHC.Base.Monad GHC.Conc.Sync.STM
instance GHC.Base.Alternative GHC.Conc.Sync.STM
instance GHC.Base.MonadPlus GHC.Conc.Sync.STM
instance GHC.Show.Show GHC.Conc.Sync.ThreadId
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadId
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadId
module Control.Exception.Base
data SomeException
SomeException :: e -> SomeException
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e
displayException :: Exception e => e -> String
data IOException
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException
RatioZeroDenominator :: ArithException
data ArrayException
IndexOutOfBounds :: String -> ArrayException
UndefinedElement :: String -> ArrayException
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException
data AsyncException
StackOverflow :: AsyncException
HeapOverflow :: AsyncException
ThreadKilled :: AsyncException
UserInterrupt :: AsyncException
asyncExceptionToException :: Exception e => e -> SomeException
asyncExceptionFromException :: Exception e => SomeException -> Maybe e
data NonTermination
NonTermination :: NonTermination
data NestedAtomically
NestedAtomically :: NestedAtomically
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar
data FixIOException
FixIOException :: FixIOException
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed
data Deadlock
Deadlock :: Deadlock
newtype NoMethodError
NoMethodError :: String -> NoMethodError
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail
newtype RecConError
RecConError :: String -> RecConError
newtype RecSelError
RecSelError :: String -> RecSelError
newtype RecUpdError
RecUpdError :: String -> RecUpdError
data ErrorCall
ErrorCallWithLocation :: String -> String -> ErrorCall
newtype TypeError
TypeError :: String -> TypeError
throwIO :: Exception e => e -> IO a
throw :: forall (r :: RuntimeRep). forall (a :: TYPE r). forall e. Exception e => e -> a
ioError :: IOError -> IO a
throwTo :: Exception e => ThreadId -> e -> IO ()
catch :: Exception e => IO a -> (e -> IO a) -> IO a
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
handle :: Exception e => (e -> IO a) -> IO a -> IO a
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
try :: Exception e => IO a -> IO (Either e a)
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
onException :: IO a -> IO b -> IO a
evaluate :: a -> IO a
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
mask_ :: IO a -> IO a
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
uninterruptibleMask_ :: IO a -> IO a
data MaskingState
Unmasked :: MaskingState
MaskedInterruptible :: MaskingState
MaskedUninterruptible :: MaskingState
getMaskingState :: IO MaskingState
assert :: Bool -> a -> a
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
bracket_ :: IO a -> IO b -> IO c -> IO c
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
finally :: IO a -> IO b -> IO a
recSelError :: Addr# -> a
recConError :: Addr# -> a
runtimeError :: Addr# -> a
nonExhaustiveGuardsError :: Addr# -> a
patError :: Addr# -> a
noMethodBindingError :: Addr# -> a
absentError :: Addr# -> a
absentSumFieldError :: a
typeError :: Addr# -> a
nonTermination :: SomeException
nestedAtomically :: SomeException
instance GHC.Show.Show Control.Exception.Base.NestedAtomically
instance GHC.Exception.Type.Exception Control.Exception.Base.NestedAtomically
instance GHC.Show.Show Control.Exception.Base.NonTermination
instance GHC.Exception.Type.Exception Control.Exception.Base.NonTermination
instance GHC.Show.Show Control.Exception.Base.TypeError
instance GHC.Exception.Type.Exception Control.Exception.Base.TypeError
instance GHC.Show.Show Control.Exception.Base.NoMethodError
instance GHC.Exception.Type.Exception Control.Exception.Base.NoMethodError
instance GHC.Show.Show Control.Exception.Base.RecUpdError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecUpdError
instance GHC.Show.Show Control.Exception.Base.RecConError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecConError
instance GHC.Show.Show Control.Exception.Base.RecSelError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecSelError
instance GHC.Show.Show Control.Exception.Base.PatternMatchFail
instance GHC.Exception.Type.Exception Control.Exception.Base.PatternMatchFail
module System.IO.Error
type IOError = IOException
userError :: String -> IOError
mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError
annotateIOError :: IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError
isAlreadyExistsError :: IOError -> Bool
isDoesNotExistError :: IOError -> Bool
isAlreadyInUseError :: IOError -> Bool
isFullError :: IOError -> Bool
isEOFError :: IOError -> Bool
isIllegalOperation :: IOError -> Bool
isPermissionError :: IOError -> Bool
isUserError :: IOError -> Bool
ioeGetErrorType :: IOError -> IOErrorType
ioeGetLocation :: IOError -> String
ioeGetErrorString :: IOError -> String
ioeGetHandle :: IOError -> Maybe Handle
ioeGetFileName :: IOError -> Maybe FilePath
ioeSetErrorType :: IOError -> IOErrorType -> IOError
ioeSetErrorString :: IOError -> String -> IOError
ioeSetLocation :: IOError -> String -> IOError
ioeSetHandle :: IOError -> Handle -> IOError
ioeSetFileName :: IOError -> FilePath -> IOError
data IOErrorType
alreadyExistsErrorType :: IOErrorType
doesNotExistErrorType :: IOErrorType
alreadyInUseErrorType :: IOErrorType
fullErrorType :: IOErrorType
eofErrorType :: IOErrorType
illegalOperationErrorType :: IOErrorType
permissionErrorType :: IOErrorType
userErrorType :: IOErrorType
isAlreadyExistsErrorType :: IOErrorType -> Bool
isDoesNotExistErrorType :: IOErrorType -> Bool
isAlreadyInUseErrorType :: IOErrorType -> Bool
isFullErrorType :: IOErrorType -> Bool
isEOFErrorType :: IOErrorType -> Bool
isIllegalOperationErrorType :: IOErrorType -> Bool
isPermissionErrorType :: IOErrorType -> Bool
isUserErrorType :: IOErrorType -> Bool
ioError :: IOError -> IO a
catchIOError :: IO a -> (IOError -> IO a) -> IO a
tryIOError :: IO a -> IO (Either IOError a)
modifyIOError :: (IOError -> IOError) -> IO a -> IO a
module Control.Exception
data SomeException
SomeException :: e -> SomeException
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e
displayException :: Exception e => e -> String
data IOException
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException
RatioZeroDenominator :: ArithException
data ArrayException
IndexOutOfBounds :: String -> ArrayException
UndefinedElement :: String -> ArrayException
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException
data AsyncException
StackOverflow :: AsyncException
HeapOverflow :: AsyncException
ThreadKilled :: AsyncException
UserInterrupt :: AsyncException
asyncExceptionToException :: Exception e => e -> SomeException
asyncExceptionFromException :: Exception e => SomeException -> Maybe e
data NonTermination
NonTermination :: NonTermination
data NestedAtomically
NestedAtomically :: NestedAtomically
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed
data Deadlock
Deadlock :: Deadlock
newtype NoMethodError
NoMethodError :: String -> NoMethodError
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail
newtype RecConError
RecConError :: String -> RecConError
newtype RecSelError
RecSelError :: String -> RecSelError
newtype RecUpdError
RecUpdError :: String -> RecUpdError
data ErrorCall
ErrorCallWithLocation :: String -> String -> ErrorCall
newtype TypeError
TypeError :: String -> TypeError
throw :: forall (r :: RuntimeRep). forall (a :: TYPE r). forall e. Exception e => e -> a
throwIO :: Exception e => e -> IO a
ioError :: IOError -> IO a
throwTo :: Exception e => ThreadId -> e -> IO ()
catch :: Exception e => IO a -> (e -> IO a) -> IO a
catches :: IO a -> [Handler a] -> IO a
data Handler a
Handler :: (e -> IO a) -> Handler a
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
handle :: Exception e => (e -> IO a) -> IO a -> IO a
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
try :: Exception e => IO a -> IO (Either e a)
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
evaluate :: a -> IO a
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
mask_ :: IO a -> IO a
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
uninterruptibleMask_ :: IO a -> IO a
data MaskingState
Unmasked :: MaskingState
MaskedInterruptible :: MaskingState
MaskedUninterruptible :: MaskingState
getMaskingState :: IO MaskingState
interruptible :: IO a -> IO a
allowInterrupt :: IO ()
assert :: Bool -> a -> a
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
bracket_ :: IO a -> IO b -> IO c -> IO c
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
finally :: IO a -> IO b -> IO a
onException :: IO a -> IO b -> IO a
instance GHC.Base.Functor Control.Exception.Handler
module System.IO.Unsafe
unsafePerformIO :: IO a -> a
unsafeDupablePerformIO :: IO a -> a
unsafeInterleaveIO :: IO a -> IO a
unsafeFixIO :: (a -> IO a) -> IO a
module GHC.IO.Encoding
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state
[encode] :: BufferCodec from to state -> CodeBuffer from to
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)
[close] :: BufferCodec from to state -> IO ()
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding
[textEncodingName] :: TextEncoding -> String
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state
data CodingProgress
InputUnderflow :: CodingProgress
OutputUnderflow :: CodingProgress
InvalidSequence :: CodingProgress
latin1 :: TextEncoding
latin1_encode :: CharBuffer -> Buffer Word8 -> IO (CharBuffer, Buffer Word8)
latin1_decode :: Buffer Word8 -> CharBuffer -> IO (Buffer Word8, CharBuffer)
utf8 :: TextEncoding
utf8_bom :: TextEncoding
utf16 :: TextEncoding
utf16le :: TextEncoding
utf16be :: TextEncoding
utf32 :: TextEncoding
utf32le :: TextEncoding
utf32be :: TextEncoding
initLocaleEncoding :: TextEncoding
getLocaleEncoding :: IO TextEncoding
getFileSystemEncoding :: IO TextEncoding
getForeignEncoding :: IO TextEncoding
setLocaleEncoding :: TextEncoding -> IO ()
setFileSystemEncoding :: TextEncoding -> IO ()
setForeignEncoding :: TextEncoding -> IO ()
char8 :: TextEncoding
mkTextEncoding :: String -> IO TextEncoding
argvEncoding :: IO TextEncoding
module GHC.Stack.CCS
currentCallStack :: IO [String]
whoCreated :: a -> IO [String]
data CostCentreStack
data CostCentre
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)
getCCSOf :: a -> IO (Ptr CostCentreStack)
clearCCS :: IO a -> IO a
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)
ccLabel :: Ptr CostCentre -> IO CString
ccModule :: Ptr CostCentre -> IO CString
ccSrcSpan :: Ptr CostCentre -> IO CString
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String
module GHC.Stack
errorWithStackTrace :: String -> a
currentCallStack :: IO [String]
whoCreated :: a -> IO [String]
data CallStack
type HasCallStack = (?callStack :: CallStack)
callStack :: HasCallStack => CallStack
emptyCallStack :: CallStack
freezeCallStack :: CallStack -> CallStack
fromCallSiteList :: [([Char], SrcLoc)] -> CallStack
getCallStack :: CallStack -> [([Char], SrcLoc)]
popCallStack :: CallStack -> CallStack
prettyCallStack :: CallStack -> String
pushCallStack :: ([Char], SrcLoc) -> CallStack -> CallStack
withFrozenCallStack :: HasCallStack => (HasCallStack => a) -> a
data SrcLoc
SrcLoc :: [Char] -> [Char] -> [Char] -> Int -> Int -> Int -> Int -> SrcLoc
[srcLocPackage] :: SrcLoc -> [Char]
[srcLocModule] :: SrcLoc -> [Char]
[srcLocFile] :: SrcLoc -> [Char]
[srcLocStartLine] :: SrcLoc -> Int
[srcLocStartCol] :: SrcLoc -> Int
[srcLocEndLine] :: SrcLoc -> Int
[srcLocEndCol] :: SrcLoc -> Int
prettySrcLoc :: SrcLoc -> String
data CostCentreStack
data CostCentre
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)
getCCSOf :: a -> IO (Ptr CostCentreStack)
clearCCS :: IO a -> IO a
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)
ccLabel :: Ptr CostCentre -> IO CString
ccModule :: Ptr CostCentre -> IO CString
ccSrcSpan :: Ptr CostCentre -> IO CString
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String
module GHC.Environment
getFullArgs :: IO [String]
module Control.Concurrent.MVar
data MVar a
newEmptyMVar :: IO (MVar a)
newMVar :: a -> IO (MVar a)
takeMVar :: MVar a -> IO a
putMVar :: MVar a -> a -> IO ()
readMVar :: MVar a -> IO a
swapMVar :: MVar a -> a -> IO a
tryTakeMVar :: MVar a -> IO (Maybe a)
tryPutMVar :: MVar a -> a -> IO Bool
isEmptyMVar :: MVar a -> IO Bool
withMVar :: MVar a -> (a -> IO b) -> IO b
withMVarMasked :: MVar a -> (a -> IO b) -> IO b
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
modifyMVarMasked_ :: MVar a -> (a -> IO a) -> IO ()
modifyMVarMasked :: MVar a -> (a -> IO (a, b)) -> IO b
tryReadMVar :: MVar a -> IO (Maybe a)
mkWeakMVar :: MVar a -> IO () -> IO (Weak (MVar a))
addMVarFinalizer :: MVar a -> IO () -> IO ()
module GHC.Conc.Signal
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
runHandlersPtr :: Ptr Word8 -> Signal -> IO ()
module GHC.Conc.IO
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()
threadDelay :: Int -> IO ()
registerDelay :: Int -> IO (TVar Bool)
threadWaitRead :: Fd -> IO ()
threadWaitWrite :: Fd -> IO ()
threadWaitReadSTM :: Fd -> IO (STM (), IO ())
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()
module GHC.IO.Handle.FD
stdin :: Handle
stdout :: Handle
stderr :: Handle
openFile :: FilePath -> IOMode -> IO Handle
openBinaryFile :: FilePath -> IOMode -> IO Handle
openFileBlocking :: FilePath -> IOMode -> IO Handle
mkHandleFromFD :: FD -> IODeviceType -> FilePath -> IOMode -> Bool -> Maybe TextEncoding -> IO Handle
fdToHandle :: FD -> IO Handle
fdToHandle' :: CInt -> Maybe IODeviceType -> Bool -> FilePath -> IOMode -> Bool -> IO Handle
handleToFd :: Handle -> IO FD
module GHC.IO.Handle.Lock
data FileLockingNotSupported
FileLockingNotSupported :: FileLockingNotSupported
data LockMode
SharedLock :: LockMode
ExclusiveLock :: LockMode
hLock :: Handle -> LockMode -> IO ()
hTryLock :: Handle -> LockMode -> IO Bool
hUnlock :: Handle -> IO ()
instance GHC.Show.Show GHC.IO.Handle.Lock.FileLockingNotSupported
instance GHC.Exception.Type.Exception GHC.IO.Handle.Lock.FileLockingNotSupported
module GHC.IO.Handle
data Handle
data BufferMode
NoBuffering :: BufferMode
LineBuffering :: BufferMode
BlockBuffering :: Maybe Int -> BufferMode
mkFileHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle
mkDuplexHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle
hFileSize :: Handle -> IO Integer
hSetFileSize :: Handle -> Integer -> IO ()
hIsEOF :: Handle -> IO Bool
isEOF :: IO Bool
hLookAhead :: Handle -> IO Char
hSetBuffering :: Handle -> BufferMode -> IO ()
hSetBinaryMode :: Handle -> Bool -> IO ()
hSetEncoding :: Handle -> TextEncoding -> IO ()
hGetEncoding :: Handle -> IO (Maybe TextEncoding)
hFlush :: Handle -> IO ()
hFlushAll :: Handle -> IO ()
hDuplicate :: Handle -> IO Handle
hDuplicateTo :: Handle -> Handle -> IO ()
hClose :: Handle -> IO ()
hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)
data LockMode
SharedLock :: LockMode
ExclusiveLock :: LockMode
hLock :: Handle -> LockMode -> IO ()
hTryLock :: Handle -> LockMode -> IO Bool
type HandlePosition = Integer
data HandlePosn
HandlePosn :: Handle -> HandlePosition -> HandlePosn
hGetPosn :: Handle -> IO HandlePosn
hSetPosn :: HandlePosn -> IO ()
data SeekMode
AbsoluteSeek :: SeekMode
RelativeSeek :: SeekMode
SeekFromEnd :: SeekMode
hSeek :: Handle -> SeekMode -> Integer -> IO ()
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hGetBuffering :: Handle -> IO BufferMode
hIsSeekable :: Handle -> IO Bool
hSetEcho :: Handle -> Bool -> IO ()
hGetEcho :: Handle -> IO Bool
hIsTerminalDevice :: Handle -> IO Bool
hSetNewlineMode :: Handle -> NewlineMode -> IO ()
data Newline
LF :: Newline
CRLF :: Newline
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode
[inputNL] :: NewlineMode -> Newline
[outputNL] :: NewlineMode -> Newline
nativeNewline :: Newline
noNewlineTranslation :: NewlineMode
universalNewlineMode :: NewlineMode
nativeNewlineMode :: NewlineMode
hShow :: Handle -> IO String
hWaitForInput :: Handle -> Int -> IO Bool
hGetChar :: Handle -> IO Char
hGetLine :: Handle -> IO String
hGetContents :: Handle -> IO String
hPutChar :: Handle -> Char -> IO ()
hPutStr :: Handle -> String -> IO ()
hGetBuf :: Handle -> Ptr a -> Int -> IO Int
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
instance GHC.Classes.Eq GHC.IO.Handle.HandlePosn
instance GHC.Show.Show GHC.IO.Handle.HandlePosn
module System.IO
data IO a
fixIO :: (a -> IO a) -> IO a
type FilePath = String
data Handle
stdin :: Handle
stdout :: Handle
stderr :: Handle
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
openFile :: FilePath -> IOMode -> IO Handle
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode
hClose :: Handle -> IO ()
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()
appendFile :: FilePath -> String -> IO ()
hFileSize :: Handle -> IO Integer
hSetFileSize :: Handle -> Integer -> IO ()
hIsEOF :: Handle -> IO Bool
isEOF :: IO Bool
data BufferMode
NoBuffering :: BufferMode
LineBuffering :: BufferMode
BlockBuffering :: Maybe Int -> BufferMode
hSetBuffering :: Handle -> BufferMode -> IO ()
hGetBuffering :: Handle -> IO BufferMode
hFlush :: Handle -> IO ()
hGetPosn :: Handle -> IO HandlePosn
hSetPosn :: HandlePosn -> IO ()
data HandlePosn
hSeek :: Handle -> SeekMode -> Integer -> IO ()
data SeekMode
AbsoluteSeek :: SeekMode
RelativeSeek :: SeekMode
SeekFromEnd :: SeekMode
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hIsSeekable :: Handle -> IO Bool
hIsTerminalDevice :: Handle -> IO Bool
hSetEcho :: Handle -> Bool -> IO ()
hGetEcho :: Handle -> IO Bool
hShow :: Handle -> IO String
hWaitForInput :: Handle -> Int -> IO Bool
hReady :: Handle -> IO Bool
hGetChar :: Handle -> IO Char
hGetLine :: Handle -> IO String
hLookAhead :: Handle -> IO Char
hGetContents :: Handle -> IO String
hPutChar :: Handle -> Char -> IO ()
hPutStr :: Handle -> String -> IO ()
hPutStrLn :: Handle -> String -> IO ()
hPrint :: Show a => Handle -> a -> IO ()
interact :: (String -> String) -> IO ()
putChar :: Char -> IO ()
putStr :: String -> IO ()
putStrLn :: String -> IO ()
print :: Show a => a -> IO ()
getChar :: IO Char
getLine :: IO String
getContents :: IO String
readIO :: Read a => String -> IO a
readLn :: Read a => IO a
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
openBinaryFile :: FilePath -> IOMode -> IO Handle
hSetBinaryMode :: Handle -> Bool -> IO ()
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hGetBuf :: Handle -> Ptr a -> Int -> IO Int
hGetBufSome :: Handle -> Ptr a -> Int -> IO Int
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
openTempFile :: FilePath -> String -> IO (FilePath, Handle)
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
hSetEncoding :: Handle -> TextEncoding -> IO ()
hGetEncoding :: Handle -> IO (Maybe TextEncoding)
data TextEncoding
latin1 :: TextEncoding
utf8 :: TextEncoding
utf8_bom :: TextEncoding
utf16 :: TextEncoding
utf16le :: TextEncoding
utf16be :: TextEncoding
utf32 :: TextEncoding
utf32le :: TextEncoding
utf32be :: TextEncoding
localeEncoding :: TextEncoding
char8 :: TextEncoding
mkTextEncoding :: String -> IO TextEncoding
hSetNewlineMode :: Handle -> NewlineMode -> IO ()
data Newline
LF :: Newline
CRLF :: Newline
nativeNewline :: Newline
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode
[inputNL] :: NewlineMode -> Newline
[outputNL] :: NewlineMode -> Newline
noNewlineTranslation :: NewlineMode
universalNewlineMode :: NewlineMode
nativeNewlineMode :: NewlineMode
module GHC.Fingerprint
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint
getFileHash :: FilePath -> IO Fingerprint
module Control.Monad.Fix
class (Monad m) => MonadFix m
mfix :: MonadFix m => (a -> m a) -> m a
fix :: (a -> a) -> a
instance Control.Monad.Fix.MonadFix GHC.Maybe.Maybe
instance Control.Monad.Fix.MonadFix []
instance Control.Monad.Fix.MonadFix GHC.Base.NonEmpty
instance Control.Monad.Fix.MonadFix GHC.Types.IO
instance Control.Monad.Fix.MonadFix ((->) r)
instance Control.Monad.Fix.MonadFix (Data.Either.Either e)
instance Control.Monad.Fix.MonadFix (GHC.ST.ST s)
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Dual
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Sum
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Product
instance Control.Monad.Fix.MonadFix Data.Monoid.First
instance Control.Monad.Fix.MonadFix Data.Monoid.Last
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (Data.Semigroup.Internal.Alt f)
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (Data.Monoid.Ap f)
instance Control.Monad.Fix.MonadFix GHC.Generics.Par1
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (GHC.Generics.Rec1 f)
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (GHC.Generics.M1 i c f)
instance (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) => Control.Monad.Fix.MonadFix (f GHC.Generics.:*: g)
instance Control.Monad.Fix.MonadFix Data.Ord.Down
module Data.Functor.Identity
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Identity.Identity a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Identity.Identity a)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
instance GHC.Real.Real a => GHC.Real.Real (Data.Functor.Identity.Identity a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Identity.Identity a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Identity.Identity a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Identity.Identity a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
instance GHC.Arr.Ix a => GHC.Arr.Ix (Data.Functor.Identity.Identity a)
instance GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Identity.Identity a)
instance GHC.Generics.Generic1 Data.Functor.Identity.Identity
instance GHC.Generics.Generic (Data.Functor.Identity.Identity a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Identity.Identity a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Identity.Identity a)
instance Data.Bits.FiniteBits a => Data.Bits.FiniteBits (Data.Functor.Identity.Identity a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Identity.Identity a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Identity.Identity a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Identity.Identity a)
instance Data.Bits.Bits a => Data.Bits.Bits (Data.Functor.Identity.Identity a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Functor.Identity.Identity a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Identity.Identity a)
instance Data.Foldable.Foldable Data.Functor.Identity.Identity
instance GHC.Base.Functor Data.Functor.Identity.Identity
instance GHC.Base.Applicative Data.Functor.Identity.Identity
instance GHC.Base.Monad Data.Functor.Identity.Identity
instance Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity
module Control.Arrow
class Category a => Arrow a
arr :: Arrow a => (b -> c) -> a b c
first :: Arrow a => a b c -> a (b, d) (c, d)
second :: Arrow a => a b c -> a (d, b) (d, c)
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 ***
infixr 3 &&&
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
[runKleisli] :: Kleisli m a b -> a -> m b
returnA :: Arrow a => a b b
(^>>) :: Arrow a => (b -> c) -> a c d -> a b d
infixr 1 ^>>
(>>^) :: Arrow a => a b c -> (c -> d) -> a b d
infixr 1 >>^
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<
(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
infixr 1 <<^
(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
infixr 1 ^<<
class Arrow a => ArrowZero a
zeroArrow :: ArrowZero a => a b c
class ArrowZero a => ArrowPlus a
(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
infixr 5 <+>
class Arrow a => ArrowChoice a
left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
(|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
infixr 2 |||
infixr 2 +++
class Arrow a => ArrowApply a
app :: ArrowApply a => a (a b c, b) c
newtype ArrowMonad a b
ArrowMonad :: a () b -> ArrowMonad a b
leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
class Arrow a => ArrowLoop a
loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
instance Control.Arrow.ArrowLoop (->)
instance Control.Monad.Fix.MonadFix m => Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m)
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Arrow.ArrowMonad a)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowApply a => GHC.Base.Monad (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowPlus a => GHC.Base.Alternative (Control.Arrow.ArrowMonad a)
instance (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) => GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowApply (->)
instance GHC.Base.Monad m => Control.Arrow.ArrowApply (Control.Arrow.Kleisli m)
instance Control.Arrow.ArrowChoice (->)
instance GHC.Base.Monad m => Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m)
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m)
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowZero (Control.Arrow.Kleisli m)
instance GHC.Base.Monad m => Control.Category.Category (Control.Arrow.Kleisli m)
instance GHC.Base.Monad m => Control.Arrow.Arrow (Control.Arrow.Kleisli m)
instance Control.Arrow.Arrow (->)
module Control.Applicative
class Functor f => Applicative f
pure :: Applicative f => a -> f a
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*
class Applicative f => Alternative f
empty :: Alternative f => f a
(<|>) :: Alternative f => f a -> f a -> f a
some :: Alternative f => f a -> f [a]
many :: Alternative f => f a -> f [a]
infixl 3 <|>
newtype Const a b
Const :: a -> Const a b
[getConst] :: Const a b -> a
newtype WrappedMonad m a
WrapMonad :: m a -> WrappedMonad m a
[unwrapMonad] :: WrappedMonad m a -> m a
newtype WrappedArrow a b c
WrapArrow :: a b c -> WrappedArrow a b c
[unwrapArrow] :: WrappedArrow a b c -> a b c
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>
liftA :: Applicative f => (a -> b) -> f a -> f b
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
optional :: Alternative f => f a -> f (Maybe a)
instance GHC.Generics.Generic1 Control.Applicative.ZipList
instance GHC.Generics.Generic (Control.Applicative.ZipList a)
instance Data.Foldable.Foldable Control.Applicative.ZipList
instance GHC.Base.Functor Control.Applicative.ZipList
instance GHC.Read.Read a => GHC.Read.Read (Control.Applicative.ZipList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Applicative.ZipList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Applicative.ZipList a)
instance GHC.Show.Show a => GHC.Show.Show (Control.Applicative.ZipList a)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
instance GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
instance GHC.Base.Applicative Control.Applicative.ZipList
instance GHC.Base.Alternative Control.Applicative.ZipList
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) => GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Applicative.WrappedMonad m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Control.Applicative.WrappedMonad m)
module Data.Traversable
class (Functor t, Foldable t) => Traversable t
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
fmapDefault :: forall t a b. Traversable t => (a -> b) -> t a -> t b
foldMapDefault :: forall t m a. (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance Data.Traversable.Traversable Data.Functor.Identity.Identity
instance Data.Traversable.Traversable GHC.Generics.V1
instance Data.Traversable.Traversable GHC.Generics.Par1
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (GHC.Generics.Rec1 f)
instance Data.Traversable.Traversable (GHC.Generics.K1 i c)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (GHC.Generics.M1 i c f)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:+: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:*: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:.: g)
instance Data.Traversable.Traversable (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Char)
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Double)
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Float)
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Int)
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Word)
instance Data.Traversable.Traversable Data.Ord.Down
instance Data.Traversable.Traversable GHC.Maybe.Maybe
instance Data.Traversable.Traversable []
instance Data.Traversable.Traversable GHC.Base.NonEmpty
instance Data.Traversable.Traversable (Data.Either.Either a)
instance Data.Traversable.Traversable ((,) a)
instance GHC.Arr.Ix i => Data.Traversable.Traversable (GHC.Arr.Array i)
instance Data.Traversable.Traversable Data.Proxy.Proxy
instance Data.Traversable.Traversable (Data.Functor.Const.Const m)
instance Data.Traversable.Traversable Data.Semigroup.Internal.Dual
instance Data.Traversable.Traversable Data.Semigroup.Internal.Sum
instance Data.Traversable.Traversable Data.Semigroup.Internal.Product
instance Data.Traversable.Traversable Data.Monoid.First
instance Data.Traversable.Traversable Data.Monoid.Last
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Semigroup.Internal.Alt f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Monoid.Ap f)
instance Data.Traversable.Traversable Control.Applicative.ZipList
instance Data.Traversable.Traversable GHC.Generics.U1
module Data.List
(++) :: [a] -> [a] -> [a]
infixr 5 ++
uncons :: [a] -> Maybe (a, [a])
null :: Foldable t => t a -> Bool
length :: Foldable t => t a -> Int
map :: (a -> b) -> [a] -> [b]
reverse :: [a] -> [a]
intersperse :: a -> [a] -> [a]
intercalate :: [a] -> [[a]] -> [a]
transpose :: [[a]] -> [[a]]
subsequences :: [a] -> [[a]]
permutations :: [a] -> [[a]]
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
concat :: Foldable t => t [a] -> [a]
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
and :: Foldable t => t Bool -> Bool
or :: Foldable t => t Bool -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
all :: Foldable t => (a -> Bool) -> t a -> Bool
sum :: (Foldable t, Num a) => t a -> a
product :: (Foldable t, Num a) => t a -> a
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl' :: (b -> a -> b) -> b -> [a] -> [b]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
iterate :: (a -> a) -> a -> [a]
iterate' :: (a -> a) -> a -> [a]
replicate :: Int -> a -> [a]
cycle :: [a] -> [a]
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhileEnd :: (a -> Bool) -> [a] -> [a]
span :: (a -> Bool) -> [a] -> ([a], [a])
break :: (a -> Bool) -> [a] -> ([a], [a])
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
group :: Eq a => [a] -> [[a]]
inits :: [a] -> [[a]]
tails :: [a] -> [[a]]
isPrefixOf :: Eq a => [a] -> [a] -> Bool
isSuffixOf :: Eq a => [a] -> [a] -> Bool
isInfixOf :: Eq a => [a] -> [a] -> Bool
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool
elem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `elem`
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`
lookup :: Eq a => a -> [(a, b)] -> Maybe b
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
filter :: (a -> Bool) -> [a] -> [a]
partition :: (a -> Bool) -> [a] -> ([a], [a])
elemIndex :: Eq a => a -> [a] -> Maybe Int
elemIndices :: Eq a => a -> [a] -> [Int]
findIndex :: (a -> Bool) -> [a] -> Maybe Int
findIndices :: (a -> Bool) -> [a] -> [Int]
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
lines :: String -> [String]
words :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
nub :: Eq a => [a] -> [a]
delete :: Eq a => a -> [a] -> [a]
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\
union :: Eq a => [a] -> [a] -> [a]
intersect :: Eq a => [a] -> [a] -> [a]
sort :: Ord a => [a] -> [a]
sortOn :: Ord b => (a -> b) -> [a] -> [a]
insert :: Ord a => a -> [a] -> [a]
nubBy :: (a -> a -> Bool) -> [a] -> [a]
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
sortBy :: (a -> a -> Ordering) -> [a] -> [a]
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])
genericIndex :: Integral i => [a] -> i -> a
genericReplicate :: Integral i => i -> a -> [a]
module Debug.Trace
trace :: String -> a -> a
traceId :: String -> String
traceShow :: Show a => a -> b -> b
traceShowId :: Show a => a -> a
traceStack :: String -> a -> a
traceIO :: String -> IO ()
traceM :: Applicative f => String -> f ()
traceShowM :: (Show a, Applicative f) => a -> f ()
putTraceMsg :: String -> IO ()
traceEvent :: String -> a -> a
traceEventIO :: String -> IO ()
traceMarker :: String -> a -> a
traceMarkerIO :: String -> IO ()
module Data.String
type String = [Char]
class IsString a
fromString :: IsString a => String -> a
lines :: String -> [String]
words :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
instance Data.String.IsString a => Data.String.IsString (Data.Functor.Const.Const a b)
instance Data.String.IsString a => Data.String.IsString (Data.Functor.Identity.Identity a)
instance (a Data.Type.Equality.~ GHC.Types.Char) => Data.String.IsString [a]
module Data.Version
data Version
Version :: [Int] -> [String] -> Version
[versionBranch] :: Version -> [Int]
[versionTags] :: Version -> [String]
showVersion :: Version -> String
parseVersion :: ReadP Version
makeVersion :: [Int] -> Version
instance GHC.Generics.Generic Data.Version.Version
instance GHC.Show.Show Data.Version.Version
instance GHC.Read.Read Data.Version.Version
instance GHC.Classes.Eq Data.Version.Version
instance GHC.Classes.Ord Data.Version.Version
module Control.Monad
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b
class Applicative m => Monad m
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b
(>>) :: forall a b. Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>
class (Alternative m, Monad m) => MonadPlus m
mzero :: MonadPlus m => m a
mplus :: MonadPlus m => m a -> m a -> m a
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<
forever :: Applicative f => f a -> f b
void :: Functor f => f a -> f ()
join :: Monad m => m (m a) -> m a
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()
replicateM :: Applicative m => Int -> m a -> m [a]
replicateM_ :: Applicative m => Int -> m a -> m ()
guard :: Alternative f => Bool -> f ()
when :: Applicative f => Bool -> f () -> f ()
unless :: Applicative f => Bool -> f () -> f ()
liftM :: Monad m => (a1 -> r) -> m a1 -> m r
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
-- liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
-- liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
-- liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
ap :: Monad m => m (a -> b) -> m a -> m b
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>
module Prelude
data Bool
False :: Bool
True :: Bool
(&&) :: Bool -> Bool -> Bool
infixr 3 &&
(||) :: Bool -> Bool -> Bool
infixr 2 ||
not :: Bool -> Bool
otherwise :: Bool
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
maybe :: b -> (a -> b) -> Maybe a -> b
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b
either :: (a -> c) -> (b -> c) -> Either a b -> c
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
data Char
type String = [Char]
fst :: (a, b) -> a
snd :: (a, b) -> b
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <
infix 4 <=
infix 4 >=
infix 4 >
class Enum a
succ :: Enum a => a -> a
pred :: Enum a => a -> a
toEnum :: Enum a => Int -> a
fromEnum :: Enum a => a -> Int
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a
data Int
data Integer
data Float
data Double
type Rational = Ratio Integer
data Word
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a
negate :: Num a => a -> a
abs :: Num a => a -> a
signum :: Num a => a -> a
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 6 -
infixl 7 *
class (Num a, Ord a) => Real a
toRational :: Real a => a -> Rational
class (Real a, Enum a) => Integral a
quot :: Integral a => a -> a -> a
rem :: Integral a => a -> a -> a
div :: Integral a => a -> a -> a
mod :: Integral a => a -> a -> a
quotRem :: Integral a => a -> a -> (a, a)
divMod :: Integral a => a -> a -> (a, a)
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`
class (Num a) => Fractional a
(/) :: Fractional a => a -> a -> a
recip :: Fractional a => a -> a
fromRational :: Fractional a => Rational -> a
infixl 7 /
class (Fractional a) => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **
class (Real a, Fractional a) => RealFrac a
properFraction :: (RealFrac a, Integral b) => a -> (b, a)
truncate :: (RealFrac a, Integral b) => a -> b
round :: (RealFrac a, Integral b) => a -> b
ceiling :: (RealFrac a, Integral b) => a -> b
floor :: (RealFrac a, Integral b) => a -> b
class (RealFrac a, Floating a) => RealFloat a
floatRadix :: RealFloat a => a -> Integer
floatDigits :: RealFloat a => a -> Int
floatRange :: RealFloat a => a -> (Int, Int)
decodeFloat :: RealFloat a => a -> (Integer, Int)
encodeFloat :: RealFloat a => Integer -> Int -> a
exponent :: RealFloat a => a -> Int
significand :: RealFloat a => a -> a
scaleFloat :: RealFloat a => Int -> a -> a
isNaN :: RealFloat a => a -> Bool
isInfinite :: RealFloat a => a -> Bool
isDenormalized :: RealFloat a => a -> Bool
isNegativeZero :: RealFloat a => a -> Bool
isIEEE :: RealFloat a => a -> Bool
atan2 :: RealFloat a => a -> a -> a
subtract :: Num a => a -> a -> a
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool
gcd :: Integral a => a -> a -> a
lcm :: Integral a => a -> a -> a
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^
fromIntegral :: (Integral a, Num b) => a -> b
realToFrac :: (Real a, Fractional b) => a -> b
class Semigroup a
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>
class Semigroup a => Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>
class Functor f => Applicative f
pure :: Applicative f => a -> f a
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*
class Applicative m => Monad m
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b
(>>) :: forall a b. Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<
class Foldable t
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
elem :: (Foldable t, Eq a) => a -> t a -> Bool
maximum :: forall a. (Foldable t, Ord a) => t a -> a
minimum :: forall a. (Foldable t, Ord a) => t a -> a
infix 4 `elem`
class (Functor t, Foldable t) => Traversable t
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
id :: a -> a
const :: a -> b -> a
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .
flip :: (a -> b -> c) -> b -> a -> c
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $
until :: (a -> Bool) -> (a -> a) -> a -> a
asTypeOf :: a -> a -> a
error :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => [Char] -> a
errorWithoutStackTrace :: forall (r :: RuntimeRep). forall (a :: TYPE r). [Char] -> a
undefined :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => a
seq :: () => a -> b -> b
($!) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!
map :: (a -> b) -> [a] -> [b]
(++) :: [a] -> [a] -> [a]
infixr 5 ++
filter :: (a -> Bool) -> [a] -> [a]
null :: Foldable t => t a -> Bool
length :: Foldable t => t a -> Int
reverse :: [a] -> [a]
and :: Foldable t => t Bool -> Bool
or :: Foldable t => t Bool -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
all :: Foldable t => (a -> Bool) -> t a -> Bool
concat :: Foldable t => t [a] -> [a]
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
iterate :: (a -> a) -> a -> [a]
replicate :: Int -> a -> [a]
cycle :: [a] -> [a]
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
takeWhile :: (a -> Bool) -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
span :: (a -> Bool) -> [a] -> ([a], [a])
break :: (a -> Bool) -> [a] -> ([a], [a])
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`
lookup :: Eq a => a -> [(a, b)] -> Maybe b
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
lines :: String -> [String]
words :: String -> [String]
unlines :: [String] -> String
unwords :: [String] -> String
type ShowS = String -> String
class Show a
showsPrec :: Show a => Int -> a -> ShowS
show :: Show a => a -> String
showList :: Show a => [a] -> ShowS
shows :: Show a => a -> ShowS
showChar :: Char -> ShowS
showString :: String -> ShowS
showParen :: Bool -> ShowS -> ShowS
type ReadS a = String -> [(a, String)]
class Read a
readsPrec :: Read a => Int -> ReadS a
readList :: Read a => ReadS [a]
reads :: Read a => ReadS a
readParen :: Bool -> ReadS a -> ReadS a
read :: Read a => String -> a
lex :: ReadS String
data IO a
putChar :: Char -> IO ()
putStr :: String -> IO ()
putStrLn :: String -> IO ()
print :: Show a => a -> IO ()
getChar :: IO Char
getLine :: IO String
getContents :: IO String
interact :: (String -> String) -> IO ()
type FilePath = String
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()
appendFile :: FilePath -> String -> IO ()
readIO :: Read a => String -> IO a
readLn :: Read a => IO a
type IOError = IOException
ioError :: IOError -> IO a
userError :: String -> IOError
module Type.Reflection.Unsafe
data TypeRep (a :: k)
mkTrApp :: forall k1 k2 (a :: k1 -> k2) (b :: k1). TypeRep (a :: k1 -> k2) -> TypeRep (b :: k1) -> TypeRep (a b)
mkTyCon :: String -> String -> String -> Int -> KindRep -> TyCon
typeRepFingerprint :: TypeRep a -> Fingerprint
someTypeRepFingerprint :: SomeTypeRep -> Fingerprint
data KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep
data TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort
data TyCon
mkTrCon :: forall k (a :: k). TyCon -> [SomeTypeRep] -> TypeRep a
tyConKindRep :: TyCon -> KindRep
tyConKindArgs :: TyCon -> Int
tyConFingerprint :: TyCon -> Fingerprint
module Text.Show.Functions
instance GHC.Show.Show (a -> b)
module Text.Printf
printf :: PrintfType r => String -> r
hPrintf :: HPrintfType r => Handle -> String -> r
class PrintfArg a
formatArg :: PrintfArg a => a -> FieldFormatter
parseFormat :: PrintfArg a => a -> ModifierParser
type FieldFormatter = FieldFormat -> ShowS
data FieldFormat
FieldFormat :: Maybe Int -> Maybe Int -> Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> String -> Char -> FieldFormat
[fmtWidth] :: FieldFormat -> Maybe Int
[fmtPrecision] :: FieldFormat -> Maybe Int
[fmtAdjust] :: FieldFormat -> Maybe FormatAdjustment
[fmtSign] :: FieldFormat -> Maybe FormatSign
[fmtAlternate] :: FieldFormat -> Bool
[fmtModifiers] :: FieldFormat -> String
[fmtChar] :: FieldFormat -> Char
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign
vFmt :: Char -> FieldFormat -> FieldFormat
type ModifierParser = String -> FormatParse
data FormatParse
FormatParse :: String -> Char -> String -> FormatParse
[fpModifiers] :: FormatParse -> String
[fpChar] :: FormatParse -> Char
[fpRest] :: FormatParse -> String
formatString :: IsChar a => [a] -> FieldFormatter
formatChar :: Char -> FieldFormatter
formatInt :: (Integral a, Bounded a) => a -> FieldFormatter
formatInteger :: Integer -> FieldFormatter
formatRealFloat :: RealFloat a => a -> FieldFormatter
errorBadFormat :: Char -> a
errorShortFormat :: a
errorMissingArgument :: a
errorBadArgument :: a
perror :: String -> a
class PrintfType t
class HPrintfType t
class IsChar c
toChar :: IsChar c => c -> Char
fromChar :: IsChar c => Char -> c
instance Text.Printf.IsChar c => Text.Printf.PrintfType [c]
instance (a Data.Type.Equality.~ ()) => Text.Printf.PrintfType (GHC.Types.IO a)
instance (Text.Printf.PrintfArg a, Text.Printf.PrintfType r) => Text.Printf.PrintfType (a -> r)
instance (a Data.Type.Equality.~ ()) => Text.Printf.HPrintfType (GHC.Types.IO a)
instance (Text.Printf.PrintfArg a, Text.Printf.HPrintfType r) => Text.Printf.HPrintfType (a -> r)
instance Text.Printf.PrintfArg GHC.Types.Char
instance Text.Printf.IsChar c => Text.Printf.PrintfArg [c]
instance Text.Printf.PrintfArg GHC.Types.Int
instance Text.Printf.PrintfArg GHC.Int.Int8
instance Text.Printf.PrintfArg GHC.Int.Int16
instance Text.Printf.PrintfArg GHC.Int.Int32
instance Text.Printf.PrintfArg GHC.Int.Int64
instance Text.Printf.PrintfArg GHC.Types.Word
instance Text.Printf.PrintfArg GHC.Word.Word8
instance Text.Printf.PrintfArg GHC.Word.Word16
instance Text.Printf.PrintfArg GHC.Word.Word32
instance Text.Printf.PrintfArg GHC.Word.Word64
instance Text.Printf.PrintfArg GHC.Integer.Type.Integer
instance Text.Printf.PrintfArg GHC.Natural.Natural
instance Text.Printf.PrintfArg GHC.Types.Float
instance Text.Printf.PrintfArg GHC.Types.Double
instance Text.Printf.IsChar GHC.Types.Char
module System.Mem.Weak
data Weak v
mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)
deRefWeak :: Weak v -> IO (Maybe v)
finalize :: Weak v -> IO ()
mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)
addFinalizer :: key -> IO () -> IO ()
mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))
module System.Mem
performGC :: IO ()
performMajorGC :: IO ()
performMinorGC :: IO ()
setAllocationCounter :: Int64 -> IO ()
getAllocationCounter :: IO Int64
enableAllocationLimit :: IO ()
disableAllocationLimit :: IO ()
module System.Info
os :: String
arch :: String
compilerName :: String
compilerVersion :: Version
module System.Exit
data ExitCode
ExitSuccess :: ExitCode
ExitFailure :: Int -> ExitCode
exitWith :: ExitCode -> IO a
exitFailure :: IO a
exitSuccess :: IO a
die :: String -> IO a
module System.Environment
getArgs :: IO [String]
getProgName :: IO String
getExecutablePath :: IO FilePath
getEnv :: String -> IO String
lookupEnv :: String -> IO (Maybe String)
setEnv :: String -> String -> IO ()
unsetEnv :: String -> IO ()
withArgs :: [String] -> IO a -> IO a
withProgName :: String -> IO a -> IO a
getEnvironment :: IO [(String, String)]
module System.Environment.Blank
getExecutablePath :: IO FilePath
getArgs :: IO [String]
getProgName :: IO String
withArgs :: [String] -> IO a -> IO a
withProgName :: String -> IO a -> IO a
getEnvironment :: IO [(String, String)]
getEnv :: String -> IO (Maybe String)
getEnvDefault :: String -> String -> IO String
setEnv :: String -> String -> Bool -> IO ()
unsetEnv :: String -> IO ()
module System.Console.GetOpt
getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
usageInfo :: String -> [OptDescr a] -> String
data ArgOrder a
RequireOrder :: ArgOrder a
Permute :: ArgOrder a
ReturnInOrder :: (String -> a) -> ArgOrder a
data OptDescr a
Option :: [Char] -> [String] -> ArgDescr a -> String -> OptDescr a
data ArgDescr a
NoArg :: a -> ArgDescr a
ReqArg :: (String -> a) -> String -> ArgDescr a
OptArg :: (Maybe String -> a) -> String -> ArgDescr a
instance GHC.Base.Functor System.Console.GetOpt.OptDescr
instance GHC.Base.Functor System.Console.GetOpt.ArgDescr
instance GHC.Base.Functor System.Console.GetOpt.ArgOrder
module System.CPUTime
getCPUTime :: IO Integer
cpuTimePrecision :: Integer
module GHC.StableName
data StableName a
StableName :: StableName# a -> StableName a
makeStableName :: a -> IO (StableName a)
hashStableName :: StableName a -> Int
eqStableName :: StableName a -> StableName b -> Bool
instance GHC.Classes.Eq (GHC.StableName.StableName a)
module System.Mem.StableName
data StableName a
makeStableName :: a -> IO (StableName a)
hashStableName :: StableName a -> Int
eqStableName :: StableName a -> StableName b -> Bool
module GHC.ResponseFile
getArgsWithResponseFiles :: IO [String]
unescapeArgs :: String -> [String]
escapeArgs :: [String] -> String
expandResponse :: [String] -> IO [String]
module GHC.Records
class HasField (x :: k) r a | x r -> a
getField :: HasField x r a => r -> a
module GHC.OverloadedLabels
class IsLabel (x :: Symbol) a
fromLabel :: IsLabel x a => a
module GHC.ByteOrder
data ByteOrder
BigEndian :: ByteOrder
LittleEndian :: ByteOrder
targetByteOrder :: ByteOrder
instance GHC.Show.Show GHC.ByteOrder.ByteOrder
instance GHC.Read.Read GHC.ByteOrder.ByteOrder
instance GHC.Enum.Enum GHC.ByteOrder.ByteOrder
instance GHC.Enum.Bounded GHC.ByteOrder.ByteOrder
instance GHC.Classes.Ord GHC.ByteOrder.ByteOrder
instance GHC.Classes.Eq GHC.ByteOrder.ByteOrder
module Data.Unique
data Unique
newUnique :: IO Unique
hashUnique :: Unique -> Int
instance GHC.Classes.Ord Data.Unique.Unique
instance GHC.Classes.Eq Data.Unique.Unique
module Data.STRef
data STRef s a
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()
modifySTRef :: STRef s a -> (a -> a) -> ST s ()
modifySTRef' :: STRef s a -> (a -> a) -> ST s ()
module Data.STRef.Strict
module Data.Ratio
data Ratio a
type Rational = Ratio Integer
(%) :: Integral a => a -> a -> Ratio a
infixl 7 %
numerator :: Ratio a -> a
denominator :: Ratio a -> a
approxRational :: RealFrac a => a -> a -> Rational
module Data.Kind
type Type = Type
data Constraint
module Data.Ix
class (Ord a) => Ix a
range :: Ix a => (a, a) -> [a]
index :: Ix a => (a, a) -> a -> Int
inRange :: Ix a => (a, a) -> a -> Bool
rangeSize :: Ix a => (a, a) -> Int
module Control.Monad.ST.Unsafe
unsafeInterleaveST :: ST s a -> ST s a
unsafeDupableInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a
unsafeSTToIO :: ST s a -> IO a
module Control.Monad.ST.Safe
data ST s a
runST :: (forall s. ST s a) -> a
fixST :: (a -> ST s a) -> ST s a
data RealWorld :: Type
stToIO :: ST RealWorld a -> IO a
module Control.Monad.ST
data ST s a
runST :: (forall s. ST s a) -> a
fixST :: (a -> ST s a) -> ST s a
data RealWorld :: Type
stToIO :: ST RealWorld a -> IO a
module Control.Monad.ST.Strict
module Control.Monad.ST.Lazy.Unsafe
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a
module Control.Monad.ST.Lazy.Safe
data ST s a
runST :: (forall s. ST s a) -> a
fixST :: (a -> ST s a) -> ST s a
strictToLazyST :: ST s a -> ST s a
lazyToStrictST :: ST s a -> ST s a
data RealWorld :: Type
stToIO :: ST RealWorld a -> IO a
module Control.Monad.ST.Lazy
data ST s a
runST :: (forall s. ST s a) -> a
fixST :: (a -> ST s a) -> ST s a
strictToLazyST :: ST s a -> ST s a
lazyToStrictST :: ST s a -> ST s a
data RealWorld :: Type
stToIO :: ST RealWorld a -> IO a
module Data.STRef.Lazy
data STRef s a
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()
modifySTRef :: STRef s a -> (a -> a) -> ST s ()
module Control.Monad.Instances
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$
class Applicative m => Monad m
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b
(>>) :: forall a b. Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>
module Control.Monad.IO.Class
class (Monad m) => MonadIO m
liftIO :: MonadIO m => IO a -> m a
instance Control.Monad.IO.Class.MonadIO GHC.Types.IO
module GHC.Stats
data RTSStats
RTSStats :: Word32 -> Word32 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> GCDetails -> RTSStats
[gcs] :: RTSStats -> Word32
[major_gcs] :: RTSStats -> Word32
[allocated_bytes] :: RTSStats -> Word64
[max_live_bytes] :: RTSStats -> Word64
[max_large_objects_bytes] :: RTSStats -> Word64
[max_compact_bytes] :: RTSStats -> Word64
[max_slop_bytes] :: RTSStats -> Word64
[max_mem_in_use_bytes] :: RTSStats -> Word64
[cumulative_live_bytes] :: RTSStats -> Word64
[copied_bytes] :: RTSStats -> Word64
[par_copied_bytes] :: RTSStats -> Word64
[cumulative_par_max_copied_bytes] :: RTSStats -> Word64
[cumulative_par_balanced_copied_bytes] :: RTSStats -> Word64
[init_cpu_ns] :: RTSStats -> RtsTime
[init_elapsed_ns] :: RTSStats -> RtsTime
[mutator_cpu_ns] :: RTSStats -> RtsTime
[mutator_elapsed_ns] :: RTSStats -> RtsTime
[gc_cpu_ns] :: RTSStats -> RtsTime
[gc_elapsed_ns] :: RTSStats -> RtsTime
[cpu_ns] :: RTSStats -> RtsTime
[elapsed_ns] :: RTSStats -> RtsTime
[gc] :: RTSStats -> GCDetails
data GCDetails
GCDetails :: Word32 -> Word32 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> RtsTime -> RtsTime -> RtsTime -> GCDetails
[gcdetails_gen] :: GCDetails -> Word32
[gcdetails_threads] :: GCDetails -> Word32
[gcdetails_allocated_bytes] :: GCDetails -> Word64
[gcdetails_live_bytes] :: GCDetails -> Word64
[gcdetails_large_objects_bytes] :: GCDetails -> Word64
[gcdetails_compact_bytes] :: GCDetails -> Word64
[gcdetails_slop_bytes] :: GCDetails -> Word64
[gcdetails_mem_in_use_bytes] :: GCDetails -> Word64
[gcdetails_copied_bytes] :: GCDetails -> Word64
[gcdetails_par_max_copied_bytes] :: GCDetails -> Word64
[gcdetails_par_balanced_copied_bytes] :: GCDetails -> Word64
[gcdetails_sync_elapsed_ns] :: GCDetails -> RtsTime
[gcdetails_cpu_ns] :: GCDetails -> RtsTime
[gcdetails_elapsed_ns] :: GCDetails -> RtsTime
type RtsTime = Int64
getRTSStats :: IO RTSStats
getRTSStatsEnabled :: IO Bool
instance GHC.Show.Show GHC.Stats.RTSStats
instance GHC.Read.Read GHC.Stats.RTSStats
instance GHC.Show.Show GHC.Stats.GCDetails
instance GHC.Read.Read GHC.Stats.GCDetails
module GHC.RTS.Flags
type RtsTime = Word64
data RTSFlags
RTSFlags :: GCFlags -> ConcFlags -> MiscFlags -> DebugFlags -> CCFlags -> ProfFlags -> TraceFlags -> TickyFlags -> ParFlags -> RTSFlags
[gcFlags] :: RTSFlags -> GCFlags
[concurrentFlags] :: RTSFlags -> ConcFlags
[miscFlags] :: RTSFlags -> MiscFlags
[debugFlags] :: RTSFlags -> DebugFlags
[costCentreFlags] :: RTSFlags -> CCFlags
[profilingFlags] :: RTSFlags -> ProfFlags
[traceFlags] :: RTSFlags -> TraceFlags
[tickyFlags] :: RTSFlags -> TickyFlags
[parFlags] :: RTSFlags -> ParFlags
data GiveGCStats
NoGCStats :: GiveGCStats
CollectGCStats :: GiveGCStats
OneLineGCStats :: GiveGCStats
SummaryGCStats :: GiveGCStats
VerboseGCStats :: GiveGCStats
data GCFlags
GCFlags :: Maybe FilePath -> GiveGCStats -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Bool -> Double -> Double -> Word32 -> Bool -> Bool -> Double -> Bool -> Bool -> RtsTime -> Bool -> Word -> Word -> Bool -> Word -> GCFlags
[statsFile] :: GCFlags -> Maybe FilePath
[giveStats] :: GCFlags -> GiveGCStats
[maxStkSize] :: GCFlags -> Word32
[initialStkSize] :: GCFlags -> Word32
[stkChunkSize] :: GCFlags -> Word32
[stkChunkBufferSize] :: GCFlags -> Word32
[maxHeapSize] :: GCFlags -> Word32
[minAllocAreaSize] :: GCFlags -> Word32
[largeAllocLim] :: GCFlags -> Word32
[nurseryChunkSize] :: GCFlags -> Word32
[minOldGenSize] :: GCFlags -> Word32
[heapSizeSuggestion] :: GCFlags -> Word32
[heapSizeSuggestionAuto] :: GCFlags -> Bool
[oldGenFactor] :: GCFlags -> Double
[pcFreeHeap] :: GCFlags -> Double
[generations] :: GCFlags -> Word32
[squeezeUpdFrames] :: GCFlags -> Bool
[compact] :: GCFlags -> Bool
[compactThreshold] :: GCFlags -> Double
[sweep] :: GCFlags -> Bool
[ringBell] :: GCFlags -> Bool
[idleGCDelayTime] :: GCFlags -> RtsTime
[doIdleGC] :: GCFlags -> Bool
[heapBase] :: GCFlags -> Word
[allocLimitGrace] :: GCFlags -> Word
[numa] :: GCFlags -> Bool
[numaMask] :: GCFlags -> Word
data ConcFlags
ConcFlags :: RtsTime -> Int -> ConcFlags
[ctxtSwitchTime] :: ConcFlags -> RtsTime
[ctxtSwitchTicks] :: ConcFlags -> Int
data MiscFlags
MiscFlags :: RtsTime -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Word -> MiscFlags
[tickInterval] :: MiscFlags -> RtsTime
[installSignalHandlers] :: MiscFlags -> Bool
[installSEHHandlers] :: MiscFlags -> Bool
[generateCrashDumpFile] :: MiscFlags -> Bool
[generateStackTrace] :: MiscFlags -> Bool
[machineReadable] :: MiscFlags -> Bool
[internalCounters] :: MiscFlags -> Bool
[linkerMemBase] :: MiscFlags -> Word
data DebugFlags
DebugFlags :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> DebugFlags
[scheduler] :: DebugFlags -> Bool
[interpreter] :: DebugFlags -> Bool
[weak] :: DebugFlags -> Bool
[gccafs] :: DebugFlags -> Bool
[gc] :: DebugFlags -> Bool
[block_alloc] :: DebugFlags -> Bool
[sanity] :: DebugFlags -> Bool
[stable] :: DebugFlags -> Bool
[prof] :: DebugFlags -> Bool
[linker] :: DebugFlags -> Bool
[apply] :: DebugFlags -> Bool
[stm] :: DebugFlags -> Bool
[squeeze] :: DebugFlags -> Bool
[hpc] :: DebugFlags -> Bool
[sparks] :: DebugFlags -> Bool
data DoCostCentres
CostCentresNone :: DoCostCentres
CostCentresSummary :: DoCostCentres
CostCentresVerbose :: DoCostCentres
CostCentresAll :: DoCostCentres
CostCentresJSON :: DoCostCentres
data CCFlags
CCFlags :: DoCostCentres -> Int -> Int -> CCFlags
[doCostCentres] :: CCFlags -> DoCostCentres
[profilerTicks] :: CCFlags -> Int
[msecsPerTick] :: CCFlags -> Int
data DoHeapProfile
NoHeapProfiling :: DoHeapProfile
HeapByCCS :: DoHeapProfile
HeapByMod :: DoHeapProfile
HeapByDescr :: DoHeapProfile
HeapByType :: DoHeapProfile
HeapByRetainer :: DoHeapProfile
HeapByLDV :: DoHeapProfile
HeapByClosureType :: DoHeapProfile
data ProfFlags
ProfFlags :: DoHeapProfile -> RtsTime -> Word -> Bool -> Bool -> Word -> Word -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> ProfFlags
[doHeapProfile] :: ProfFlags -> DoHeapProfile
[heapProfileInterval] :: ProfFlags -> RtsTime
[heapProfileIntervalTicks] :: ProfFlags -> Word
[includeTSOs] :: ProfFlags -> Bool
[showCCSOnException] :: ProfFlags -> Bool
[maxRetainerSetSize] :: ProfFlags -> Word
[ccsLength] :: ProfFlags -> Word
[modSelector] :: ProfFlags -> Maybe String
[descrSelector] :: ProfFlags -> Maybe String
[typeSelector] :: ProfFlags -> Maybe String
[ccSelector] :: ProfFlags -> Maybe String
[ccsSelector] :: ProfFlags -> Maybe String
[retainerSelector] :: ProfFlags -> Maybe String
[bioSelector] :: ProfFlags -> Maybe String
data DoTrace
TraceNone :: DoTrace
TraceEventLog :: DoTrace
TraceStderr :: DoTrace
data TraceFlags
TraceFlags :: DoTrace -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> TraceFlags
[tracing] :: TraceFlags -> DoTrace
[timestamp] :: TraceFlags -> Bool
[traceScheduler] :: TraceFlags -> Bool
[traceGc] :: TraceFlags -> Bool
[sparksSampled] :: TraceFlags -> Bool
[sparksFull] :: TraceFlags -> Bool
[user] :: TraceFlags -> Bool
data TickyFlags
TickyFlags :: Bool -> Maybe FilePath -> TickyFlags
[showTickyStats] :: TickyFlags -> Bool
[tickyFile] :: TickyFlags -> Maybe FilePath
data ParFlags
ParFlags :: Word32 -> Bool -> Word32 -> Bool -> Word32 -> Bool -> Word32 -> Word32 -> Word32 -> Bool -> ParFlags
[nCapabilities] :: ParFlags -> Word32
[migrate] :: ParFlags -> Bool
[maxLocalSparks] :: ParFlags -> Word32
[parGcEnabled] :: ParFlags -> Bool
[parGcGen] :: ParFlags -> Word32
[parGcLoadBalancingEnabled] :: ParFlags -> Bool
[parGcLoadBalancingGen] :: ParFlags -> Word32
[parGcNoSyncWithIdle] :: ParFlags -> Word32
[parGcThreads] :: ParFlags -> Word32
[setAffinity] :: ParFlags -> Bool
getRTSFlags :: IO RTSFlags
getGCFlags :: IO GCFlags
getConcFlags :: IO ConcFlags
getMiscFlags :: IO MiscFlags
getDebugFlags :: IO DebugFlags
getCCFlags :: IO CCFlags
getProfFlags :: IO ProfFlags
getTraceFlags :: IO TraceFlags
getTickyFlags :: IO TickyFlags
getParFlags :: IO ParFlags
instance GHC.Show.Show GHC.RTS.Flags.RTSFlags
instance GHC.Show.Show GHC.RTS.Flags.ParFlags
instance GHC.Show.Show GHC.RTS.Flags.TickyFlags
instance GHC.Show.Show GHC.RTS.Flags.TraceFlags
instance GHC.Show.Show GHC.RTS.Flags.DoTrace
instance GHC.Show.Show GHC.RTS.Flags.ProfFlags
instance GHC.Show.Show GHC.RTS.Flags.DoHeapProfile
instance GHC.Show.Show GHC.RTS.Flags.CCFlags
instance GHC.Show.Show GHC.RTS.Flags.DoCostCentres
instance GHC.Show.Show GHC.RTS.Flags.DebugFlags
instance GHC.Show.Show GHC.RTS.Flags.MiscFlags
instance GHC.Show.Show GHC.RTS.Flags.ConcFlags
instance GHC.Show.Show GHC.RTS.Flags.GCFlags
instance GHC.Show.Show GHC.RTS.Flags.GiveGCStats
instance GHC.Enum.Enum GHC.RTS.Flags.DoTrace
instance GHC.Enum.Enum GHC.RTS.Flags.DoHeapProfile
instance GHC.Enum.Enum GHC.RTS.Flags.DoCostCentres
instance GHC.Enum.Enum GHC.RTS.Flags.GiveGCStats
module GHC.ExecutionStack.Internal
data Location
Location :: String -> String -> Maybe SrcLoc -> Location
[objectName] :: Location -> String
[functionName] :: Location -> String
[srcLoc] :: Location -> Maybe SrcLoc
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[sourceFile] :: SrcLoc -> String
[sourceLine] :: SrcLoc -> Int
[sourceColumn] :: SrcLoc -> Int
data StackTrace
stackFrames :: StackTrace -> Maybe [Location]
stackDepth :: StackTrace -> Int
collectStackTrace :: IO (Maybe StackTrace)
showStackFrames :: [Location] -> ShowS
invalidateDebugCache :: IO ()
module GHC.ExecutionStack
data Location
Location :: String -> String -> Maybe SrcLoc -> Location
[objectName] :: Location -> String
[functionName] :: Location -> String
[srcLoc] :: Location -> Maybe SrcLoc
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[sourceFile] :: SrcLoc -> String
[sourceLine] :: SrcLoc -> Int
[sourceColumn] :: SrcLoc -> Int
getStackTrace :: IO (Maybe [Location])
showStackTrace :: IO (Maybe String)
module Data.List.NonEmpty
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|
map :: (a -> b) -> NonEmpty a -> NonEmpty b
intersperse :: a -> NonEmpty a -> NonEmpty a
scanl :: Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b
scanr :: Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b
scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a
scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a
transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)
sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a
sortWith :: Ord o => (a -> o) -> NonEmpty a -> NonEmpty a
length :: NonEmpty a -> Int
head :: NonEmpty a -> a
tail :: NonEmpty a -> [a]
last :: NonEmpty a -> a
init :: NonEmpty a -> [a]
(<|) :: a -> NonEmpty a -> NonEmpty a
infixr 5 <|
cons :: a -> NonEmpty a -> NonEmpty a
uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))
unfoldr :: (a -> (b, Maybe a)) -> a -> NonEmpty b
sort :: Ord a => NonEmpty a -> NonEmpty a
reverse :: NonEmpty a -> NonEmpty a
inits :: Foldable f => f a -> NonEmpty [a]
tails :: Foldable f => f a -> NonEmpty [a]
iterate :: (a -> a) -> a -> NonEmpty a
cycle :: NonEmpty a -> NonEmpty a
unfold :: (a -> (b, Maybe a)) -> a -> NonEmpty b
insert :: (Foldable f, Ord a) => a -> f a -> NonEmpty a
some1 :: Alternative f => f a -> f (NonEmpty a)
take :: Int -> NonEmpty a -> [a]
drop :: Int -> NonEmpty a -> [a]
splitAt :: Int -> NonEmpty a -> ([a], [a])
takeWhile :: (a -> Bool) -> NonEmpty a -> [a]
dropWhile :: (a -> Bool) -> NonEmpty a -> [a]
span :: (a -> Bool) -> NonEmpty a -> ([a], [a])
break :: (a -> Bool) -> NonEmpty a -> ([a], [a])
filter :: (a -> Bool) -> NonEmpty a -> [a]
partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])
group :: (Foldable f, Eq a) => f a -> [NonEmpty a]
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]
groupWith :: (Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]
groupAllWith :: Ord b => (a -> b) -> [a] -> [NonEmpty a]
group1 :: Eq a => NonEmpty a -> NonEmpty (NonEmpty a)
groupBy1 :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)
groupWith1 :: Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)
groupAllWith1 :: Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)
isPrefixOf :: Eq a => [a] -> NonEmpty a -> Bool
nub :: Eq a => NonEmpty a -> NonEmpty a
nubBy :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty a
zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)
zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c
unzip :: Functor f => f (a, b) -> (f a, f b)
fromList :: [a] -> NonEmpty a
toList :: NonEmpty a -> [a]
nonEmpty :: [a] -> Maybe (NonEmpty a)
xor :: NonEmpty Bool -> Bool
module Control.Monad.Zip
class Monad m => MonadZip m
mzip :: MonadZip m => m a -> m b -> m (a, b)
mzipWith :: MonadZip m => (a -> b -> c) -> m a -> m b -> m c
munzip :: MonadZip m => m (a, b) -> (m a, m b)
instance Control.Monad.Zip.MonadZip []
instance Control.Monad.Zip.MonadZip GHC.Base.NonEmpty
instance Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Dual
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Sum
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Product
instance Control.Monad.Zip.MonadZip GHC.Maybe.Maybe
instance Control.Monad.Zip.MonadZip Data.Monoid.First
instance Control.Monad.Zip.MonadZip Data.Monoid.Last
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (Data.Semigroup.Internal.Alt f)
instance Control.Monad.Zip.MonadZip Data.Proxy.Proxy
instance Control.Monad.Zip.MonadZip GHC.Generics.U1
instance Control.Monad.Zip.MonadZip GHC.Generics.Par1
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (GHC.Generics.Rec1 f)
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (GHC.Generics.M1 i c f)
instance (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) => Control.Monad.Zip.MonadZip (f GHC.Generics.:*: g)
instance Control.Monad.Zip.MonadZip Data.Ord.Down
module Data.Functor.Classes
class Eq1 f
liftEq :: Eq1 f => (a -> b -> Bool) -> f a -> f b -> Bool
eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool
class (Eq1 f) => Ord1 f
liftCompare :: Ord1 f => (a -> b -> Ordering) -> f a -> f b -> Ordering
compare1 :: (Ord1 f, Ord a) => f a -> f a -> Ordering
class Read1 f
liftReadsPrec :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)
liftReadList :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]
liftReadPrec :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)
liftReadListPrec :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]
readsPrec1 :: (Read1 f, Read a) => Int -> ReadS (f a)
readPrec1 :: (Read1 f, Read a) => ReadPrec (f a)
liftReadListDefault :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]
liftReadListPrecDefault :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]
class Show1 f
liftShowsPrec :: Show1 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS
liftShowList :: Show1 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> [f a] -> ShowS
showsPrec1 :: (Show1 f, Show a) => Int -> f a -> ShowS
class Eq2 f
liftEq2 :: Eq2 f => (a -> b -> Bool) -> (c -> d -> Bool) -> f a c -> f b d -> Bool
eq2 :: (Eq2 f, Eq a, Eq b) => f a b -> f a b -> Bool
class (Eq2 f) => Ord2 f
liftCompare2 :: Ord2 f => (a -> b -> Ordering) -> (c -> d -> Ordering) -> f a c -> f b d -> Ordering
compare2 :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> Ordering
class Read2 f
liftReadsPrec2 :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> Int -> ReadS (f a b)
liftReadList2 :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]
liftReadPrec2 :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec (f a b)
liftReadListPrec2 :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]
readsPrec2 :: (Read2 f, Read a, Read b) => Int -> ReadS (f a b)
readPrec2 :: (Read2 f, Read a, Read b) => ReadPrec (f a b)
liftReadList2Default :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]
liftReadListPrec2Default :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]
class Show2 f
liftShowsPrec2 :: Show2 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> Int -> f a b -> ShowS
liftShowList2 :: Show2 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> [f a b] -> ShowS
showsPrec2 :: (Show2 f, Show a, Show b) => Int -> f a b -> ShowS
readsData :: (String -> ReadS a) -> Int -> ReadS a
readData :: ReadPrec a -> ReadPrec a
readsUnaryWith :: (Int -> ReadS a) -> String -> (a -> t) -> String -> ReadS t
readUnaryWith :: ReadPrec a -> String -> (a -> t) -> ReadPrec t
readsBinaryWith :: (Int -> ReadS a) -> (Int -> ReadS b) -> String -> (a -> b -> t) -> String -> ReadS t
readBinaryWith :: ReadPrec a -> ReadPrec b -> String -> (a -> b -> t) -> ReadPrec t
showsUnaryWith :: (Int -> a -> ShowS) -> String -> Int -> a -> ShowS
showsBinaryWith :: (Int -> a -> ShowS) -> (Int -> b -> ShowS) -> String -> Int -> a -> b -> ShowS
readsUnary :: Read a => String -> (a -> t) -> String -> ReadS t
readsUnary1 :: (Read1 f, Read a) => String -> (f a -> t) -> String -> ReadS t
readsBinary1 :: (Read1 f, Read1 g, Read a) => String -> (f a -> g a -> t) -> String -> ReadS t
showsUnary :: Show a => String -> Int -> a -> ShowS
showsUnary1 :: (Show1 f, Show a) => String -> Int -> f a -> ShowS
showsBinary1 :: (Show1 f, Show1 g, Show a) => String -> Int -> f a -> g a -> ShowS
instance Data.Functor.Classes.Show2 (,)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a)
instance Data.Functor.Classes.Show2 Data.Either.Either
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Either.Either a)
instance Data.Functor.Classes.Show2 Data.Functor.Const.Const
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Read2 (,)
instance GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a)
instance Data.Functor.Classes.Read2 Data.Either.Either
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Either.Either a)
instance Data.Functor.Classes.Read2 Data.Functor.Const.Const
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Ord2 (,)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a)
instance Data.Functor.Classes.Ord2 Data.Either.Either
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Either.Either a)
instance Data.Functor.Classes.Ord2 Data.Functor.Const.Const
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Eq2 (,)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a)
instance Data.Functor.Classes.Eq2 Data.Either.Either
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Either.Either a)
instance Data.Functor.Classes.Eq2 Data.Functor.Const.Const
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Show1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Show1 []
instance Data.Functor.Classes.Show1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Show1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Show1 Data.Proxy.Proxy
instance Data.Functor.Classes.Show1 Data.Ord.Down
instance Data.Functor.Classes.Read1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Read1 []
instance Data.Functor.Classes.Read1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Read1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Read1 Data.Proxy.Proxy
instance Data.Functor.Classes.Read1 Data.Ord.Down
instance Data.Functor.Classes.Ord1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Ord1 []
instance Data.Functor.Classes.Ord1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Ord1 Data.Proxy.Proxy
instance Data.Functor.Classes.Ord1 Data.Ord.Down
instance Data.Functor.Classes.Eq1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Eq1 []
instance Data.Functor.Classes.Eq1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Eq1 Data.Proxy.Proxy
instance Data.Functor.Classes.Eq1 Data.Ord.Down
module Data.Bifunctor
class Bifunctor p
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
first :: Bifunctor p => (a -> b) -> p a c -> p b c
second :: Bifunctor p => (b -> c) -> p a b -> p a c
instance Data.Bifunctor.Bifunctor (,)
instance Data.Bifunctor.Bifunctor ((,,) x1)
instance Data.Bifunctor.Bifunctor ((,,,) x1 x2)
instance Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
instance Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
instance Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
instance Data.Bifunctor.Bifunctor Data.Either.Either
instance Data.Bifunctor.Bifunctor Data.Functor.Const.Const
instance Data.Bifunctor.Bifunctor (GHC.Generics.K1 i)
module Data.Bifoldable
class Bifoldable p
bifold :: (Bifoldable p, Monoid m) => p m m -> m
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c
bifoldr1 :: Bifoldable t => (a -> a -> a) -> t a a -> a
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a
bifoldl1 :: Bifoldable t => (a -> a -> a) -> t a a -> a
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()
bimapM_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()
biforM_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()
bimsum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a
bisequenceA_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()
bisequence_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()
biasum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a
biList :: Bifoldable t => t a a -> [a]
binull :: Bifoldable t => t a b -> Bool
bilength :: Bifoldable t => t a b -> Int
bielem :: (Bifoldable t, Eq a) => a -> t a a -> Bool
bimaximum :: forall t a. (Bifoldable t, Ord a) => t a a -> a
biminimum :: forall t a. (Bifoldable t, Ord a) => t a a -> a
bisum :: (Bifoldable t, Num a) => t a a -> a
biproduct :: (Bifoldable t, Num a) => t a a -> a
biconcat :: Bifoldable t => t [a] [a] -> [a]
biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]
biand :: Bifoldable t => t Bool Bool -> Bool
bior :: Bifoldable t => t Bool Bool -> Bool
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool
bimaximumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a
biminimumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a
binotElem :: (Bifoldable t, Eq a) => a -> t a a -> Bool
bifind :: Bifoldable t => (a -> Bool) -> t a a -> Maybe a
instance Data.Bifoldable.Bifoldable (,)
instance Data.Bifoldable.Bifoldable Data.Functor.Const.Const
instance Data.Bifoldable.Bifoldable (GHC.Generics.K1 i)
instance Data.Bifoldable.Bifoldable ((,,) x)
instance Data.Bifoldable.Bifoldable ((,,,) x y)
instance Data.Bifoldable.Bifoldable ((,,,,) x y z)
instance Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
instance Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
instance Data.Bifoldable.Bifoldable Data.Either.Either
module Data.Bitraversable
class (Bifunctor t, Bifoldable t) => Bitraversable t
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)
bisequence :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)
bimapM :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
biforM :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
bimapDefault :: forall t a b c d. Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d
bifoldMapDefault :: forall t m a b. (Bitraversable t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Bitraversable.Bitraversable (,)
instance Data.Bitraversable.Bitraversable ((,,) x)
instance Data.Bitraversable.Bitraversable ((,,,) x y)
instance Data.Bitraversable.Bitraversable ((,,,,) x y z)
instance Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
instance Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
instance Data.Bitraversable.Bitraversable Data.Either.Either
instance Data.Bitraversable.Bitraversable Data.Functor.Const.Const
instance Data.Bitraversable.Bitraversable (GHC.Generics.K1 i)
module GHC.Event
data EventManager
data TimerManager
getSystemEventManager :: IO (Maybe EventManager)
new :: IO EventManager
getSystemTimerManager :: IO TimerManager
data Event
evtRead :: Event
evtWrite :: Event
type IOCallback = FdKey -> Event -> IO ()
data FdKey
data Lifetime
OneShot :: Lifetime
MultiShot :: Lifetime
registerFd :: EventManager -> IOCallback -> Fd -> Event -> Lifetime -> IO FdKey
unregisterFd :: EventManager -> FdKey -> IO ()
unregisterFd_ :: EventManager -> FdKey -> IO Bool
closeFd :: EventManager -> (Fd -> IO ()) -> Fd -> IO ()
type TimeoutCallback = IO ()
data TimeoutKey
registerTimeout :: TimerManager -> Int -> TimeoutCallback -> IO TimeoutKey
updateTimeout :: TimerManager -> TimeoutKey -> Int -> IO ()
unregisterTimeout :: TimerManager -> TimeoutKey -> IO ()
module GHC.Conc
data ThreadId
ThreadId :: ThreadId# -> ThreadId
forkIO :: IO () -> IO ThreadId
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId
forkOn :: Int -> IO () -> IO ThreadId
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId
numCapabilities :: Int
getNumCapabilities :: IO Int
setNumCapabilities :: Int -> IO ()
getNumProcessors :: IO Int
numSparks :: IO Int
childHandler :: SomeException -> IO ()
myThreadId :: IO ThreadId
killThread :: ThreadId -> IO ()
throwTo :: Exception e => ThreadId -> e -> IO ()
par :: a -> b -> b
infixr 0 `par`
pseq :: a -> b -> b
infixr 0 `pseq`
runSparks :: IO ()
yield :: IO ()
labelThread :: ThreadId -> String -> IO ()
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)
data ThreadStatus
ThreadRunning :: ThreadStatus
ThreadFinished :: ThreadStatus
ThreadBlocked :: BlockReason -> ThreadStatus
ThreadDied :: ThreadStatus
data BlockReason
BlockedOnMVar :: BlockReason
BlockedOnBlackHole :: BlockReason
BlockedOnException :: BlockReason
BlockedOnSTM :: BlockReason
BlockedOnForeignCall :: BlockReason
BlockedOnOther :: BlockReason
threadStatus :: ThreadId -> IO ThreadStatus
threadCapability :: ThreadId -> IO (Int, Bool)
newStablePtrPrimMVar :: MVar () -> IO (StablePtr PrimMVar)
data PrimMVar
threadDelay :: Int -> IO ()
registerDelay :: Int -> IO (TVar Bool)
threadWaitRead :: Fd -> IO ()
threadWaitWrite :: Fd -> IO ()
threadWaitReadSTM :: Fd -> IO (STM (), IO ())
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()
setAllocationCounter :: Int64 -> IO ()
getAllocationCounter :: IO Int64
enableAllocationLimit :: IO ()
disableAllocationLimit :: IO ()
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a
atomically :: STM a -> IO a
retry :: STM a
orElse :: STM a -> STM a -> STM a
throwSTM :: Exception e => e -> STM a
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a
data TVar a
TVar :: TVar# RealWorld a -> TVar a
newTVar :: a -> STM (TVar a)
newTVarIO :: a -> IO (TVar a)
readTVar :: TVar a -> STM a
readTVarIO :: TVar a -> IO a
writeTVar :: TVar a -> a -> STM ()
unsafeIOToSTM :: IO a -> STM a
withMVar :: MVar a -> (a -> IO b) -> IO b
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()
reportHeapOverflow :: IO ()
module Control.Concurrent.QSemN
data QSemN
newQSemN :: Int -> IO QSemN
waitQSemN :: QSemN -> Int -> IO ()
signalQSemN :: QSemN -> Int -> IO ()
module Control.Concurrent.QSem
data QSem
newQSem :: Int -> IO QSem
waitQSem :: QSem -> IO ()
signalQSem :: QSem -> IO ()
module Control.Concurrent.Chan
data Chan a
newChan :: IO (Chan a)
writeChan :: Chan a -> a -> IO ()
readChan :: Chan a -> IO a
dupChan :: Chan a -> IO (Chan a)
getChanContents :: Chan a -> IO [a]
writeList2Chan :: Chan a -> [a] -> IO ()
instance GHC.Classes.Eq (Control.Concurrent.Chan.Chan a)
module Control.Concurrent
data ThreadId
myThreadId :: IO ThreadId
forkIO :: IO () -> IO ThreadId
forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId
killThread :: ThreadId -> IO ()
throwTo :: Exception e => ThreadId -> e -> IO ()
forkOn :: Int -> IO () -> IO ThreadId
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId
getNumCapabilities :: IO Int
setNumCapabilities :: Int -> IO ()
threadCapability :: ThreadId -> IO (Int, Bool)
yield :: IO ()
threadDelay :: Int -> IO ()
threadWaitRead :: Fd -> IO ()
threadWaitWrite :: Fd -> IO ()
threadWaitReadSTM :: Fd -> IO (STM (), IO ())
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())
rtsSupportsBoundThreads :: Bool
forkOS :: IO () -> IO ThreadId
forkOSWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId
isCurrentThreadBound :: IO Bool
runInBoundThread :: IO a -> IO a
runInUnboundThread :: IO a -> IO a
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)
module System.Timeout
timeout :: Int -> IO a -> IO (Maybe a)
instance GHC.Classes.Eq System.Timeout.Timeout
instance GHC.Show.Show System.Timeout.Timeout
instance GHC.Exception.Type.Exception System.Timeout.Timeout
module Data.Data
class Typeable a => Data a
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
toConstr :: Data a => a -> Constr
dataTypeOf :: Data a => a -> DataType
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a
gmapQl :: forall r r'. Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]
gmapQi :: forall u. Data a => Int -> (forall d. Data d => d -> u) -> a -> u
gmapM :: forall m. (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a
gmapMp :: forall m. (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a
gmapMo :: forall m. (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a
data DataType
mkDataType :: String -> [Constr] -> DataType
mkIntType :: String -> DataType
mkFloatType :: String -> DataType
mkCharType :: String -> DataType
mkNoRepType :: String -> DataType
dataTypeName :: DataType -> String
data DataRep
AlgRep :: [Constr] -> DataRep
IntRep :: DataRep
FloatRep :: DataRep
CharRep :: DataRep
NoRep :: DataRep
dataTypeRep :: DataType -> DataRep
repConstr :: DataType -> ConstrRep -> Constr
isAlgType :: DataType -> Bool
dataTypeConstrs :: DataType -> [Constr]
indexConstr :: DataType -> ConIndex -> Constr
maxConstrIndex :: DataType -> ConIndex
isNorepType :: DataType -> Bool
data Constr
type ConIndex = Int
data Fixity
Prefix :: Fixity
Infix :: Fixity
mkConstr :: DataType -> String -> [String] -> Fixity -> Constr
mkIntegralConstr :: (Integral a, Show a) => DataType -> a -> Constr
mkRealConstr :: (Real a, Show a) => DataType -> a -> Constr
mkCharConstr :: DataType -> Char -> Constr
constrType :: Constr -> DataType
data ConstrRep
AlgConstr :: ConIndex -> ConstrRep
IntConstr :: Integer -> ConstrRep
FloatConstr :: Rational -> ConstrRep
CharConstr :: Char -> ConstrRep
constrRep :: Constr -> ConstrRep
constrFields :: Constr -> [String]
constrFixity :: Constr -> Fixity
constrIndex :: Constr -> ConIndex
showConstr :: Constr -> String
readConstr :: DataType -> String -> Maybe Constr
tyconUQname :: String -> String
tyconModule :: String -> String
fromConstr :: Data a => Constr -> a
fromConstrB :: Data a => (forall d. Data d => d) -> Constr -> a
fromConstrM :: forall m a. (Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
instance GHC.Show.Show Data.Data.DataRep
instance GHC.Classes.Eq Data.Data.DataRep
instance GHC.Show.Show Data.Data.DataType
instance GHC.Show.Show Data.Data.Fixity
instance GHC.Classes.Eq Data.Data.Fixity
instance GHC.Show.Show Data.Data.ConstrRep
instance GHC.Classes.Eq Data.Data.ConstrRep
instance Data.Data.Data GHC.Types.Bool
instance Data.Data.Data a => Data.Data.Data (GHC.Base.NonEmpty a)
instance Data.Data.Data a => Data.Data.Data (GHC.Maybe.Maybe a)
instance Data.Data.Data GHC.Types.Ordering
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Either.Either a b)
instance Data.Data.Data ()
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (a, b)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c) => Data.Data.Data (a, b, c)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d) => Data.Data.Data (a, b, c, d)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e) => Data.Data.Data (a, b, c, d, e)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f) => Data.Data.Data (a, b, c, d, e, f)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f, Data.Data.Data g) => Data.Data.Data (a, b, c, d, e, f, g)
instance Data.Data.Data Foreign.Ptr.IntPtr
instance Data.Data.Data Foreign.Ptr.WordPtr
instance Data.Data.Data t => Data.Data.Data (Data.Proxy.Proxy t)
instance (a Data.Type.Equality.~ b, Data.Data.Data a) => Data.Data.Data (a Data.Type.Equality.:~: b)
instance forall i j (a :: i) (b :: j). (Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable j, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, a GHC.Types.~~ b) => Data.Data.Data (a Data.Type.Equality.:~~: b)
instance (GHC.Types.Coercible a b, Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Type.Coercion.Coercion a b)
instance Data.Data.Data a => Data.Data.Data (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). (Data.Typeable.Internal.Typeable k, Data.Data.Data a, Data.Typeable.Internal.Typeable b) => Data.Data.Data (Data.Functor.Const.Const a b)
instance Data.Data.Data Data.Version.Version
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Dual a)
instance Data.Data.Data Data.Semigroup.Internal.All
instance Data.Data.Data Data.Semigroup.Internal.Any
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Sum a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Product a)
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.First a)
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.Last a)
instance (Data.Data.Data (f a), Data.Data.Data a, Data.Typeable.Internal.Typeable f) => Data.Data.Data (Data.Semigroup.Internal.Alt f a)
instance (Data.Data.Data (f a), Data.Data.Data a, Data.Typeable.Internal.Typeable f) => Data.Data.Data (Data.Monoid.Ap f a)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.U1 p)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.Par1 p)
instance (Data.Data.Data (f p), Data.Typeable.Internal.Typeable f, Data.Data.Data p) => Data.Data.Data (GHC.Generics.Rec1 f p)
instance (Data.Typeable.Internal.Typeable i, Data.Data.Data p, Data.Data.Data c) => Data.Data.Data (GHC.Generics.K1 i c p)
instance (Data.Data.Data p, Data.Data.Data (f p), Data.Typeable.Internal.Typeable c, Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable f) => Data.Data.Data (GHC.Generics.M1 i c f p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f p), Data.Data.Data (g p)) => Data.Data.Data ((GHC.Generics.:+:) f g p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f (g p))) => Data.Data.Data ((GHC.Generics.:.:) f g p)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.V1 p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f p), Data.Data.Data (g p)) => Data.Data.Data ((GHC.Generics.:*:) f g p)
instance Data.Data.Data GHC.Generics.Fixity
instance Data.Data.Data GHC.Generics.Associativity
instance Data.Data.Data GHC.Generics.SourceUnpackedness
instance Data.Data.Data GHC.Generics.SourceStrictness
instance Data.Data.Data GHC.Generics.DecidedStrictness
instance Data.Data.Data a => Data.Data.Data (Data.Ord.Down a)
instance Data.Data.Data GHC.Types.Char
instance Data.Data.Data GHC.Types.Float
instance Data.Data.Data GHC.Types.Double
instance Data.Data.Data GHC.Types.Int
instance Data.Data.Data GHC.Integer.Type.Integer
instance Data.Data.Data GHC.Natural.Natural
instance Data.Data.Data GHC.Int.Int8
instance Data.Data.Data GHC.Int.Int16
instance Data.Data.Data GHC.Int.Int32
instance Data.Data.Data GHC.Int.Int64
instance Data.Data.Data GHC.Types.Word
instance Data.Data.Data GHC.Word.Word8
instance Data.Data.Data GHC.Word.Word16
instance Data.Data.Data GHC.Word.Word32
instance Data.Data.Data GHC.Word.Word64
instance (Data.Data.Data a, GHC.Real.Integral a) => Data.Data.Data (GHC.Real.Ratio a)
instance Data.Data.Data a => Data.Data.Data [a]
instance Data.Data.Data a => Data.Data.Data (GHC.Ptr.Ptr a)
instance Data.Data.Data a => Data.Data.Data (GHC.ForeignPtr.ForeignPtr a)
instance (Data.Data.Data a, Data.Data.Data b, GHC.Arr.Ix a) => Data.Data.Data (GHC.Arr.Array a b)
instance GHC.Show.Show Data.Data.Constr
instance GHC.Classes.Eq Data.Data.Constr
module GHC.Exts
data Int
I# :: Int# -> Int
data Word
W# :: Word# -> Word
data Float
F# :: Float# -> Float
data Double
D# :: Double# -> Double
data Char
C# :: Char# -> Char
data Ptr a
Ptr :: Addr# -> Ptr a
data FunPtr a
FunPtr :: Addr# -> FunPtr a
maxTupleSize :: Int
seq :: () => a -> b -> b
realWorld# :: State# RealWorld
void# :: Void#
unsafeCoerce# :: () => a -> b
nullAddr# :: Addr#
magicDict :: () => a
proxy# :: () => Proxy# a
data Addr# :: TYPE AddrRep
data Array# (a :: Type) :: Type -> TYPE UnliftedRep
data ByteArray# :: TYPE UnliftedRep
data Char# :: TYPE WordRep
data Double# :: TYPE DoubleRep
data Float# :: TYPE FloatRep
data Int# :: TYPE IntRep
data Int32# :: TYPE IntRep
data Int64# :: TYPE Int64Rep
data Weak# (a :: Type) :: Type -> TYPE UnliftedRep
data MutableArray# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data MutableByteArray# (a :: Type) :: Type -> TYPE UnliftedRep
data MVar# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data RealWorld :: Type
data StablePtr# (a :: Type) :: Type -> TYPE AddrRep
data ArrayArray# :: TYPE UnliftedRep
data MutableArrayArray# (a :: Type) :: Type -> TYPE UnliftedRep
data State# (a :: Type) :: Type -> TYPE TupleRep ([] :: [RuntimeRep])
data StableName# (a :: Type) :: Type -> TYPE UnliftedRep
data MutVar# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data Void# :: TYPE TupleRep ([] :: [RuntimeRep])
data Word# :: TYPE WordRep
data Word32# :: TYPE WordRep
data Word64# :: TYPE Word64Rep
data ThreadId# :: TYPE UnliftedRep
data BCO# :: TYPE UnliftedRep
data TVar# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data Compact# :: TYPE UnliftedRep
data Proxy# :: forall k0. () => k0 -> TYPE TupleRep ([] :: [RuntimeRep])
data SmallArray# (a :: Type) :: Type -> TYPE UnliftedRep
data SmallMutableArray# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data Int8X16# :: TYPE VecRep Vec16 Int8ElemRep
data Int16X8# :: TYPE VecRep Vec8 Int16ElemRep
data Int32X4# :: TYPE VecRep Vec4 Int32ElemRep
data Int64X2# :: TYPE VecRep Vec2 Int64ElemRep
data Int8X32# :: TYPE VecRep Vec32 Int8ElemRep
data Int16X16# :: TYPE VecRep Vec16 Int16ElemRep
data Int32X8# :: TYPE VecRep Vec8 Int32ElemRep
data Int64X4# :: TYPE VecRep Vec4 Int64ElemRep
data Int8X64# :: TYPE VecRep Vec64 Int8ElemRep
data Int16X32# :: TYPE VecRep Vec32 Int16ElemRep
data Int32X16# :: TYPE VecRep Vec16 Int32ElemRep
data Int64X8# :: TYPE VecRep Vec8 Int64ElemRep
data Word8X16# :: TYPE VecRep Vec16 Word8ElemRep
data Word16X8# :: TYPE VecRep Vec8 Word16ElemRep
data Word32X4# :: TYPE VecRep Vec4 Word32ElemRep
data Word64X2# :: TYPE VecRep Vec2 Word64ElemRep
data Word8X32# :: TYPE VecRep Vec32 Word8ElemRep
data Word16X16# :: TYPE VecRep Vec16 Word16ElemRep
data Word32X8# :: TYPE VecRep Vec8 Word32ElemRep
data Word64X4# :: TYPE VecRep Vec4 Word64ElemRep
data Word8X64# :: TYPE VecRep Vec64 Word8ElemRep
data Word16X32# :: TYPE VecRep Vec32 Word16ElemRep
data Word32X16# :: TYPE VecRep Vec16 Word32ElemRep
data Word64X8# :: TYPE VecRep Vec8 Word64ElemRep
data FloatX4# :: TYPE VecRep Vec4 FloatElemRep
data DoubleX2# :: TYPE VecRep Vec2 DoubleElemRep
data FloatX8# :: TYPE VecRep Vec8 FloatElemRep
data DoubleX4# :: TYPE VecRep Vec4 DoubleElemRep
data FloatX16# :: TYPE VecRep Vec16 FloatElemRep
data DoubleX8# :: TYPE VecRep Vec8 DoubleElemRep
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
(-#) :: Int# -> Int# -> Int#
infixl 6 -#
(*#) :: Int# -> Int# -> Int#
infixl 7 *#
mulIntMayOflo# :: Int# -> Int# -> Int#
quotInt# :: Int# -> Int# -> Int#
remInt# :: Int# -> Int# -> Int#
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#
addIntC# :: Int# -> Int# -> (# Int#, Int# #)
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
infix 4 >#
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRL# :: Int# -> Int# -> Int#
plusWord# :: Word# -> Word# -> Word#
addWordC# :: Word# -> Word# -> (# Word#, Int# #)
subWordC# :: Word# -> Word# -> (# Word#, Int# #)
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#
popCnt8# :: Word# -> Word#
popCnt16# :: Word# -> Word#
popCnt32# :: Word# -> Word#
popCnt64# :: Word# -> Word#
popCnt# :: Word# -> Word#
pdep8# :: Word# -> Word# -> Word#
pdep16# :: Word# -> Word# -> Word#
pdep32# :: Word# -> Word# -> Word#
pdep64# :: Word# -> Word# -> Word#
pdep# :: Word# -> Word# -> Word#
pext8# :: Word# -> Word# -> Word#
pext16# :: Word# -> Word# -> Word#
pext32# :: Word# -> Word# -> Word#
pext64# :: Word# -> Word# -> Word#
pext# :: Word# -> Word# -> Word#
clz8# :: Word# -> Word#
clz16# :: Word# -> Word#
clz32# :: Word# -> Word#
clz64# :: Word# -> Word#
clz# :: Word# -> Word#
ctz8# :: Word# -> Word#
ctz16# :: Word# -> Word#
ctz32# :: Word# -> Word#
ctz64# :: Word# -> Word#
ctz# :: Word# -> Word#
byteSwap16# :: Word# -> Word#
byteSwap32# :: Word# -> Word#
byteSwap64# :: Word# -> Word#
byteSwap# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
(>##) :: Double# -> Double# -> Int#
infix 4 >##
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(*##) :: Double# -> Double# -> Double#
infixl 7 *##
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
logDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
(**##) :: Double# -> Double# -> Double#
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
decodeDouble_Int64# :: Double# -> (# Int#, Int# #)
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
logFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
newArray# :: () => Int# -> a -> State# d -> (# State# d, MutableArray# d a #)
sameMutableArray# :: () => MutableArray# d a -> MutableArray# d a -> Int#
readArray# :: () => MutableArray# d a -> Int# -> State# d -> (# State# d, a #)
writeArray# :: () => MutableArray# d a -> Int# -> a -> State# d -> State# d
sizeofArray# :: () => Array# a -> Int#
sizeofMutableArray# :: () => MutableArray# d a -> Int#
indexArray# :: () => Array# a -> Int# -> (# a #)
unsafeFreezeArray# :: () => MutableArray# d a -> State# d -> (# State# d, Array# a #)
unsafeThawArray# :: () => Array# a -> State# d -> (# State# d, MutableArray# d a #)
copyArray# :: () => Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
copyMutableArray# :: () => MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
cloneArray# :: () => Array# a -> Int# -> Int# -> Array# a
cloneMutableArray# :: () => MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
freezeArray# :: () => MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)
thawArray# :: () => Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
casArray# :: () => MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
newSmallArray# :: () => Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)
sameSmallMutableArray# :: () => SmallMutableArray# d a -> SmallMutableArray# d a -> Int#
readSmallArray# :: () => SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)
writeSmallArray# :: () => SmallMutableArray# d a -> Int# -> a -> State# d -> State# d
sizeofSmallArray# :: () => SmallArray# a -> Int#
sizeofSmallMutableArray# :: () => SmallMutableArray# d a -> Int#
indexSmallArray# :: () => SmallArray# a -> Int# -> (# a #)
unsafeFreezeSmallArray# :: () => SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)
unsafeThawSmallArray# :: () => SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)
copySmallArray# :: () => SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
copySmallMutableArray# :: () => SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
cloneSmallArray# :: () => SmallArray# a -> Int# -> Int# -> SmallArray# a
cloneSmallMutableArray# :: () => SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
freezeSmallArray# :: () => SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)
thawSmallArray# :: () => SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
casSmallArray# :: () => SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
newByteArray# :: () => Int# -> State# d -> (# State# d, MutableByteArray# d #)
newPinnedByteArray# :: () => Int# -> State# d -> (# State# d, MutableByteArray# d #)
newAlignedPinnedByteArray# :: () => Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
isMutableByteArrayPinned# :: () => MutableByteArray# d -> Int#
isByteArrayPinned# :: ByteArray# -> Int#
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: () => MutableByteArray# d -> MutableByteArray# d -> Int#
shrinkMutableByteArray# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
resizeMutableByteArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
unsafeFreezeByteArray# :: () => MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)
sizeofByteArray# :: ByteArray# -> Int#
sizeofMutableByteArray# :: () => MutableByteArray# d -> Int#
getSizeofMutableByteArray# :: () => MutableByteArray# d -> State# d -> (# State# d, Int# #)
indexCharArray# :: ByteArray# -> Int# -> Char#
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: () => ByteArray# -> Int# -> StablePtr# a
indexInt8Array# :: ByteArray# -> Int# -> Int#
indexInt16Array# :: ByteArray# -> Int# -> Int#
indexInt32Array# :: ByteArray# -> Int# -> Int#
indexInt64Array# :: ByteArray# -> Int# -> Int#
indexWord8Array# :: ByteArray# -> Int# -> Word#
indexWord16Array# :: ByteArray# -> Int# -> Word#
indexWord32Array# :: ByteArray# -> Int# -> Word#
indexWord64Array# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
indexWord8ArrayAsStablePtr# :: () => ByteArray# -> Int# -> StablePtr# a
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
readCharArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
readWideCharArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
readIntArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWordArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readAddrArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
readFloatArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
readDoubleArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
readStablePtrArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
readInt8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readInt16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readInt32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readInt64Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord64Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord8ArrayAsChar# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
readWord8ArrayAsWideChar# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
readWord8ArrayAsAddr# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
readWord8ArrayAsFloat# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
readWord8ArrayAsDouble# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
readWord8ArrayAsStablePtr# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
readWord8ArrayAsInt16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8ArrayAsInt32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8ArrayAsInt64# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8ArrayAsInt# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8ArrayAsWord16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord8ArrayAsWord32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord8ArrayAsWord64# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord8ArrayAsWord# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
writeCharArray# :: () => MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
writeWideCharArray# :: () => MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
writeIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWordArray# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeAddrArray# :: () => MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
writeFloatArray# :: () => MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
writeDoubleArray# :: () => MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
writeStablePtrArray# :: () => MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
writeInt8Array# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeInt16Array# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeInt32Array# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeInt64Array# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8Array# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord16Array# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord32Array# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord64Array# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord8ArrayAsChar# :: () => MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
writeWord8ArrayAsWideChar# :: () => MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
writeWord8ArrayAsAddr# :: () => MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
writeWord8ArrayAsFloat# :: () => MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
writeWord8ArrayAsDouble# :: () => MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
writeWord8ArrayAsStablePtr# :: () => MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
writeWord8ArrayAsInt16# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8ArrayAsInt32# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8ArrayAsInt64# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8ArrayAsInt# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8ArrayAsWord16# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord8ArrayAsWord32# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord8ArrayAsWord64# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord8ArrayAsWord# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
copyByteArray# :: () => ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
copyMutableByteArray# :: () => MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
copyByteArrayToAddr# :: () => ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d
copyMutableByteArrayToAddr# :: () => MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d
copyAddrToByteArray# :: () => Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
setByteArray# :: () => MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d
atomicReadIntArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
atomicWriteIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
casIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)
fetchAddIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
fetchSubIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
fetchAndIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
fetchNandIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
fetchOrIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
fetchXorIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
newArrayArray# :: () => Int# -> State# d -> (# State# d, MutableArrayArray# d #)
sameMutableArrayArray# :: () => MutableArrayArray# d -> MutableArrayArray# d -> Int#
unsafeFreezeArrayArray# :: () => MutableArrayArray# d -> State# d -> (# State# d, ArrayArray# #)
sizeofArrayArray# :: ArrayArray# -> Int#
sizeofMutableArrayArray# :: () => MutableArrayArray# d -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: () => MutableArrayArray# d -> Int# -> State# d -> (# State# d, ByteArray# #)
readMutableByteArrayArray# :: () => MutableArrayArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
readArrayArrayArray# :: () => MutableArrayArray# d -> Int# -> State# d -> (# State# d, ArrayArray# #)
readMutableArrayArrayArray# :: () => MutableArrayArray# d -> Int# -> State# d -> (# State# d, MutableArrayArray# d #)
writeByteArrayArray# :: () => MutableArrayArray# d -> Int# -> ByteArray# -> State# d -> State# d
writeMutableByteArrayArray# :: () => MutableArrayArray# d -> Int# -> MutableByteArray# d -> State# d -> State# d
writeArrayArrayArray# :: () => MutableArrayArray# d -> Int# -> ArrayArray# -> State# d -> State# d
writeMutableArrayArrayArray# :: () => MutableArrayArray# d -> Int# -> MutableArrayArray# d -> State# d -> State# d
copyArrayArray# :: () => ArrayArray# -> Int# -> MutableArrayArray# d -> Int# -> Int# -> State# d -> State# d
copyMutableArrayArray# :: () => MutableArrayArray# d -> Int# -> MutableArrayArray# d -> Int# -> Int# -> State# d -> State# d
plusAddr# :: Addr# -> Int# -> Addr#
minusAddr# :: Addr# -> Addr# -> Int#
remAddr# :: Addr# -> Int# -> Int#
addr2Int# :: Addr# -> Int#
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#
indexCharOffAddr# :: Addr# -> Int# -> Char#
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: () => Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word#
readCharOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Char# #)
readWideCharOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Char# #)
readIntOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readWordOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
readAddrOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Addr# #)
readFloatOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Float# #)
readDoubleOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Double# #)
readStablePtrOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)
readInt8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readInt16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readInt32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readInt64OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readWord8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
readWord16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
readWord32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
readWord64OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
writeCharOffAddr# :: () => Addr# -> Int# -> Char# -> State# d -> State# d
writeWideCharOffAddr# :: () => Addr# -> Int# -> Char# -> State# d -> State# d
writeIntOffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeWordOffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
writeAddrOffAddr# :: () => Addr# -> Int# -> Addr# -> State# d -> State# d
writeFloatOffAddr# :: () => Addr# -> Int# -> Float# -> State# d -> State# d
writeDoubleOffAddr# :: () => Addr# -> Int# -> Double# -> State# d -> State# d
writeStablePtrOffAddr# :: () => Addr# -> Int# -> StablePtr# a -> State# d -> State# d
writeInt8OffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeInt16OffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeInt32OffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeInt64OffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeWord8OffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
writeWord16OffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
writeWord32OffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
writeWord64OffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
newMutVar# :: () => a -> State# d -> (# State# d, MutVar# d a #)
readMutVar# :: () => MutVar# d a -> State# d -> (# State# d, a #)
writeMutVar# :: () => MutVar# d a -> a -> State# d -> State# d
sameMutVar# :: () => MutVar# d a -> MutVar# d a -> Int#
atomicModifyMutVar# :: () => MutVar# d a -> (a -> b) -> State# d -> (# State# d, c #)
casMutVar# :: () => MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)
catch# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
raise# :: () => b -> a
raiseIO# :: () => a -> State# RealWorld -> (# State# RealWorld, b #)
maskAsyncExceptions# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
maskUninterruptible# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
unmaskAsyncExceptions# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
atomically# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
retry# :: () => State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
newTVar# :: () => a -> State# d -> (# State# d, TVar# d a #)
readTVar# :: () => TVar# d a -> State# d -> (# State# d, a #)
readTVarIO# :: () => TVar# d a -> State# d -> (# State# d, a #)
writeTVar# :: () => TVar# d a -> a -> State# d -> State# d
sameTVar# :: () => TVar# d a -> TVar# d a -> Int#
newMVar# :: () => State# d -> (# State# d, MVar# d a #)
takeMVar# :: () => MVar# d a -> State# d -> (# State# d, a #)
tryTakeMVar# :: () => MVar# d a -> State# d -> (# State# d, Int#, a #)
putMVar# :: () => MVar# d a -> a -> State# d -> State# d
tryPutMVar# :: () => MVar# d a -> a -> State# d -> (# State# d, Int# #)
readMVar# :: () => MVar# d a -> State# d -> (# State# d, a #)
tryReadMVar# :: () => MVar# d a -> State# d -> (# State# d, Int#, a #)
sameMVar# :: () => MVar# d a -> MVar# d a -> Int#
isEmptyMVar# :: () => MVar# d a -> State# d -> (# State# d, Int# #)
delay# :: () => Int# -> State# d -> State# d
waitRead# :: () => Int# -> State# d -> State# d
waitWrite# :: () => Int# -> State# d -> State# d
fork# :: () => a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: () => Int# -> a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: () => ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: () => State# d -> State# d
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
mkWeak# :: () => a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: () => a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)
addCFinalizerToWeak# :: () => Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: () => Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)
finalizeWeak# :: () => Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: () => a -> State# RealWorld -> State# RealWorld
makeStablePtr# :: () => a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
deRefStablePtr# :: () => StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
eqStablePtr# :: () => StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: () => a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
eqStableName# :: () => StableName# a -> StableName# b -> Int#
stableNameToInt# :: () => StableName# a -> Int#
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
compactContains# :: () => Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactContainsAny# :: () => a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
compactAdd# :: () => Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactAddWithSharing# :: () => Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
reallyUnsafePtrEquality# :: () => a -> a -> Int#
par# :: () => a -> Int#
spark# :: () => a -> State# d -> (# State# d, a #)
seq# :: () => a -> State# d -> (# State# d, a #)
getSpark# :: () => State# d -> (# State# d, Int#, a #)
numSparks# :: () => State# d -> (# State# d, Int# #)
dataToTag# :: () => a -> Int#
tagToEnum# :: () => Int# -> a
addrToAny# :: () => Addr# -> (# a #)
anyToAddr# :: () => a -> State# RealWorld -> (# State# RealWorld, Addr# #)
mkApUpd0# :: () => BCO# -> (# a #)
newBCO# :: () => ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO# #)
unpackClosure# :: () => a -> (# Addr#, ByteArray#, Array# b #)
getApStackVal# :: () => a -> Int# -> (# Int#, b #)
getCCSOf# :: () => a -> State# d -> (# State# d, Addr# #)
getCurrentCCS# :: () => a -> State# d -> (# State# d, Addr# #)
clearCCS# :: () => (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)
traceEvent# :: () => Addr# -> State# d -> State# d
traceMarker# :: () => Addr# -> State# d -> State# d
getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int# #)
setThreadAllocationCounter# :: Int# -> State# RealWorld -> State# RealWorld
broadcastInt8X16# :: Int# -> Int8X16#
broadcastInt16X8# :: Int# -> Int16X8#
broadcastInt32X4# :: Int# -> Int32X4#
broadcastInt64X2# :: Int# -> Int64X2#
broadcastInt8X32# :: Int# -> Int8X32#
broadcastInt16X16# :: Int# -> Int16X16#
broadcastInt32X8# :: Int# -> Int32X8#
broadcastInt64X4# :: Int# -> Int64X4#
broadcastInt8X64# :: Int# -> Int8X64#
broadcastInt16X32# :: Int# -> Int16X32#
broadcastInt32X16# :: Int# -> Int32X16#
broadcastInt64X8# :: Int# -> Int64X8#
broadcastWord8X16# :: Word# -> Word8X16#
broadcastWord16X8# :: Word# -> Word16X8#
broadcastWord32X4# :: Word# -> Word32X4#
broadcastWord64X2# :: Word# -> Word64X2#
broadcastWord8X32# :: Word# -> Word8X32#
broadcastWord16X16# :: Word# -> Word16X16#
broadcastWord32X8# :: Word# -> Word32X8#
broadcastWord64X4# :: Word# -> Word64X4#
broadcastWord8X64# :: Word# -> Word8X64#
broadcastWord16X32# :: Word# -> Word16X32#
broadcastWord32X16# :: Word# -> Word32X16#
broadcastWord64X8# :: Word# -> Word64X8#
broadcastFloatX4# :: Float# -> FloatX4#
broadcastDoubleX2# :: Double# -> DoubleX2#
broadcastFloatX8# :: Float# -> FloatX8#
broadcastDoubleX4# :: Double# -> DoubleX4#
broadcastFloatX16# :: Float# -> FloatX16#
broadcastDoubleX8# :: Double# -> DoubleX8#
packInt8X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#
packInt16X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#
packInt32X4# :: (# Int#, Int#, Int#, Int# #) -> Int32X4#
packInt64X2# :: (# Int#, Int# #) -> Int64X2#
packInt8X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#
packInt16X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#
packInt32X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#
packInt64X4# :: (# Int#, Int#, Int#, Int# #) -> Int64X4#
packInt8X64# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#
packInt16X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#
packInt32X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#
packInt64X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#
packWord8X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X16#
packWord16X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X8#
packWord32X4# :: (# Word#, Word#, Word#, Word# #) -> Word32X4#
packWord64X2# :: (# Word#, Word# #) -> Word64X2#
packWord8X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X32#
packWord16X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X16#
packWord32X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X8#
packWord64X4# :: (# Word#, Word#, Word#, Word# #) -> Word64X4#
packWord8X64# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X64#
packWord16X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X32#
packWord32X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X16#
packWord64X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word64X8#
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#
unpackInt8X16# :: Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackInt16X8# :: Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackInt32X4# :: Int32X4# -> (# Int#, Int#, Int#, Int# #)
unpackInt64X2# :: Int64X2# -> (# Int#, Int# #)
unpackInt8X32# :: Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackInt16X16# :: Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackInt32X8# :: Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackInt64X4# :: Int64X4# -> (# Int#, Int#, Int#, Int# #)
unpackInt8X64# :: Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackInt16X32# :: Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackInt32X16# :: Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackInt64X8# :: Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)
unpackWord8X16# :: Word8X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackWord16X8# :: Word16X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackWord32X4# :: Word32X4# -> (# Word#, Word#, Word#, Word# #)
unpackWord64X2# :: Word64X2# -> (# Word#, Word# #)
unpackWord8X32# :: Word8X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackWord16X16# :: Word16X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackWord32X8# :: Word32X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackWord64X4# :: Word64X4# -> (# Word#, Word#, Word#, Word# #)
unpackWord8X64# :: Word8X64# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackWord16X32# :: Word16X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackWord32X16# :: Word32X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackWord64X8# :: Word64X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)
insertInt8X16# :: Int8X16# -> Int# -> Int# -> Int8X16#
insertInt16X8# :: Int16X8# -> Int# -> Int# -> Int16X8#
insertInt32X4# :: Int32X4# -> Int# -> Int# -> Int32X4#
insertInt64X2# :: Int64X2# -> Int# -> Int# -> Int64X2#
insertInt8X32# :: Int8X32# -> Int# -> Int# -> Int8X32#
insertInt16X16# :: Int16X16# -> Int# -> Int# -> Int16X16#
insertInt32X8# :: Int32X8# -> Int# -> Int# -> Int32X8#
insertInt64X4# :: Int64X4# -> Int# -> Int# -> Int64X4#
insertInt8X64# :: Int8X64# -> Int# -> Int# -> Int8X64#
insertInt16X32# :: Int16X32# -> Int# -> Int# -> Int16X32#
insertInt32X16# :: Int32X16# -> Int# -> Int# -> Int32X16#
insertInt64X8# :: Int64X8# -> Int# -> Int# -> Int64X8#
insertWord8X16# :: Word8X16# -> Word# -> Int# -> Word8X16#
insertWord16X8# :: Word16X8# -> Word# -> Int# -> Word16X8#
insertWord32X4# :: Word32X4# -> Word# -> Int# -> Word32X4#
insertWord64X2# :: Word64X2# -> Word# -> Int# -> Word64X2#
insertWord8X32# :: Word8X32# -> Word# -> Int# -> Word8X32#
insertWord16X16# :: Word16X16# -> Word# -> Int# -> Word16X16#
insertWord32X8# :: Word32X8# -> Word# -> Int# -> Word32X8#
insertWord64X4# :: Word64X4# -> Word# -> Int# -> Word64X4#
insertWord8X64# :: Word8X64# -> Word# -> Int# -> Word8X64#
insertWord16X32# :: Word16X32# -> Word# -> Int# -> Word16X32#
insertWord32X16# :: Word32X16# -> Word# -> Int# -> Word32X16#
insertWord64X8# :: Word64X8# -> Word# -> Int# -> Word64X8#
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
negateInt8X16# :: Int8X16# -> Int8X16#
negateInt16X8# :: Int16X8# -> Int16X8#
negateInt32X4# :: Int32X4# -> Int32X4#
negateInt64X2# :: Int64X2# -> Int64X2#
negateInt8X32# :: Int8X32# -> Int8X32#
negateInt16X16# :: Int16X16# -> Int16X16#
negateInt32X8# :: Int32X8# -> Int32X8#
negateInt64X4# :: Int64X4# -> Int64X4#
negateInt8X64# :: Int8X64# -> Int8X64#
negateInt16X32# :: Int16X32# -> Int16X32#
negateInt32X16# :: Int32X16# -> Int32X16#
negateInt64X8# :: Int64X8# -> Int64X8#
negateFloatX4# :: FloatX4# -> FloatX4#
negateDoubleX2# :: DoubleX2# -> DoubleX2#
negateFloatX8# :: FloatX8# -> FloatX8#
negateDoubleX4# :: DoubleX4# -> DoubleX4#
negateFloatX16# :: FloatX16# -> FloatX16#
negateDoubleX8# :: DoubleX8# -> DoubleX8#
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#
readInt8X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
readInt16X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
readInt32X4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
readInt64X2Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
readInt8X32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
readInt16X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
readInt32X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
readInt64X4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
readInt8X64Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
readInt16X32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
readInt32X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
readInt64X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
readWord8X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
readWord16X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
readWord32X4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
readWord64X2Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
readWord8X32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
readWord16X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
readWord32X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
readWord64X4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
readWord8X64Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
readWord16X32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
readWord32X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
readWord64X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
readFloatX4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
readDoubleX2Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
readFloatX8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
readDoubleX4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
readFloatX16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
readDoubleX8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
writeInt8X16Array# :: () => MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
writeInt16X8Array# :: () => MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
writeInt32X4Array# :: () => MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
writeInt64X2Array# :: () => MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
writeInt8X32Array# :: () => MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
writeInt16X16Array# :: () => MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
writeInt32X8Array# :: () => MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
writeInt64X4Array# :: () => MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
writeInt8X64Array# :: () => MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
writeInt16X32Array# :: () => MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
writeInt32X16Array# :: () => MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
writeInt64X8Array# :: () => MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
writeWord8X16Array# :: () => MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
writeWord16X8Array# :: () => MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
writeWord32X4Array# :: () => MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
writeWord64X2Array# :: () => MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
writeWord8X32Array# :: () => MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
writeWord16X16Array# :: () => MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
writeWord32X8Array# :: () => MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
writeWord64X4Array# :: () => MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
writeWord8X64Array# :: () => MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
writeWord16X32Array# :: () => MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
writeWord32X16Array# :: () => MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
writeWord64X8Array# :: () => MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
writeFloatX4Array# :: () => MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
writeDoubleX2Array# :: () => MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
writeFloatX8Array# :: () => MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
writeDoubleX4Array# :: () => MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
writeFloatX16Array# :: () => MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
writeDoubleX8Array# :: () => MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#
readInt8X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
readInt16X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
readInt32X4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
readInt64X2OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
readInt8X32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
readInt16X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
readInt32X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
readInt64X4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
readInt8X64OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
readInt16X32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
readInt32X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
readInt64X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
readWord8X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
readWord16X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
readWord32X4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
readWord64X2OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
readWord8X32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
readWord16X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
readWord32X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
readWord64X4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
readWord8X64OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
readWord16X32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
readWord32X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
readWord64X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
readFloatX4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
readDoubleX2OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
readFloatX8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
readDoubleX4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
readFloatX16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
readDoubleX8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
writeInt8X16OffAddr# :: () => Addr# -> Int# -> Int8X16# -> State# d -> State# d
writeInt16X8OffAddr# :: () => Addr# -> Int# -> Int16X8# -> State# d -> State# d
writeInt32X4OffAddr# :: () => Addr# -> Int# -> Int32X4# -> State# d -> State# d
writeInt64X2OffAddr# :: () => Addr# -> Int# -> Int64X2# -> State# d -> State# d
writeInt8X32OffAddr# :: () => Addr# -> Int# -> Int8X32# -> State# d -> State# d
writeInt16X16OffAddr# :: () => Addr# -> Int# -> Int16X16# -> State# d -> State# d
writeInt32X8OffAddr# :: () => Addr# -> Int# -> Int32X8# -> State# d -> State# d
writeInt64X4OffAddr# :: () => Addr# -> Int# -> Int64X4# -> State# d -> State# d
writeInt8X64OffAddr# :: () => Addr# -> Int# -> Int8X64# -> State# d -> State# d
writeInt16X32OffAddr# :: () => Addr# -> Int# -> Int16X32# -> State# d -> State# d
writeInt32X16OffAddr# :: () => Addr# -> Int# -> Int32X16# -> State# d -> State# d
writeInt64X8OffAddr# :: () => Addr# -> Int# -> Int64X8# -> State# d -> State# d
writeWord8X16OffAddr# :: () => Addr# -> Int# -> Word8X16# -> State# d -> State# d
writeWord16X8OffAddr# :: () => Addr# -> Int# -> Word16X8# -> State# d -> State# d
writeWord32X4OffAddr# :: () => Addr# -> Int# -> Word32X4# -> State# d -> State# d
writeWord64X2OffAddr# :: () => Addr# -> Int# -> Word64X2# -> State# d -> State# d
writeWord8X32OffAddr# :: () => Addr# -> Int# -> Word8X32# -> State# d -> State# d
writeWord16X16OffAddr# :: () => Addr# -> Int# -> Word16X16# -> State# d -> State# d
writeWord32X8OffAddr# :: () => Addr# -> Int# -> Word32X8# -> State# d -> State# d
writeWord64X4OffAddr# :: () => Addr# -> Int# -> Word64X4# -> State# d -> State# d
writeWord8X64OffAddr# :: () => Addr# -> Int# -> Word8X64# -> State# d -> State# d
writeWord16X32OffAddr# :: () => Addr# -> Int# -> Word16X32# -> State# d -> State# d
writeWord32X16OffAddr# :: () => Addr# -> Int# -> Word32X16# -> State# d -> State# d
writeWord64X8OffAddr# :: () => Addr# -> Int# -> Word64X8# -> State# d -> State# d
writeFloatX4OffAddr# :: () => Addr# -> Int# -> FloatX4# -> State# d -> State# d
writeDoubleX2OffAddr# :: () => Addr# -> Int# -> DoubleX2# -> State# d -> State# d
writeFloatX8OffAddr# :: () => Addr# -> Int# -> FloatX8# -> State# d -> State# d
writeDoubleX4OffAddr# :: () => Addr# -> Int# -> DoubleX4# -> State# d -> State# d
writeFloatX16OffAddr# :: () => Addr# -> Int# -> FloatX16# -> State# d -> State# d
writeDoubleX8OffAddr# :: () => Addr# -> Int# -> DoubleX8# -> State# d -> State# d
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#
readInt8ArrayAsInt8X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
readInt16ArrayAsInt16X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
readInt32ArrayAsInt32X4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
readInt64ArrayAsInt64X2# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
readInt8ArrayAsInt8X32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
readInt16ArrayAsInt16X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
readInt32ArrayAsInt32X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
readInt64ArrayAsInt64X4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
readInt8ArrayAsInt8X64# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
readInt16ArrayAsInt16X32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
readInt32ArrayAsInt32X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
readInt64ArrayAsInt64X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
readWord8ArrayAsWord8X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
readWord16ArrayAsWord16X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
readWord32ArrayAsWord32X4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
readWord64ArrayAsWord64X2# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
readWord8ArrayAsWord8X32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
readWord16ArrayAsWord16X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
readWord32ArrayAsWord32X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
readWord64ArrayAsWord64X4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
readWord8ArrayAsWord8X64# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
readWord16ArrayAsWord16X32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
readWord32ArrayAsWord32X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
readWord64ArrayAsWord64X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
readFloatArrayAsFloatX4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
readDoubleArrayAsDoubleX2# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
readFloatArrayAsFloatX8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
readDoubleArrayAsDoubleX4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
readFloatArrayAsFloatX16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
readDoubleArrayAsDoubleX8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
writeInt8ArrayAsInt8X16# :: () => MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
writeInt16ArrayAsInt16X8# :: () => MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
writeInt32ArrayAsInt32X4# :: () => MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
writeInt64ArrayAsInt64X2# :: () => MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
writeInt8ArrayAsInt8X32# :: () => MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
writeInt16ArrayAsInt16X16# :: () => MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
writeInt32ArrayAsInt32X8# :: () => MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
writeInt64ArrayAsInt64X4# :: () => MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
writeInt8ArrayAsInt8X64# :: () => MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
writeInt16ArrayAsInt16X32# :: () => MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
writeInt32ArrayAsInt32X16# :: () => MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
writeInt64ArrayAsInt64X8# :: () => MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
writeWord8ArrayAsWord8X16# :: () => MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
writeWord16ArrayAsWord16X8# :: () => MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
writeWord32ArrayAsWord32X4# :: () => MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
writeWord64ArrayAsWord64X2# :: () => MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
writeWord8ArrayAsWord8X32# :: () => MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
writeWord16ArrayAsWord16X16# :: () => MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
writeWord32ArrayAsWord32X8# :: () => MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
writeWord64ArrayAsWord64X4# :: () => MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
writeWord8ArrayAsWord8X64# :: () => MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
writeWord16ArrayAsWord16X32# :: () => MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
writeWord32ArrayAsWord32X16# :: () => MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
writeWord64ArrayAsWord64X8# :: () => MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
writeFloatArrayAsFloatX4# :: () => MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
writeDoubleArrayAsDoubleX2# :: () => MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
writeFloatArrayAsFloatX8# :: () => MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
writeDoubleArrayAsDoubleX4# :: () => MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
writeFloatArrayAsFloatX16# :: () => MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
writeDoubleArrayAsDoubleX8# :: () => MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#
readInt8OffAddrAsInt8X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
readInt16OffAddrAsInt16X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
readInt32OffAddrAsInt32X4# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
readInt64OffAddrAsInt64X2# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
readInt8OffAddrAsInt8X32# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
readInt16OffAddrAsInt16X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
readInt32OffAddrAsInt32X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
readInt64OffAddrAsInt64X4# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
readInt8OffAddrAsInt8X64# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
readInt16OffAddrAsInt16X32# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
readInt32OffAddrAsInt32X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
readInt64OffAddrAsInt64X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
readWord8OffAddrAsWord8X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
readWord16OffAddrAsWord16X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
readWord32OffAddrAsWord32X4# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
readWord64OffAddrAsWord64X2# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
readWord8OffAddrAsWord8X32# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
readWord16OffAddrAsWord16X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
readWord32OffAddrAsWord32X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
readWord64OffAddrAsWord64X4# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
readWord8OffAddrAsWord8X64# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
readWord16OffAddrAsWord16X32# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
readWord32OffAddrAsWord32X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
readWord64OffAddrAsWord64X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
readFloatOffAddrAsFloatX4# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
readDoubleOffAddrAsDoubleX2# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
readFloatOffAddrAsFloatX8# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
readDoubleOffAddrAsDoubleX4# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
readFloatOffAddrAsFloatX16# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
readDoubleOffAddrAsDoubleX8# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
writeInt8OffAddrAsInt8X16# :: () => Addr# -> Int# -> Int8X16# -> State# d -> State# d
writeInt16OffAddrAsInt16X8# :: () => Addr# -> Int# -> Int16X8# -> State# d -> State# d
writeInt32OffAddrAsInt32X4# :: () => Addr# -> Int# -> Int32X4# -> State# d -> State# d
writeInt64OffAddrAsInt64X2# :: () => Addr# -> Int# -> Int64X2# -> State# d -> State# d
writeInt8OffAddrAsInt8X32# :: () => Addr# -> Int# -> Int8X32# -> State# d -> State# d
writeInt16OffAddrAsInt16X16# :: () => Addr# -> Int# -> Int16X16# -> State# d -> State# d
writeInt32OffAddrAsInt32X8# :: () => Addr# -> Int# -> Int32X8# -> State# d -> State# d
writeInt64OffAddrAsInt64X4# :: () => Addr# -> Int# -> Int64X4# -> State# d -> State# d
writeInt8OffAddrAsInt8X64# :: () => Addr# -> Int# -> Int8X64# -> State# d -> State# d
writeInt16OffAddrAsInt16X32# :: () => Addr# -> Int# -> Int16X32# -> State# d -> State# d
writeInt32OffAddrAsInt32X16# :: () => Addr# -> Int# -> Int32X16# -> State# d -> State# d
writeInt64OffAddrAsInt64X8# :: () => Addr# -> Int# -> Int64X8# -> State# d -> State# d
writeWord8OffAddrAsWord8X16# :: () => Addr# -> Int# -> Word8X16# -> State# d -> State# d
writeWord16OffAddrAsWord16X8# :: () => Addr# -> Int# -> Word16X8# -> State# d -> State# d
writeWord32OffAddrAsWord32X4# :: () => Addr# -> Int# -> Word32X4# -> State# d -> State# d
writeWord64OffAddrAsWord64X2# :: () => Addr# -> Int# -> Word64X2# -> State# d -> State# d
writeWord8OffAddrAsWord8X32# :: () => Addr# -> Int# -> Word8X32# -> State# d -> State# d
writeWord16OffAddrAsWord16X16# :: () => Addr# -> Int# -> Word16X16# -> State# d -> State# d
writeWord32OffAddrAsWord32X8# :: () => Addr# -> Int# -> Word32X8# -> State# d -> State# d
writeWord64OffAddrAsWord64X4# :: () => Addr# -> Int# -> Word64X4# -> State# d -> State# d
writeWord8OffAddrAsWord8X64# :: () => Addr# -> Int# -> Word8X64# -> State# d -> State# d
writeWord16OffAddrAsWord16X32# :: () => Addr# -> Int# -> Word16X32# -> State# d -> State# d
writeWord32OffAddrAsWord32X16# :: () => Addr# -> Int# -> Word32X16# -> State# d -> State# d
writeWord64OffAddrAsWord64X8# :: () => Addr# -> Int# -> Word64X8# -> State# d -> State# d
writeFloatOffAddrAsFloatX4# :: () => Addr# -> Int# -> FloatX4# -> State# d -> State# d
writeDoubleOffAddrAsDoubleX2# :: () => Addr# -> Int# -> DoubleX2# -> State# d -> State# d
writeFloatOffAddrAsFloatX8# :: () => Addr# -> Int# -> FloatX8# -> State# d -> State# d
writeDoubleOffAddrAsDoubleX4# :: () => Addr# -> Int# -> DoubleX4# -> State# d -> State# d
writeFloatOffAddrAsFloatX16# :: () => Addr# -> Int# -> FloatX16# -> State# d -> State# d
writeDoubleOffAddrAsDoubleX8# :: () => Addr# -> Int# -> DoubleX8# -> State# d -> State# d
prefetchByteArray3# :: () => ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray3# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr3# :: () => Addr# -> Int# -> State# d -> State# d
prefetchValue3# :: () => a -> State# d -> State# d
prefetchByteArray2# :: () => ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray2# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr2# :: () => Addr# -> Int# -> State# d -> State# d
prefetchValue2# :: () => a -> State# d -> State# d
prefetchByteArray1# :: () => ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray1# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr1# :: () => Addr# -> Int# -> State# d -> State# d
prefetchValue1# :: () => a -> State# d -> State# d
prefetchByteArray0# :: () => ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray0# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr0# :: () => Addr# -> Int# -> State# d -> State# d
prefetchValue0# :: () => a -> State# d -> State# d
shiftL# :: Word# -> Int# -> Word#
shiftRL# :: Word# -> Int# -> Word#
iShiftL# :: Int# -> Int# -> Int#
iShiftRA# :: Int# -> Int# -> Int#
iShiftRL# :: Int# -> Int# -> Int#
uncheckedShiftL64# :: Word# -> Int# -> Word#
uncheckedShiftRL64# :: Word# -> Int# -> Word#
uncheckedIShiftL64# :: Int# -> Int# -> Int#
uncheckedIShiftRA64# :: Int# -> Int# -> Int#
isTrue# :: Int# -> Bool
build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
augment :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
class IsString a
fromString :: IsString a => String -> a
breakpoint :: a -> a
breakpointCond :: Bool -> a -> a
lazy :: () => a -> a
inline :: () => a -> a
oneShot :: () => (a -> b) -> a -> b
runRW# :: () => (State# RealWorld -> o) -> o
coerce :: Coercible a b => a -> b
class a ~R# b => Coercible (a :: k0) (b :: k0)
class a ~# b => (~~) (a :: k0) (b :: k1)
data TYPE (a :: RuntimeRep) :: RuntimeRep -> Type
data RuntimeRep
VecRep :: VecCount -> VecElem -> RuntimeRep
TupleRep :: [RuntimeRep] -> RuntimeRep
SumRep :: [RuntimeRep] -> RuntimeRep
LiftedRep :: RuntimeRep
UnliftedRep :: RuntimeRep
IntRep :: RuntimeRep
WordRep :: RuntimeRep
Int64Rep :: RuntimeRep
Word64Rep :: RuntimeRep
AddrRep :: RuntimeRep
FloatRep :: RuntimeRep
DoubleRep :: RuntimeRep
data VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount
data VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem
newtype Down a
Down :: a -> Down a
groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
sortWith :: Ord b => (a -> b) -> [a] -> [a]
the :: Eq a => [a] -> a
traceEvent :: String -> IO ()
data SpecConstrAnnotation
NoSpecConstr :: SpecConstrAnnotation
ForceSpecConstr :: SpecConstrAnnotation
currentCallStack :: IO [String]
data Constraint
type family Any :: k0
class IsList l where {

    type family Item l;
}
fromList :: IsList l => [Item l] -> l
fromListN :: IsList l => Int -> [Item l] -> l
toList :: IsList l => l -> [Item l]
instance GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation
instance Data.Data.Data GHC.Exts.SpecConstrAnnotation
instance GHC.Exts.IsList [a]
instance GHC.Exts.IsList (GHC.Base.NonEmpty a)
instance GHC.Exts.IsList Data.Version.Version
instance GHC.Exts.IsList GHC.Stack.Types.CallStack
module GHC.StaticPtr
data StaticPtr a
deRefStaticPtr :: StaticPtr a -> a
type StaticKey = Fingerprint
staticKey :: StaticPtr a -> StaticKey
unsafeLookupStaticPtr :: StaticKey -> IO (Maybe (StaticPtr a))
data StaticPtrInfo
StaticPtrInfo :: String -> String -> (Int, Int) -> StaticPtrInfo
[spInfoUnitId] :: StaticPtrInfo -> String
[spInfoModuleName] :: StaticPtrInfo -> String
[spInfoSrcLoc] :: StaticPtrInfo -> (Int, Int)
staticPtrInfo :: StaticPtr a -> StaticPtrInfo
staticPtrKeys :: IO [StaticKey]
class IsStatic p
fromStaticPtr :: IsStatic p => StaticPtr a -> p a
instance GHC.Show.Show GHC.StaticPtr.StaticPtrInfo
instance GHC.StaticPtr.IsStatic GHC.StaticPtr.StaticPtr
module Data.Semigroup
class Semigroup a
(<>) :: Semigroup a => a -> a -> a
sconcat :: Semigroup a => NonEmpty a -> a
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a
stimesIdempotent :: Integral b => b -> a -> a
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a
newtype First a
First :: a -> First a
[getFirst] :: First a -> a
newtype Last a
Last :: a -> Last a
[getLast] :: Last a -> a
newtype WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a
newtype All
All :: Bool -> All
[getAll] :: All -> Bool
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a
option :: b -> (a -> b) -> Option a -> b
diff :: Semigroup m => m -> Endo m
cycle1 :: Semigroup m => m -> m
data Arg a b
Arg :: a -> b -> Arg a b
type ArgMin a b = Min (Arg a b)
type ArgMax a b = Max (Arg a b)
instance GHC.Generics.Generic1 Data.Semigroup.Option
instance GHC.Generics.Generic (Data.Semigroup.Option a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Option a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Option a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Option a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Option a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Option a)
instance GHC.Generics.Generic1 Data.Semigroup.WrappedMonoid
instance GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m)
instance Data.Data.Data m => Data.Data.Data (Data.Semigroup.WrappedMonoid m)
instance GHC.Read.Read m => GHC.Read.Read (Data.Semigroup.WrappedMonoid m)
instance GHC.Show.Show m => GHC.Show.Show (Data.Semigroup.WrappedMonoid m)
instance GHC.Classes.Ord m => GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m)
instance GHC.Classes.Eq m => GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
instance GHC.Enum.Bounded m => GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m)
instance GHC.Generics.Generic1 Data.Semigroup.Last
instance GHC.Generics.Generic (Data.Semigroup.Last a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Last a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Last a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Last a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Last a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Last a)
instance GHC.Generics.Generic1 Data.Semigroup.First
instance GHC.Generics.Generic (Data.Semigroup.First a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.First a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.First a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.First a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.First a)
instance GHC.Generics.Generic1 (Data.Semigroup.Arg a)
instance GHC.Generics.Generic (Data.Semigroup.Arg a b)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Semigroup.Arg a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Semigroup.Arg a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Semigroup.Arg a b)
instance GHC.Generics.Generic1 Data.Semigroup.Max
instance GHC.Generics.Generic (Data.Semigroup.Max a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Max a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Max a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Max a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Max a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Max a)
instance GHC.Generics.Generic1 Data.Semigroup.Min
instance GHC.Generics.Generic (Data.Semigroup.Min a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Min a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Min a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Min a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Min a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Min a)
instance GHC.Base.Functor Data.Semigroup.Option
instance GHC.Base.Applicative Data.Semigroup.Option
instance GHC.Base.Monad Data.Semigroup.Option
instance GHC.Base.Alternative Data.Semigroup.Option
instance GHC.Base.MonadPlus Data.Semigroup.Option
instance Control.Monad.Fix.MonadFix Data.Semigroup.Option
instance Data.Foldable.Foldable Data.Semigroup.Option
instance Data.Traversable.Traversable Data.Semigroup.Option
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Semigroup.Option a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Data.Semigroup.Option a)
instance GHC.Base.Monoid m => GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m)
instance GHC.Base.Monoid m => GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Last a)
instance GHC.Base.Semigroup (Data.Semigroup.Last a)
instance GHC.Base.Functor Data.Semigroup.Last
instance Data.Foldable.Foldable Data.Semigroup.Last
instance Data.Traversable.Traversable Data.Semigroup.Last
instance GHC.Base.Applicative Data.Semigroup.Last
instance GHC.Base.Monad Data.Semigroup.Last
instance Control.Monad.Fix.MonadFix Data.Semigroup.Last
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.First a)
instance GHC.Base.Semigroup (Data.Semigroup.First a)
instance GHC.Base.Functor Data.Semigroup.First
instance Data.Foldable.Foldable Data.Semigroup.First
instance Data.Traversable.Traversable Data.Semigroup.First
instance GHC.Base.Applicative Data.Semigroup.First
instance GHC.Base.Monad Data.Semigroup.First
instance Control.Monad.Fix.MonadFix Data.Semigroup.First
instance GHC.Base.Functor (Data.Semigroup.Arg a)
instance Data.Foldable.Foldable (Data.Semigroup.Arg a)
instance Data.Traversable.Traversable (Data.Semigroup.Arg a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Arg a b)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Arg a b)
instance Data.Bifunctor.Bifunctor Data.Semigroup.Arg
instance Data.Bifoldable.Bifoldable Data.Semigroup.Arg
instance Data.Bitraversable.Bitraversable Data.Semigroup.Arg
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Max a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Max a)
instance GHC.Base.Functor Data.Semigroup.Max
instance Data.Foldable.Foldable Data.Semigroup.Max
instance Data.Traversable.Traversable Data.Semigroup.Max
instance GHC.Base.Applicative Data.Semigroup.Max
instance GHC.Base.Monad Data.Semigroup.Max
instance Control.Monad.Fix.MonadFix Data.Semigroup.Max
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Min a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Min a)
instance GHC.Base.Functor Data.Semigroup.Min
instance Data.Foldable.Foldable Data.Semigroup.Min
instance Data.Traversable.Traversable Data.Semigroup.Min
instance GHC.Base.Applicative Data.Semigroup.Min
instance GHC.Base.Monad Data.Semigroup.Min
instance Control.Monad.Fix.MonadFix Data.Semigroup.Min
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a)
module Data.Void
data Void
absurd :: Void -> a
vacuous :: Functor f => f Void -> f a
instance GHC.Show.Show Data.Void.Void
instance GHC.Read.Read Data.Void.Void
instance GHC.Classes.Ord Data.Void.Void
instance GHC.Generics.Generic Data.Void.Void
instance Data.Data.Data Data.Void.Void
instance GHC.Classes.Eq Data.Void.Void
instance GHC.Arr.Ix Data.Void.Void
instance GHC.Exception.Type.Exception Data.Void.Void
instance GHC.Base.Semigroup Data.Void.Void
module Data.Functor.Sum
data Sum f g a
InL :: f a -> Sum f g a
InR :: g a -> Sum f g a
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Sum.Sum f g a)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Sum.Sum f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Sum.Sum f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Sum.Sum f g)
module Data.Functor.Product
data Product f g a
Pair :: f a -> g a -> Product f g a
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Product.Product f g)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Product.Product f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Product.Product f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Product.Product f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Product.Product f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Data.Functor.Product.Product f g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (Data.Functor.Product.Product f g)
instance (GHC.Base.Monad f, GHC.Base.Monad g) => GHC.Base.Monad (Data.Functor.Product.Product f g)
instance (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) => GHC.Base.MonadPlus (Data.Functor.Product.Product f g)
instance (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) => Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f g)
instance (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) => Control.Monad.Zip.MonadZip (Data.Functor.Product.Product f g)
module Data.Functor.Compose
newtype Compose f g a
Compose :: f (g a) -> Compose f g a
[getCompose] :: Compose f g a -> f (g a)
infixr 9 `Compose`
infixr 9 `Compose`
instance forall (f :: * -> *) k (g :: k -> *). GHC.Base.Functor f => GHC.Generics.Generic1 (Data.Functor.Compose.Compose f g)
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Generics.Generic (Data.Functor.Compose.Compose f g a)
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k1, Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) => Data.Data.Data (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Compose.Compose f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Alternative f, GHC.Base.Applicative g) => GHC.Base.Alternative (Data.Functor.Compose.Compose f g)
module Data.Functor.Contravariant
class Contravariant f
contramap :: Contravariant f => (a -> b) -> f b -> f a
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$
phantom :: (Functor f, Contravariant f) => f a -> f b
(>$<) :: Contravariant f => (a -> b) -> f b -> f a
infixl 4 >$<
(>$$<) :: Contravariant f => f b -> (a -> b) -> f a
infixl 4 >$$<
($<) :: Contravariant f => f b -> b -> f a
infixl 4 $<
newtype Predicate a
Predicate :: (a -> Bool) -> Predicate a
[getPredicate] :: Predicate a -> a -> Bool
newtype Comparison a
Comparison :: (a -> a -> Ordering) -> Comparison a
[getComparison] :: Comparison a -> a -> a -> Ordering
defaultComparison :: Ord a => Comparison a
newtype Equivalence a
Equivalence :: (a -> a -> Bool) -> Equivalence a
[getEquivalence] :: Equivalence a -> a -> a -> Bool
defaultEquivalence :: Eq a => Equivalence a
comparisonEquivalence :: Comparison a -> Equivalence a
newtype Op a b
Op :: (b -> a) -> Op a b
[getOp] :: Op a b -> b -> a
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
instance Control.Category.Category Data.Functor.Contravariant.Op
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Op a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Contravariant.Op a b)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Contravariant.Op a b)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Equivalence
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Predicate
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a)
instance Data.Functor.Contravariant.Contravariant GHC.Generics.V1
instance Data.Functor.Contravariant.Contravariant GHC.Generics.U1
instance Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Const.Const a)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Compose.Compose f g)
instance Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy
module Data.Fixed
div' :: (Real a, Integral b) => a -> a -> b
mod' :: Real a => a -> a -> a
divMod' :: (Real a, Integral b) => a -> a -> (b, a)
newtype Fixed a
MkFixed :: Integer -> Fixed a
class HasResolution a
resolution :: HasResolution a => p a -> Integer
showFixed :: HasResolution a => Bool -> Fixed a -> String
data E0
type Uni = Fixed E0
data E1
type Deci = Fixed E1
data E2
type Centi = Fixed E2
data E3
type Milli = Fixed E3
data E6
type Micro = Fixed E6
data E9
type Nano = Fixed E9
data E12
type Pico = Fixed E12
instance GHC.Classes.Ord (Data.Fixed.Fixed a)
instance GHC.Classes.Eq (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution Data.Fixed.E12
instance Data.Fixed.HasResolution Data.Fixed.E9
instance Data.Fixed.HasResolution Data.Fixed.E6
instance Data.Fixed.HasResolution Data.Fixed.E3
instance Data.Fixed.HasResolution Data.Fixed.E2
instance Data.Fixed.HasResolution Data.Fixed.E1
instance Data.Fixed.HasResolution Data.Fixed.E0
instance Data.Fixed.HasResolution a => GHC.Num.Num (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.Real (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.Fractional (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.RealFrac (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Show.Show (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Read.Read (Data.Fixed.Fixed a)
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (Data.Fixed.Fixed a)
instance GHC.Enum.Enum (Data.Fixed.Fixed a)
module Data.Complex
data Complex a
(:+) :: !a -> !a -> Complex a
infix 6 :+
realPart :: Complex a -> a
imagPart :: Complex a -> a
mkPolar :: Floating a => a -> a -> Complex a
cis :: Floating a => a -> Complex a
polar :: RealFloat a => Complex a -> (a, a)
magnitude :: RealFloat a => Complex a -> a
phase :: RealFloat a => Complex a -> a
conjugate :: Num a => Complex a -> Complex a
instance Data.Traversable.Traversable Data.Complex.Complex
instance Data.Foldable.Foldable Data.Complex.Complex
instance GHC.Base.Functor Data.Complex.Complex
instance GHC.Generics.Generic1 Data.Complex.Complex
instance GHC.Generics.Generic (Data.Complex.Complex a)
instance Data.Data.Data a => Data.Data.Data (Data.Complex.Complex a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Complex.Complex a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Complex.Complex a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Num.Num (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Real.Fractional (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Float.Floating (Data.Complex.Complex a)
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Complex.Complex a)
instance GHC.Base.Applicative Data.Complex.Complex
instance GHC.Base.Monad Data.Complex.Complex
