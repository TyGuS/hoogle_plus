@package containers
@version 0.6.0.1
module Utils.Containers.Internal.BitUtil
bitcount :: Int -> Word -> Int
highestBitMask :: Word -> Word
shiftLL :: Word -> Int -> Word
shiftRL :: Word -> Int -> Word
wordSize :: Int
module Utils.Containers.Internal.BitQueue
data BitQueue
data BitQueueB
emptyQB :: BitQueueB
snocQB :: BitQueueB -> Bool -> BitQueueB
buildQ :: BitQueueB -> BitQueue
unconsQ :: BitQueue -> Maybe (Bool, BitQueue)
toListQ :: BitQueue -> [Bool]
instance GHC.Show.Show Utils.Containers.Internal.BitQueue.BitQueue
instance GHC.Show.Show Utils.Containers.Internal.BitQueue.BitQueueB
module Utils.Containers.Internal.StrictPair
data StrictPair a b
(:*:) :: !a -> !b -> StrictPair a b
toPair :: StrictPair a b -> (a, b)
module Data.Set.Internal
data Set a
Bin :: {-# UNPACK #-} !Size -> !a -> !(Set a) -> !(Set a) -> Set a
Tip :: Set a
type Size = Int
(\\) :: Ord a => Set a -> Set a -> Set a
infixl 9 \\
null :: Set a -> Bool
size :: Set a -> Int
member :: Ord a => a -> Set a -> Bool
notMember :: Ord a => a -> Set a -> Bool
lookupLT :: Ord a => a -> Set a -> Maybe a
lookupGT :: Ord a => a -> Set a -> Maybe a
lookupLE :: Ord a => a -> Set a -> Maybe a
lookupGE :: Ord a => a -> Set a -> Maybe a
isSubsetOf :: Ord a => Set a -> Set a -> Bool
isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
disjoint :: Ord a => Set a -> Set a -> Bool
empty :: Set a
singleton :: a -> Set a
insert :: Ord a => a -> Set a -> Set a
delete :: Ord a => a -> Set a -> Set a
powerSet :: Set a -> Set (Set a)
union :: Ord a => Set a -> Set a -> Set a
unions :: (Foldable f, Ord a) => f (Set a) -> Set a
difference :: Ord a => Set a -> Set a -> Set a
intersection :: Ord a => Set a -> Set a -> Set a
cartesianProduct :: Set a -> Set b -> Set (a, b)
disjointUnion :: Set a -> Set b -> Set (Either a b)
filter :: (a -> Bool) -> Set a -> Set a
takeWhileAntitone :: (a -> Bool) -> Set a -> Set a
dropWhileAntitone :: (a -> Bool) -> Set a -> Set a
spanAntitone :: (a -> Bool) -> Set a -> (Set a, Set a)
partition :: (a -> Bool) -> Set a -> (Set a, Set a)
split :: Ord a => a -> Set a -> (Set a, Set a)
splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)
splitRoot :: Set a -> [Set a]
lookupIndex :: Ord a => a -> Set a -> Maybe Int
findIndex :: Ord a => a -> Set a -> Int
elemAt :: Int -> Set a -> a
deleteAt :: Int -> Set a -> Set a
take :: Int -> Set a -> Set a
drop :: Int -> Set a -> Set a
splitAt :: Int -> Set a -> (Set a, Set a)
map :: Ord b => (a -> b) -> Set a -> Set b
mapMonotonic :: (a -> b) -> Set a -> Set b
foldr :: (a -> b -> b) -> b -> Set a -> b
foldl :: (a -> b -> a) -> a -> Set b -> a
foldr' :: (a -> b -> b) -> b -> Set a -> b
foldl' :: (a -> b -> a) -> a -> Set b -> a
fold :: (a -> b -> b) -> b -> Set a -> b
lookupMin :: Set a -> Maybe a
lookupMax :: Set a -> Maybe a
findMin :: Set a -> a
findMax :: Set a -> a
deleteMin :: Set a -> Set a
deleteMax :: Set a -> Set a
deleteFindMin :: Set a -> (a, Set a)
deleteFindMax :: Set a -> (a, Set a)
maxView :: Set a -> Maybe (a, Set a)
minView :: Set a -> Maybe (a, Set a)
elems :: Set a -> [a]
toList :: Set a -> [a]
fromList :: Ord a => [a] -> Set a
toAscList :: Set a -> [a]
toDescList :: Set a -> [a]
fromAscList :: Eq a => [a] -> Set a
fromDistinctAscList :: [a] -> Set a
fromDescList :: Eq a => [a] -> Set a
fromDistinctDescList :: [a] -> Set a
showTree :: Show a => Set a -> String
showTreeWith :: Show a => Bool -> Bool -> Set a -> String
valid :: Ord a => Set a -> Bool
bin :: a -> Set a -> Set a -> Set a
balanced :: Set a -> Bool
link :: a -> Set a -> Set a -> Set a
merge :: Set a -> Set a -> Set a
instance GHC.Base.Semigroup (Data.Set.Internal.MergeSet a)
instance GHC.Base.Monoid (Data.Set.Internal.MergeSet a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Set.Internal.Set a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Set.Internal.Set a)
instance Data.Foldable.Foldable Data.Set.Internal.Set
instance (Data.Data.Data a, GHC.Classes.Ord a) => Data.Data.Data (Data.Set.Internal.Set a)
instance GHC.Classes.Ord a => GHC.Exts.IsList (Data.Set.Internal.Set a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Set.Internal.Set a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Set.Internal.Set a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Set.Internal.Set a)
instance Data.Functor.Classes.Eq1 Data.Set.Internal.Set
instance Data.Functor.Classes.Ord1 Data.Set.Internal.Set
instance Data.Functor.Classes.Show1 Data.Set.Internal.Set
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (Data.Set.Internal.Set a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Set.Internal.Set a)
module Data.Set
data Set a
empty :: Set a
singleton :: a -> Set a
fromList :: Ord a => [a] -> Set a
fromAscList :: Eq a => [a] -> Set a
fromDescList :: Eq a => [a] -> Set a
fromDistinctAscList :: [a] -> Set a
fromDistinctDescList :: [a] -> Set a
powerSet :: Set a -> Set (Set a)
insert :: Ord a => a -> Set a -> Set a
delete :: Ord a => a -> Set a -> Set a
member :: Ord a => a -> Set a -> Bool
notMember :: Ord a => a -> Set a -> Bool
lookupLT :: Ord a => a -> Set a -> Maybe a
lookupGT :: Ord a => a -> Set a -> Maybe a
lookupLE :: Ord a => a -> Set a -> Maybe a
lookupGE :: Ord a => a -> Set a -> Maybe a
null :: Set a -> Bool
size :: Set a -> Int
isSubsetOf :: Ord a => Set a -> Set a -> Bool
isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
disjoint :: Ord a => Set a -> Set a -> Bool
union :: Ord a => Set a -> Set a -> Set a
unions :: (Foldable f, Ord a) => f (Set a) -> Set a
difference :: Ord a => Set a -> Set a -> Set a
(\\) :: Ord a => Set a -> Set a -> Set a
infixl 9 \\
intersection :: Ord a => Set a -> Set a -> Set a
cartesianProduct :: Set a -> Set b -> Set (a, b)
disjointUnion :: Set a -> Set b -> Set (Either a b)
filter :: (a -> Bool) -> Set a -> Set a
takeWhileAntitone :: (a -> Bool) -> Set a -> Set a
dropWhileAntitone :: (a -> Bool) -> Set a -> Set a
spanAntitone :: (a -> Bool) -> Set a -> (Set a, Set a)
partition :: (a -> Bool) -> Set a -> (Set a, Set a)
split :: Ord a => a -> Set a -> (Set a, Set a)
splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)
splitRoot :: Set a -> [Set a]
lookupIndex :: Ord a => a -> Set a -> Maybe Int
findIndex :: Ord a => a -> Set a -> Int
elemAt :: Int -> Set a -> a
deleteAt :: Int -> Set a -> Set a
take :: Int -> Set a -> Set a
drop :: Int -> Set a -> Set a
splitAt :: Int -> Set a -> (Set a, Set a)
map :: Ord b => (a -> b) -> Set a -> Set b
mapMonotonic :: (a -> b) -> Set a -> Set b
foldr :: (a -> b -> b) -> b -> Set a -> b
foldl :: (a -> b -> a) -> a -> Set b -> a
foldr' :: (a -> b -> b) -> b -> Set a -> b
foldl' :: (a -> b -> a) -> a -> Set b -> a
fold :: (a -> b -> b) -> b -> Set a -> b
lookupMin :: Set a -> Maybe a
lookupMax :: Set a -> Maybe a
findMin :: Set a -> a
findMax :: Set a -> a
deleteMin :: Set a -> Set a
deleteMax :: Set a -> Set a
deleteFindMin :: Set a -> (a, Set a)
deleteFindMax :: Set a -> (a, Set a)
maxView :: Set a -> Maybe (a, Set a)
minView :: Set a -> Maybe (a, Set a)
elems :: Set a -> [a]
toList :: Set a -> [a]
toAscList :: Set a -> [a]
toDescList :: Set a -> [a]
showTree :: Show a => Set a -> String
showTreeWith :: Show a => Bool -> Bool -> Set a -> String
valid :: Ord a => Set a -> Bool
module Data.Sequence.Internal
newtype Elem a
Elem :: a -> Elem a
[getElem] :: Elem a -> a
data FingerTree a
EmptyT :: FingerTree a
Single :: a -> FingerTree a
Deep :: {-# UNPACK #-} !Int -> !(Digit a) -> (FingerTree (Node a)) -> !(Digit a) -> FingerTree a
data Node a
Node2 :: {-# UNPACK #-} !Int -> a -> a -> Node a
Node3 :: {-# UNPACK #-} !Int -> a -> a -> a -> Node a
data Digit a
One :: a -> Digit a
Two :: a -> a -> Digit a
Three :: a -> a -> a -> Digit a
Four :: a -> a -> a -> a -> Digit a
class Sized a
size :: Sized a => a -> Int
class MaybeForce a
newtype Seq a
Seq :: (FingerTree (Elem a)) -> Seq a
newtype State s a
State :: s -> (s, a) -> State s a
[runState] :: State s a -> s -> (s, a)
execState :: State s a -> s -> a
foldDigit :: (b -> b -> b) -> (a -> b) -> Digit a -> b
foldNode :: (b -> b -> b) -> (a -> b) -> Node a -> b
foldWithIndexDigit :: Sized a => (b -> b -> b) -> (Int -> a -> b) -> Int -> Digit a -> b
foldWithIndexNode :: Sized a => (m -> m -> m) -> (Int -> a -> m) -> Int -> Node a -> m
empty :: Seq a
singleton :: a -> Seq a
(<|) :: a -> Seq a -> Seq a
infixr 5 <|
(|>) :: Seq a -> a -> Seq a
infixl 5 |>
(><) :: Seq a -> Seq a -> Seq a
infixr 5 ><
fromList :: [a] -> Seq a
fromFunction :: Int -> (Int -> a) -> Seq a
fromArray :: Ix i => Array i a -> Seq a
replicate :: Int -> a -> Seq a
replicateA :: Applicative f => Int -> f a -> f (Seq a)
replicateM :: Applicative m => Int -> m a -> m (Seq a)
cycleTaking :: Int -> Seq a -> Seq a
iterateN :: Int -> (a -> a) -> a -> Seq a
unfoldr :: (b -> Maybe (a, b)) -> b -> Seq a
unfoldl :: (b -> Maybe (b, a)) -> b -> Seq a
null :: Seq a -> Bool
length :: Seq a -> Int
data ViewL a
EmptyL :: ViewL a
(:<) :: a -> Seq a -> ViewL a
viewl :: Seq a -> ViewL a
data ViewR a
EmptyR :: ViewR a
(:>) :: Seq a -> a -> ViewR a
viewr :: Seq a -> ViewR a
scanl :: (a -> b -> a) -> a -> Seq b -> Seq a
scanl1 :: (a -> a -> a) -> Seq a -> Seq a
scanr :: (a -> b -> b) -> b -> Seq a -> Seq b
scanr1 :: (a -> a -> a) -> Seq a -> Seq a
tails :: Seq a -> Seq (Seq a)
inits :: Seq a -> Seq (Seq a)
chunksOf :: Int -> Seq a -> Seq (Seq a)
takeWhileL :: (a -> Bool) -> Seq a -> Seq a
takeWhileR :: (a -> Bool) -> Seq a -> Seq a
dropWhileL :: (a -> Bool) -> Seq a -> Seq a
dropWhileR :: (a -> Bool) -> Seq a -> Seq a
spanl :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
spanr :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
breakl :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
breakr :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
filter :: (a -> Bool) -> Seq a -> Seq a
lookup :: Int -> Seq a -> Maybe a
(!?) :: Seq a -> Int -> Maybe a
index :: Seq a -> Int -> a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
adjust' :: forall a. (a -> a) -> Int -> Seq a -> Seq a
update :: Int -> a -> Seq a -> Seq a
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
insertAt :: Int -> a -> Seq a -> Seq a
deleteAt :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
elemIndexL :: Eq a => a -> Seq a -> Maybe Int
elemIndicesL :: Eq a => a -> Seq a -> [Int]
elemIndexR :: Eq a => a -> Seq a -> Maybe Int
elemIndicesR :: Eq a => a -> Seq a -> [Int]
findIndexL :: (a -> Bool) -> Seq a -> Maybe Int
findIndicesL :: (a -> Bool) -> Seq a -> [Int]
findIndexR :: (a -> Bool) -> Seq a -> Maybe Int
findIndicesR :: (a -> Bool) -> Seq a -> [Int]
foldMapWithIndex :: Monoid m => (Int -> a -> m) -> Seq a -> m
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
traverseWithIndex :: Applicative f => (Int -> a -> f b) -> Seq a -> f (Seq b)
reverse :: Seq a -> Seq a
intersperse :: a -> Seq a -> Seq a
liftA2Seq :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zip :: Seq a -> Seq b -> Seq (a, b)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
zip4 :: Seq a -> Seq b -> Seq c -> Seq d -> Seq (a, b, c, d)
zipWith4 :: (a -> b -> c -> d -> e) -> Seq a -> Seq b -> Seq c -> Seq d -> Seq e
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzipWith :: (a -> (b, c)) -> Seq a -> (Seq b, Seq c)
instance GHC.Read.Read a => GHC.Read.Read (Data.Sequence.Internal.ViewR a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Sequence.Internal.ViewR a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Sequence.Internal.ViewR a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Sequence.Internal.ViewR a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Sequence.Internal.ViewL a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Sequence.Internal.ViewL a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Sequence.Internal.ViewL a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Sequence.Internal.ViewL a)
instance GHC.Generics.Generic1 Data.Sequence.Internal.FingerTree
instance GHC.Generics.Generic (Data.Sequence.Internal.FingerTree a)
instance GHC.Generics.Generic1 Data.Sequence.Internal.Digit
instance GHC.Generics.Generic (Data.Sequence.Internal.Digit a)
instance GHC.Generics.Generic1 Data.Sequence.Internal.Node
instance GHC.Generics.Generic (Data.Sequence.Internal.Node a)
instance GHC.Generics.Generic1 Data.Sequence.Internal.Elem
instance GHC.Generics.Generic (Data.Sequence.Internal.Elem a)
instance Data.Data.Data a => Data.Data.Data (Data.Sequence.Internal.ViewL a)
instance GHC.Generics.Generic1 Data.Sequence.Internal.ViewL
instance GHC.Generics.Generic (Data.Sequence.Internal.ViewL a)
instance Data.Data.Data a => Data.Data.Data (Data.Sequence.Internal.ViewR a)
instance GHC.Generics.Generic1 Data.Sequence.Internal.ViewR
instance GHC.Generics.Generic (Data.Sequence.Internal.ViewR a)
instance Data.Sequence.Internal.UnzipWith Data.Sequence.Internal.Elem
instance Data.Sequence.Internal.UnzipWith Data.Sequence.Internal.Node
instance Data.Sequence.Internal.UnzipWith Data.Sequence.Internal.Digit
instance Data.Sequence.Internal.UnzipWith Data.Sequence.Internal.FingerTree
instance Data.Sequence.Internal.UnzipWith Data.Sequence.Internal.Seq
instance GHC.Base.Functor Data.Sequence.Internal.ViewR
instance Data.Foldable.Foldable Data.Sequence.Internal.ViewR
instance Data.Traversable.Traversable Data.Sequence.Internal.ViewR
instance Data.Data.Data a => Data.Data.Data (Data.Sequence.Internal.Seq a)
instance GHC.Base.Functor Data.Sequence.Internal.ViewL
instance Data.Foldable.Foldable Data.Sequence.Internal.ViewL
instance Data.Traversable.Traversable Data.Sequence.Internal.ViewL
instance GHC.Base.Functor Data.Sequence.Internal.Seq
instance Data.Foldable.Foldable Data.Sequence.Internal.Seq
instance Data.Traversable.Traversable Data.Sequence.Internal.Seq
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Sequence.Internal.Seq a)
instance GHC.Base.Monad Data.Sequence.Internal.Seq
instance Control.Monad.Fix.MonadFix Data.Sequence.Internal.Seq
instance GHC.Base.Applicative Data.Sequence.Internal.Seq
instance GHC.Base.MonadPlus Data.Sequence.Internal.Seq
instance GHC.Base.Alternative Data.Sequence.Internal.Seq
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Sequence.Internal.Seq a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Sequence.Internal.Seq a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Sequence.Internal.Seq a)
instance Data.Functor.Classes.Show1 Data.Sequence.Internal.Seq
instance Data.Functor.Classes.Eq1 Data.Sequence.Internal.Seq
instance Data.Functor.Classes.Ord1 Data.Sequence.Internal.Seq
instance GHC.Read.Read a => GHC.Read.Read (Data.Sequence.Internal.Seq a)
instance Data.Functor.Classes.Read1 Data.Sequence.Internal.Seq
instance GHC.Base.Monoid (Data.Sequence.Internal.Seq a)
instance GHC.Base.Semigroup (Data.Sequence.Internal.Seq a)
instance GHC.Exts.IsList (Data.Sequence.Internal.Seq a)
instance (a ~ GHC.Types.Char) => Data.String.IsString (Data.Sequence.Internal.Seq a)
instance Control.Monad.Zip.MonadZip Data.Sequence.Internal.Seq
instance Data.Sequence.Internal.MaybeForce (Data.Sequence.Internal.Elem a)
instance Data.Sequence.Internal.Sized a => Data.Sequence.Internal.Sized (Data.Sequence.Internal.FingerTree a)
instance Data.Sequence.Internal.Sized (Data.Sequence.Internal.Elem a)
instance GHC.Base.Functor Data.Sequence.Internal.Elem
instance Data.Foldable.Foldable Data.Sequence.Internal.Elem
instance Data.Traversable.Traversable Data.Sequence.Internal.Elem
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Sequence.Internal.Elem a)
instance Data.Foldable.Foldable Data.Sequence.Internal.FingerTree
instance GHC.Base.Functor Data.Sequence.Internal.FingerTree
instance Data.Traversable.Traversable Data.Sequence.Internal.FingerTree
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Sequence.Internal.FingerTree a)
instance Data.Sequence.Internal.MaybeForce (Data.Sequence.Internal.Node a)
instance Data.Foldable.Foldable Data.Sequence.Internal.Node
instance GHC.Base.Functor Data.Sequence.Internal.Node
instance Data.Traversable.Traversable Data.Sequence.Internal.Node
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Sequence.Internal.Node a)
instance Data.Sequence.Internal.Sized (Data.Sequence.Internal.Node a)
instance Data.Foldable.Foldable Data.Sequence.Internal.Digit
instance GHC.Base.Functor Data.Sequence.Internal.Digit
instance Data.Traversable.Traversable Data.Sequence.Internal.Digit
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Sequence.Internal.Digit a)
instance Data.Sequence.Internal.Sized a => Data.Sequence.Internal.Sized (Data.Sequence.Internal.Digit a)
instance Data.Sequence.Internal.MaybeForce (Data.Sequence.Internal.ForceBox a)
instance Data.Sequence.Internal.Sized (Data.Sequence.Internal.ForceBox a)
module Data.Sequence.Internal.Sorting
sort :: Ord a => Seq a -> Seq a
sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
sortOn :: Ord b => (a -> b) -> Seq a -> Seq a
unstableSort :: Ord a => Seq a -> Seq a
unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
unstableSortOn :: Ord b => (a -> b) -> Seq a -> Seq a
data Queue e
Q :: !e -> (QList e) -> Queue e
data QList e
Nil :: QList e
QCons :: {-# UNPACK #-} !(Queue e) -> (QList e) -> QList e
data IndexedQueue e
IQ :: {-# UNPACK #-} !Int -> !e -> (IQList e) -> IndexedQueue e
data IQList e
IQNil :: IQList e
IQCons :: {-# UNPACK #-} !(IndexedQueue e) -> (IQList e) -> IQList e
data TaggedQueue a b
TQ :: !a -> b -> (TQList a b) -> TaggedQueue a b
data TQList a b
TQNil :: TQList a b
TQCons :: {-# UNPACK #-} !(TaggedQueue a b) -> (TQList a b) -> TQList a b
data IndexedTaggedQueue e a
ITQ :: {-# UNPACK #-} !Int -> !e -> a -> (ITQList e a) -> IndexedTaggedQueue e a
data ITQList e a
ITQNil :: ITQList e a
ITQCons :: {-# UNPACK #-} !(IndexedTaggedQueue e a) -> (ITQList e a) -> ITQList e a
mergeQ :: (a -> a -> Ordering) -> Queue a -> Queue a -> Queue a
mergeIQ :: (a -> a -> Ordering) -> IndexedQueue a -> IndexedQueue a -> IndexedQueue a
mergeTQ :: (a -> a -> Ordering) -> TaggedQueue a b -> TaggedQueue a b -> TaggedQueue a b
mergeITQ :: (a -> a -> Ordering) -> IndexedTaggedQueue a b -> IndexedTaggedQueue a b -> IndexedTaggedQueue a b
popMinQ :: (e -> e -> Ordering) -> Queue e -> (Queue e, e)
popMinIQ :: (e -> e -> Ordering) -> IndexedQueue e -> (IndexedQueue e, e)
popMinTQ :: (a -> a -> Ordering) -> TaggedQueue a b -> (TaggedQueue a b, b)
popMinITQ :: (e -> e -> Ordering) -> IndexedTaggedQueue e b -> (IndexedTaggedQueue e b, b)
buildQ :: (b -> b -> Ordering) -> (a -> Queue b) -> FingerTree a -> Maybe (Queue b)
buildIQ :: (b -> b -> Ordering) -> (Int -> Elem y -> IndexedQueue b) -> Int -> FingerTree (Elem y) -> Maybe (IndexedQueue b)
buildTQ :: (b -> b -> Ordering) -> (a -> TaggedQueue b c) -> FingerTree a -> Maybe (TaggedQueue b c)
buildITQ :: (b -> b -> Ordering) -> (Int -> Elem y -> IndexedTaggedQueue b c) -> Int -> FingerTree (Elem y) -> Maybe (IndexedTaggedQueue b c)
foldToMaybeTree :: (b -> b -> b) -> (a -> b) -> FingerTree a -> Maybe b
foldToMaybeWithIndexTree :: (b -> b -> b) -> (Int -> Elem y -> b) -> Int -> FingerTree (Elem y) -> Maybe b
module Data.Sequence
data Seq a
empty :: Seq a
singleton :: a -> Seq a
(<|) :: a -> Seq a -> Seq a
infixr 5 <|
(|>) :: Seq a -> a -> Seq a
infixl 5 |>
(><) :: Seq a -> Seq a -> Seq a
infixr 5 ><
fromList :: [a] -> Seq a
fromFunction :: Int -> (Int -> a) -> Seq a
fromArray :: Ix i => Array i a -> Seq a
replicate :: Int -> a -> Seq a
replicateA :: Applicative f => Int -> f a -> f (Seq a)
replicateM :: Applicative m => Int -> m a -> m (Seq a)
cycleTaking :: Int -> Seq a -> Seq a
iterateN :: Int -> (a -> a) -> a -> Seq a
unfoldr :: (b -> Maybe (a, b)) -> b -> Seq a
unfoldl :: (b -> Maybe (b, a)) -> b -> Seq a
null :: Seq a -> Bool
length :: Seq a -> Int
data ViewL a
EmptyL :: ViewL a
(:<) :: a -> Seq a -> ViewL a
viewl :: Seq a -> ViewL a
data ViewR a
EmptyR :: ViewR a
(:>) :: Seq a -> a -> ViewR a
viewr :: Seq a -> ViewR a
scanl :: (a -> b -> a) -> a -> Seq b -> Seq a
scanl1 :: (a -> a -> a) -> Seq a -> Seq a
scanr :: (a -> b -> b) -> b -> Seq a -> Seq b
scanr1 :: (a -> a -> a) -> Seq a -> Seq a
tails :: Seq a -> Seq (Seq a)
inits :: Seq a -> Seq (Seq a)
chunksOf :: Int -> Seq a -> Seq (Seq a)
takeWhileL :: (a -> Bool) -> Seq a -> Seq a
takeWhileR :: (a -> Bool) -> Seq a -> Seq a
dropWhileL :: (a -> Bool) -> Seq a -> Seq a
dropWhileR :: (a -> Bool) -> Seq a -> Seq a
spanl :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
spanr :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
breakl :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
breakr :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
partition :: (a -> Bool) -> Seq a -> (Seq a, Seq a)
filter :: (a -> Bool) -> Seq a -> Seq a
sort :: Ord a => Seq a -> Seq a
sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
sortOn :: Ord b => (a -> b) -> Seq a -> Seq a
unstableSort :: Ord a => Seq a -> Seq a
unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
unstableSortOn :: Ord b => (a -> b) -> Seq a -> Seq a
lookup :: Int -> Seq a -> Maybe a
(!?) :: Seq a -> Int -> Maybe a
index :: Seq a -> Int -> a
adjust :: (a -> a) -> Int -> Seq a -> Seq a
adjust' :: forall a. (a -> a) -> Int -> Seq a -> Seq a
update :: Int -> a -> Seq a -> Seq a
take :: Int -> Seq a -> Seq a
drop :: Int -> Seq a -> Seq a
insertAt :: Int -> a -> Seq a -> Seq a
deleteAt :: Int -> Seq a -> Seq a
splitAt :: Int -> Seq a -> (Seq a, Seq a)
elemIndexL :: Eq a => a -> Seq a -> Maybe Int
elemIndicesL :: Eq a => a -> Seq a -> [Int]
elemIndexR :: Eq a => a -> Seq a -> Maybe Int
elemIndicesR :: Eq a => a -> Seq a -> [Int]
findIndexL :: (a -> Bool) -> Seq a -> Maybe Int
findIndicesL :: (a -> Bool) -> Seq a -> [Int]
findIndexR :: (a -> Bool) -> Seq a -> Maybe Int
findIndicesR :: (a -> Bool) -> Seq a -> [Int]
foldMapWithIndex :: Monoid m => (Int -> a -> m) -> Seq a -> m
foldlWithIndex :: (b -> Int -> a -> b) -> b -> Seq a -> b
foldrWithIndex :: (Int -> a -> b -> b) -> b -> Seq a -> b
mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
traverseWithIndex :: Applicative f => (Int -> a -> f b) -> Seq a -> f (Seq b)
reverse :: Seq a -> Seq a
intersperse :: a -> Seq a -> Seq a
zip :: Seq a -> Seq b -> Seq (a, b)
zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
zip4 :: Seq a -> Seq b -> Seq c -> Seq d -> Seq (a, b, c, d)
zipWith4 :: (a -> b -> c -> d -> e) -> Seq a -> Seq b -> Seq c -> Seq d -> Seq e
unzip :: Seq (a, b) -> (Seq a, Seq b)
unzipWith :: (a -> (b, c)) -> Seq a -> (Seq b, Seq c)
module Data.Tree
data Tree a
Node :: a -> Forest a -> Tree a
[rootLabel] :: Tree a -> a
[subForest] :: Tree a -> Forest a
type Forest a = [Tree a]
unfoldTree :: (b -> (a, [b])) -> b -> Tree a
unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
foldTree :: (a -> [b] -> b) -> Tree a -> b
flatten :: Tree a -> [a]
levels :: Tree a -> [[a]]
drawTree :: Tree String -> String
drawForest :: Forest String -> String
instance GHC.Generics.Generic1 Data.Tree.Tree
instance GHC.Generics.Generic (Data.Tree.Tree a)
instance Data.Data.Data a => Data.Data.Data (Data.Tree.Tree a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Tree.Tree a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Tree.Tree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Tree.Tree a)
instance Data.Functor.Classes.Eq1 Data.Tree.Tree
instance Data.Functor.Classes.Ord1 Data.Tree.Tree
instance Data.Functor.Classes.Show1 Data.Tree.Tree
instance Data.Functor.Classes.Read1 Data.Tree.Tree
instance GHC.Base.Functor Data.Tree.Tree
instance GHC.Base.Applicative Data.Tree.Tree
instance GHC.Base.Monad Data.Tree.Tree
instance Control.Monad.Fix.MonadFix Data.Tree.Tree
instance Data.Traversable.Traversable Data.Tree.Tree
instance Data.Foldable.Foldable Data.Tree.Tree
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Tree.Tree a)
instance Control.Monad.Zip.MonadZip Data.Tree.Tree
module Data.Graph
type Graph = Array Vertex [Vertex]
type Bounds = (Vertex, Vertex)
type Edge = (Vertex, Vertex)
type Vertex = Int
type Table a = Array Vertex a
graphFromEdges :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)
graphFromEdges' :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]))
buildG :: Bounds -> [Edge] -> Graph
vertices :: Graph -> [Vertex]
edges :: Graph -> [Edge]
outdegree :: Graph -> Array Vertex Int
indegree :: Graph -> Array Vertex Int
transposeG :: Graph -> Graph
dfs :: Graph -> [Vertex] -> Forest Vertex
dff :: Graph -> Forest Vertex
topSort :: Graph -> [Vertex]
components :: Graph -> Forest Vertex
scc :: Graph -> Forest Vertex
bcc :: Graph -> Forest [Vertex]
reachable :: Graph -> Vertex -> [Vertex]
path :: Graph -> Vertex -> Vertex -> Bool
data SCC vertex
AcyclicSCC :: vertex -> SCC vertex
CyclicSCC :: [vertex] -> SCC vertex
stronglyConnComp :: Ord key => [(node, key, [key])] -> [SCC node]
stronglyConnCompR :: Ord key => [(node, key, [key])] -> [SCC (node, key, [key])]
flattenSCC :: SCC vertex -> [vertex]
flattenSCCs :: [SCC a] -> [a]
type Forest a = [Tree a]
data Tree a
Node :: a -> Forest a -> Tree a
instance GHC.Read.Read vertex => GHC.Read.Read (Data.Graph.SCC vertex)
instance GHC.Show.Show vertex => GHC.Show.Show (Data.Graph.SCC vertex)
instance GHC.Classes.Eq vertex => GHC.Classes.Eq (Data.Graph.SCC vertex)
instance Data.Data.Data vertex => Data.Data.Data (Data.Graph.SCC vertex)
instance GHC.Generics.Generic1 Data.Graph.SCC
instance GHC.Generics.Generic (Data.Graph.SCC vertex)
instance GHC.Base.Monad (Data.Graph.SetM s)
instance GHC.Base.Functor (Data.Graph.SetM s)
instance GHC.Base.Applicative (Data.Graph.SetM s)
instance Data.Functor.Classes.Eq1 Data.Graph.SCC
instance Data.Functor.Classes.Show1 Data.Graph.SCC
instance Data.Functor.Classes.Read1 Data.Graph.SCC
instance Data.Foldable.Foldable Data.Graph.SCC
instance Data.Traversable.Traversable Data.Graph.SCC
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Graph.SCC a)
instance GHC.Base.Functor Data.Graph.SCC
module Data.Map.Internal
data Map k a
Bin :: {-# UNPACK #-} !Size -> !k -> a -> !(Map k a) -> !(Map k a) -> Map k a
Tip :: Map k a
type Size = Int
(!) :: Ord k => Map k a -> k -> a
infixl 9 !
(!?) :: Ord k => Map k a -> k -> Maybe a
infixl 9 !?
(\\) :: Ord k => Map k a -> Map k b -> Map k a
infixl 9 \\
null :: Map k a -> Bool
size :: Map k a -> Int
member :: Ord k => k -> Map k a -> Bool
notMember :: Ord k => k -> Map k a -> Bool
lookup :: Ord k => k -> Map k a -> Maybe a
findWithDefault :: Ord k => a -> k -> Map k a -> a
lookupLT :: Ord k => k -> Map k v -> Maybe (k, v)
lookupGT :: Ord k => k -> Map k v -> Maybe (k, v)
lookupLE :: Ord k => k -> Map k v -> Maybe (k, v)
lookupGE :: Ord k => k -> Map k v -> Maybe (k, v)
empty :: Map k a
singleton :: k -> a -> Map k a
insert :: Ord k => k -> a -> Map k a -> Map k a
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
delete :: Ord k => k -> Map k a -> Map k a
adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
alterF :: (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> Map k a -> f (Map k a)
union :: Ord k => Map k a -> Map k a -> Map k a
unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
unions :: (Foldable f, Ord k) => f (Map k a) -> Map k a
unionsWith :: (Foldable f, Ord k) => (a -> a -> a) -> f (Map k a) -> Map k a
difference :: Ord k => Map k a -> Map k b -> Map k a
differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
intersection :: Ord k => Map k a -> Map k b -> Map k a
intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
type SimpleWhenMissing = WhenMissing Identity
type SimpleWhenMatched = WhenMatched Identity
runWhenMatched :: WhenMatched f k x y z -> k -> x -> y -> f (Maybe z)
runWhenMissing :: WhenMissing f k x y -> k -> x -> f (Maybe y)
merge :: Ord k => SimpleWhenMissing k a c -> SimpleWhenMissing k b c -> SimpleWhenMatched k a b c -> Map k a -> Map k b -> Map k c
zipWithMaybeMatched :: Applicative f => (k -> x -> y -> Maybe z) -> WhenMatched f k x y z
zipWithMatched :: Applicative f => (k -> x -> y -> z) -> WhenMatched f k x y z
mapMaybeMissing :: Applicative f => (k -> x -> Maybe y) -> WhenMissing f k x y
dropMissing :: Applicative f => WhenMissing f k x y
preserveMissing :: Applicative f => WhenMissing f k x x
mapMissing :: Applicative f => (k -> x -> y) -> WhenMissing f k x y
filterMissing :: Applicative f => (k -> x -> Bool) -> WhenMissing f k x x
data WhenMissing f k x y
WhenMissing :: Map k x -> f (Map k y) -> k -> x -> f (Maybe y) -> WhenMissing f k x y
[missingSubtree] :: WhenMissing f k x y -> Map k x -> f (Map k y)
[missingKey] :: WhenMissing f k x y -> k -> x -> f (Maybe y)
newtype WhenMatched f k x y z
WhenMatched :: k -> x -> y -> f (Maybe z) -> WhenMatched f k x y z
[matchedKey] :: WhenMatched f k x y z -> k -> x -> y -> f (Maybe z)
mergeA :: (Applicative f, Ord k) => WhenMissing f k a c -> WhenMissing f k b c -> WhenMatched f k a b c -> Map k a -> Map k b -> f (Map k c)
zipWithMaybeAMatched :: (k -> x -> y -> f (Maybe z)) -> WhenMatched f k x y z
zipWithAMatched :: Applicative f => (k -> x -> y -> f z) -> WhenMatched f k x y z
traverseMaybeMissing :: Applicative f => (k -> x -> f (Maybe y)) -> WhenMissing f k x y
traverseMissing :: Applicative f => (k -> x -> f y) -> WhenMissing f k x y
filterAMissing :: Applicative f => (k -> x -> f Bool) -> WhenMissing f k x x
mergeWithKey :: Ord k => (k -> a -> b -> Maybe c) -> (Map k a -> Map k c) -> (Map k b -> Map k c) -> Map k a -> Map k b -> Map k c
map :: (a -> b) -> Map k a -> Map k b
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
traverseWithKey :: Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)
traverseMaybeWithKey :: Applicative f => (k -> a -> f (Maybe b)) -> Map k a -> f (Map k b)
mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
foldr :: (a -> b -> b) -> b -> Map k a -> b
foldl :: (a -> b -> a) -> a -> Map k b -> a
foldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
foldlWithKey :: (a -> k -> b -> a) -> a -> Map k b -> a
foldMapWithKey :: Monoid m => (k -> a -> m) -> Map k a -> m
foldr' :: (a -> b -> b) -> b -> Map k a -> b
foldl' :: (a -> b -> a) -> a -> Map k b -> a
foldrWithKey' :: (k -> a -> b -> b) -> b -> Map k a -> b
foldlWithKey' :: (a -> k -> b -> a) -> a -> Map k b -> a
elems :: Map k a -> [a]
keys :: Map k a -> [k]
assocs :: Map k a -> [(k, a)]
keysSet :: Map k a -> Set k
fromSet :: (k -> a) -> Set k -> Map k a
toList :: Map k a -> [(k, a)]
fromList :: Ord k => [(k, a)] -> Map k a
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
toAscList :: Map k a -> [(k, a)]
toDescList :: Map k a -> [(k, a)]
fromAscList :: Eq k => [(k, a)] -> Map k a
fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctAscList :: [(k, a)] -> Map k a
fromDescList :: Eq k => [(k, a)] -> Map k a
fromDescListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromDescListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctDescList :: [(k, a)] -> Map k a
filter :: (a -> Bool) -> Map k a -> Map k a
filterWithKey :: (k -> a -> Bool) -> Map k a -> Map k a
takeWhileAntitone :: (k -> Bool) -> Map k a -> Map k a
dropWhileAntitone :: (k -> Bool) -> Map k a -> Map k a
spanAntitone :: (k -> Bool) -> Map k a -> (Map k a, Map k a)
restrictKeys :: Ord k => Map k a -> Set k -> Map k a
withoutKeys :: Ord k => Map k a -> Set k -> Map k a
partition :: (a -> Bool) -> Map k a -> (Map k a, Map k a)
partitionWithKey :: (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)
mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
mapEither :: (a -> Either b c) -> Map k a -> (Map k b, Map k c)
mapEitherWithKey :: (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
split :: Ord k => k -> Map k a -> (Map k a, Map k a)
splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
splitRoot :: Map k b -> [Map k b]
isSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
isProperSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
lookupIndex :: Ord k => k -> Map k a -> Maybe Int
findIndex :: Ord k => k -> Map k a -> Int
elemAt :: Int -> Map k a -> (k, a)
updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
deleteAt :: Int -> Map k a -> Map k a
take :: Int -> Map k a -> Map k a
drop :: Int -> Map k a -> Map k a
splitAt :: Int -> Map k a -> (Map k a, Map k a)
lookupMin :: Map k a -> Maybe (k, a)
lookupMax :: Map k a -> Maybe (k, a)
findMin :: Map k a -> (k, a)
findMax :: Map k a -> (k, a)
deleteMin :: Map k a -> Map k a
deleteMax :: Map k a -> Map k a
deleteFindMin :: Map k a -> ((k, a), Map k a)
deleteFindMax :: Map k a -> ((k, a), Map k a)
updateMin :: (a -> Maybe a) -> Map k a -> Map k a
updateMax :: (a -> Maybe a) -> Map k a -> Map k a
updateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
minView :: Map k a -> Maybe (a, Map k a)
maxView :: Map k a -> Maybe (a, Map k a)
minViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
maxViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
data AreWeStrict
Strict :: AreWeStrict
Lazy :: AreWeStrict
atKeyImpl :: (Functor f, Ord k) => AreWeStrict -> k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a)
atKeyPlain :: Ord k => AreWeStrict -> k -> (Maybe a -> Maybe a) -> Map k a -> Map k a
bin :: k -> a -> Map k a -> Map k a -> Map k a
balance :: k -> a -> Map k a -> Map k a -> Map k a
balanceL :: k -> a -> Map k a -> Map k a -> Map k a
balanceR :: k -> a -> Map k a -> Map k a -> Map k a
delta :: Int
insertMax :: k -> a -> Map k a -> Map k a
link :: k -> a -> Map k a -> Map k a -> Map k a
link2 :: Map k a -> Map k a -> Map k a
glue :: Map k a -> Map k a -> Map k a
data MaybeS a
NothingS :: MaybeS a
JustS :: !a -> MaybeS a
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
mapWhenMissing :: (Applicative f, Monad f) => (a -> b) -> WhenMissing f k x a -> WhenMissing f k x b
mapWhenMatched :: Functor f => (a -> b) -> WhenMatched f k x y a -> WhenMatched f k x y b
lmapWhenMissing :: (b -> a) -> WhenMissing f k a x -> WhenMissing f k b x
contramapFirstWhenMatched :: (b -> a) -> WhenMatched f k a y z -> WhenMatched f k b y z
contramapSecondWhenMatched :: (b -> a) -> WhenMatched f k x a z -> WhenMatched f k x b z
mapGentlyWhenMissing :: Functor f => (a -> b) -> WhenMissing f k x a -> WhenMissing f k x b
mapGentlyWhenMatched :: Functor f => (a -> b) -> WhenMatched f k x y a -> WhenMatched f k x y b
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Map.Internal.WhenMatched f k x y)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => Control.Category.Category (Data.Map.Internal.WhenMatched f k x)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => GHC.Base.Applicative (Data.Map.Internal.WhenMatched f k x y)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => GHC.Base.Monad (Data.Map.Internal.WhenMatched f k x y)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Functor (Data.Map.Internal.WhenMissing f k x)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => Control.Category.Category (Data.Map.Internal.WhenMissing f k)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Applicative (Data.Map.Internal.WhenMissing f k x)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Monad (Data.Map.Internal.WhenMissing f k x)
instance GHC.Classes.Ord k => GHC.Base.Monoid (Data.Map.Internal.Map k v)
instance GHC.Classes.Ord k => GHC.Base.Semigroup (Data.Map.Internal.Map k v)
instance (Data.Data.Data k, Data.Data.Data a, GHC.Classes.Ord k) => Data.Data.Data (Data.Map.Internal.Map k a)
instance GHC.Classes.Ord k => GHC.Exts.IsList (Data.Map.Internal.Map k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Map.Internal.Map k a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Data.Map.Internal.Map k v)
instance Data.Functor.Classes.Eq2 Data.Map.Internal.Map
instance GHC.Classes.Eq k => Data.Functor.Classes.Eq1 (Data.Map.Internal.Map k)
instance Data.Functor.Classes.Ord2 Data.Map.Internal.Map
instance GHC.Classes.Ord k => Data.Functor.Classes.Ord1 (Data.Map.Internal.Map k)
instance Data.Functor.Classes.Show2 Data.Map.Internal.Map
instance GHC.Show.Show k => Data.Functor.Classes.Show1 (Data.Map.Internal.Map k)
instance (GHC.Classes.Ord k, GHC.Read.Read k) => Data.Functor.Classes.Read1 (Data.Map.Internal.Map k)
instance GHC.Base.Functor (Data.Map.Internal.Map k)
instance Data.Traversable.Traversable (Data.Map.Internal.Map k)
instance Data.Foldable.Foldable (Data.Map.Internal.Map k)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Map.Internal.Map k a)
instance (GHC.Classes.Ord k, GHC.Read.Read k, GHC.Read.Read e) => GHC.Read.Read (Data.Map.Internal.Map k e)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Data.Map.Internal.Map k a)
module Data.Map.Merge.Lazy
type SimpleWhenMissing = WhenMissing Identity
type SimpleWhenMatched = WhenMatched Identity
merge :: Ord k => SimpleWhenMissing k a c -> SimpleWhenMissing k b c -> SimpleWhenMatched k a b c -> Map k a -> Map k b -> Map k c
zipWithMaybeMatched :: Applicative f => (k -> x -> y -> Maybe z) -> WhenMatched f k x y z
zipWithMatched :: Applicative f => (k -> x -> y -> z) -> WhenMatched f k x y z
mapMaybeMissing :: Applicative f => (k -> x -> Maybe y) -> WhenMissing f k x y
dropMissing :: Applicative f => WhenMissing f k x y
preserveMissing :: Applicative f => WhenMissing f k x x
mapMissing :: Applicative f => (k -> x -> y) -> WhenMissing f k x y
filterMissing :: Applicative f => (k -> x -> Bool) -> WhenMissing f k x x
data WhenMissing f k x y
data WhenMatched f k x y z
mergeA :: (Applicative f, Ord k) => WhenMissing f k a c -> WhenMissing f k b c -> WhenMatched f k a b c -> Map k a -> Map k b -> f (Map k c)
zipWithMaybeAMatched :: (k -> x -> y -> f (Maybe z)) -> WhenMatched f k x y z
zipWithAMatched :: Applicative f => (k -> x -> y -> f z) -> WhenMatched f k x y z
traverseMaybeMissing :: Applicative f => (k -> x -> f (Maybe y)) -> WhenMissing f k x y
traverseMissing :: Applicative f => (k -> x -> f y) -> WhenMissing f k x y
filterAMissing :: Applicative f => (k -> x -> f Bool) -> WhenMissing f k x x
mapWhenMissing :: (Applicative f, Monad f) => (a -> b) -> WhenMissing f k x a -> WhenMissing f k x b
mapWhenMatched :: Functor f => (a -> b) -> WhenMatched f k x y a -> WhenMatched f k x y b
lmapWhenMissing :: (b -> a) -> WhenMissing f k a x -> WhenMissing f k b x
contramapFirstWhenMatched :: (b -> a) -> WhenMatched f k a y z -> WhenMatched f k b y z
contramapSecondWhenMatched :: (b -> a) -> WhenMatched f k x a z -> WhenMatched f k x b z
runWhenMatched :: WhenMatched f k x y z -> k -> x -> y -> f (Maybe z)
runWhenMissing :: WhenMissing f k x y -> k -> x -> f (Maybe y)
module Data.Map.Internal.Debug
showTree :: (Show k, Show a) => Map k a -> String
showTreeWith :: (k -> a -> String) -> Bool -> Bool -> Map k a -> String
showsTree :: (k -> a -> String) -> Bool -> [String] -> [String] -> Map k a -> ShowS
showsTreeHang :: (k -> a -> String) -> Bool -> [String] -> Map k a -> ShowS
showWide :: Bool -> [String] -> String -> String
showsBars :: [String] -> ShowS
node :: String
withBar :: [String] -> [String]
withEmpty :: [String] -> [String]
valid :: Ord k => Map k a -> Bool
ordered :: Ord a => Map a b -> Bool
balanced :: Map k a -> Bool
validsize :: Map a b -> Bool
module Data.IntSet.Internal
data IntSet
Bin :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !Mask -> !IntSet -> !IntSet -> IntSet
Tip :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !BitMap -> IntSet
Nil :: IntSet
type Key = Int
type Prefix = Int
type Mask = Int
type BitMap = Word
(\\) :: IntSet -> IntSet -> IntSet
infixl 9 \\
null :: IntSet -> Bool
size :: IntSet -> Int
member :: Key -> IntSet -> Bool
notMember :: Key -> IntSet -> Bool
lookupLT :: Key -> IntSet -> Maybe Key
lookupGT :: Key -> IntSet -> Maybe Key
lookupLE :: Key -> IntSet -> Maybe Key
lookupGE :: Key -> IntSet -> Maybe Key
isSubsetOf :: IntSet -> IntSet -> Bool
isProperSubsetOf :: IntSet -> IntSet -> Bool
disjoint :: IntSet -> IntSet -> Bool
empty :: IntSet
singleton :: Key -> IntSet
insert :: Key -> IntSet -> IntSet
delete :: Key -> IntSet -> IntSet
union :: IntSet -> IntSet -> IntSet
unions :: Foldable f => f IntSet -> IntSet
difference :: IntSet -> IntSet -> IntSet
intersection :: IntSet -> IntSet -> IntSet
filter :: (Key -> Bool) -> IntSet -> IntSet
partition :: (Key -> Bool) -> IntSet -> (IntSet, IntSet)
split :: Key -> IntSet -> (IntSet, IntSet)
splitMember :: Key -> IntSet -> (IntSet, Bool, IntSet)
splitRoot :: IntSet -> [IntSet]
map :: (Key -> Key) -> IntSet -> IntSet
foldr :: (Key -> b -> b) -> b -> IntSet -> b
foldl :: (a -> Key -> a) -> a -> IntSet -> a
foldr' :: (Key -> b -> b) -> b -> IntSet -> b
foldl' :: (a -> Key -> a) -> a -> IntSet -> a
fold :: (Key -> b -> b) -> b -> IntSet -> b
findMin :: IntSet -> Key
findMax :: IntSet -> Key
deleteMin :: IntSet -> IntSet
deleteMax :: IntSet -> IntSet
deleteFindMin :: IntSet -> (Key, IntSet)
deleteFindMax :: IntSet -> (Key, IntSet)
maxView :: IntSet -> Maybe (Key, IntSet)
minView :: IntSet -> Maybe (Key, IntSet)
elems :: IntSet -> [Key]
toList :: IntSet -> [Key]
fromList :: [Key] -> IntSet
toAscList :: IntSet -> [Key]
toDescList :: IntSet -> [Key]
fromAscList :: [Key] -> IntSet
fromDistinctAscList :: [Key] -> IntSet
showTree :: IntSet -> String
showTreeWith :: Bool -> Bool -> IntSet -> String
match :: Int -> Prefix -> Mask -> Bool
suffixBitMask :: Int
prefixBitMask :: Int
bitmapOf :: Int -> BitMap
zero :: Int -> Mask -> Bool
instance GHC.Exts.IsList Data.IntSet.Internal.IntSet
instance GHC.Base.Monoid Data.IntSet.Internal.IntSet
instance GHC.Base.Semigroup Data.IntSet.Internal.IntSet
instance Data.Data.Data Data.IntSet.Internal.IntSet
instance GHC.Classes.Eq Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord Data.IntSet.Internal.IntSet
instance GHC.Show.Show Data.IntSet.Internal.IntSet
instance GHC.Read.Read Data.IntSet.Internal.IntSet
instance Control.DeepSeq.NFData Data.IntSet.Internal.IntSet
module Data.IntSet
data IntSet
type Key = Int
empty :: IntSet
singleton :: Key -> IntSet
fromList :: [Key] -> IntSet
fromAscList :: [Key] -> IntSet
fromDistinctAscList :: [Key] -> IntSet
insert :: Key -> IntSet -> IntSet
delete :: Key -> IntSet -> IntSet
member :: Key -> IntSet -> Bool
notMember :: Key -> IntSet -> Bool
lookupLT :: Key -> IntSet -> Maybe Key
lookupGT :: Key -> IntSet -> Maybe Key
lookupLE :: Key -> IntSet -> Maybe Key
lookupGE :: Key -> IntSet -> Maybe Key
null :: IntSet -> Bool
size :: IntSet -> Int
isSubsetOf :: IntSet -> IntSet -> Bool
isProperSubsetOf :: IntSet -> IntSet -> Bool
disjoint :: IntSet -> IntSet -> Bool
union :: IntSet -> IntSet -> IntSet
unions :: Foldable f => f IntSet -> IntSet
difference :: IntSet -> IntSet -> IntSet
(\\) :: IntSet -> IntSet -> IntSet
infixl 9 \\
intersection :: IntSet -> IntSet -> IntSet
filter :: (Key -> Bool) -> IntSet -> IntSet
partition :: (Key -> Bool) -> IntSet -> (IntSet, IntSet)
split :: Key -> IntSet -> (IntSet, IntSet)
splitMember :: Key -> IntSet -> (IntSet, Bool, IntSet)
splitRoot :: IntSet -> [IntSet]
map :: (Key -> Key) -> IntSet -> IntSet
foldr :: (Key -> b -> b) -> b -> IntSet -> b
foldl :: (a -> Key -> a) -> a -> IntSet -> a
foldr' :: (Key -> b -> b) -> b -> IntSet -> b
foldl' :: (a -> Key -> a) -> a -> IntSet -> a
fold :: (Key -> b -> b) -> b -> IntSet -> b
findMin :: IntSet -> Key
findMax :: IntSet -> Key
deleteMin :: IntSet -> IntSet
deleteMax :: IntSet -> IntSet
deleteFindMin :: IntSet -> (Key, IntSet)
deleteFindMax :: IntSet -> (Key, IntSet)
maxView :: IntSet -> Maybe (Key, IntSet)
minView :: IntSet -> Maybe (Key, IntSet)
elems :: IntSet -> [Key]
toList :: IntSet -> [Key]
toAscList :: IntSet -> [Key]
toDescList :: IntSet -> [Key]
showTree :: IntSet -> String
showTreeWith :: Bool -> Bool -> IntSet -> String
module Data.Containers.ListUtils
nubOrd :: Ord a => [a] -> [a]
nubOrdOn :: Ord b => (a -> b) -> [a] -> [a]
nubInt :: [Int] -> [Int]
nubIntOn :: (a -> Int) -> [a] -> [a]
module Data.IntMap.Internal
data IntMap a
Bin :: {-# UNPACK #-} !Prefix -> {-# UNPACK #-} !Mask -> !(IntMap a) -> !(IntMap a) -> IntMap a
Tip :: {-# UNPACK #-} !Key -> a -> IntMap a
Nil :: IntMap a
type Key = Int
(!) :: IntMap a -> Key -> a
(!?) :: IntMap a -> Key -> Maybe a
infixl 9 !?
(\\) :: IntMap a -> IntMap b -> IntMap a
infixl 9 \\
null :: IntMap a -> Bool
size :: IntMap a -> Int
member :: Key -> IntMap a -> Bool
notMember :: Key -> IntMap a -> Bool
lookup :: Key -> IntMap a -> Maybe a
findWithDefault :: a -> Key -> IntMap a -> a
lookupLT :: Key -> IntMap a -> Maybe (Key, a)
lookupGT :: Key -> IntMap a -> Maybe (Key, a)
lookupLE :: Key -> IntMap a -> Maybe (Key, a)
lookupGE :: Key -> IntMap a -> Maybe (Key, a)
empty :: IntMap a
singleton :: Key -> a -> IntMap a
insert :: Key -> a -> IntMap a -> IntMap a
insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
delete :: Key -> IntMap a -> IntMap a
adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
adjustWithKey :: (Key -> a -> a) -> Key -> IntMap a -> IntMap a
update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
alter :: (Maybe a -> Maybe a) -> Key -> IntMap a -> IntMap a
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)
union :: IntMap a -> IntMap a -> IntMap a
unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unions :: Foldable f => f (IntMap a) -> IntMap a
unionsWith :: Foldable f => (a -> a -> a) -> f (IntMap a) -> IntMap a
difference :: IntMap a -> IntMap b -> IntMap a
differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
differenceWithKey :: (Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
intersection :: IntMap a -> IntMap b -> IntMap a
intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
intersectionWithKey :: (Key -> a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
type SimpleWhenMissing = WhenMissing Identity
type SimpleWhenMatched = WhenMatched Identity
runWhenMatched :: WhenMatched f x y z -> Key -> x -> y -> f (Maybe z)
runWhenMissing :: WhenMissing f x y -> Key -> x -> f (Maybe y)
merge :: SimpleWhenMissing a c -> SimpleWhenMissing b c -> SimpleWhenMatched a b c -> IntMap a -> IntMap b -> IntMap c
zipWithMaybeMatched :: Applicative f => (Key -> x -> y -> Maybe z) -> WhenMatched f x y z
zipWithMatched :: Applicative f => (Key -> x -> y -> z) -> WhenMatched f x y z
mapMaybeMissing :: Applicative f => (Key -> x -> Maybe y) -> WhenMissing f x y
dropMissing :: Applicative f => WhenMissing f x y
preserveMissing :: Applicative f => WhenMissing f x x
mapMissing :: Applicative f => (Key -> x -> y) -> WhenMissing f x y
filterMissing :: Applicative f => (Key -> x -> Bool) -> WhenMissing f x x
data WhenMissing f x y
WhenMissing :: IntMap x -> f (IntMap y) -> Key -> x -> f (Maybe y) -> WhenMissing f x y
[missingSubtree] :: WhenMissing f x y -> IntMap x -> f (IntMap y)
[missingKey] :: WhenMissing f x y -> Key -> x -> f (Maybe y)
newtype WhenMatched f x y z
WhenMatched :: Key -> x -> y -> f (Maybe z) -> WhenMatched f x y z
[matchedKey] :: WhenMatched f x y z -> Key -> x -> y -> f (Maybe z)
mergeA :: (Applicative f) => WhenMissing f a c -> WhenMissing f b c -> WhenMatched f a b c -> IntMap a -> IntMap b -> f (IntMap c)
zipWithMaybeAMatched :: (Key -> x -> y -> f (Maybe z)) -> WhenMatched f x y z
zipWithAMatched :: Applicative f => (Key -> x -> y -> f z) -> WhenMatched f x y z
traverseMaybeMissing :: Applicative f => (Key -> x -> f (Maybe y)) -> WhenMissing f x y
traverseMissing :: Applicative f => (Key -> x -> f y) -> WhenMissing f x y
filterAMissing :: Applicative f => (Key -> x -> f Bool) -> WhenMissing f x x
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (IntMap a -> IntMap c) -> (IntMap b -> IntMap c) -> IntMap a -> IntMap b -> IntMap c
mergeWithKey' :: (Prefix -> Mask -> IntMap c -> IntMap c -> IntMap c) -> (IntMap a -> IntMap b -> IntMap c) -> (IntMap a -> IntMap c) -> (IntMap b -> IntMap c) -> IntMap a -> IntMap b -> IntMap c
map :: (a -> b) -> IntMap a -> IntMap b
mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
traverseWithKey :: Applicative t => (Key -> a -> t b) -> IntMap a -> t (IntMap b)
mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapKeys :: (Key -> Key) -> IntMap a -> IntMap a
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> IntMap a -> IntMap a
mapKeysMonotonic :: (Key -> Key) -> IntMap a -> IntMap a
foldr :: (a -> b -> b) -> b -> IntMap a -> b
foldl :: (a -> b -> a) -> a -> IntMap b -> a
foldrWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldlWithKey :: (a -> Key -> b -> a) -> a -> IntMap b -> a
foldMapWithKey :: Monoid m => (Key -> a -> m) -> IntMap a -> m
foldr' :: (a -> b -> b) -> b -> IntMap a -> b
foldl' :: (a -> b -> a) -> a -> IntMap b -> a
foldrWithKey' :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldlWithKey' :: (a -> Key -> b -> a) -> a -> IntMap b -> a
elems :: IntMap a -> [a]
keys :: IntMap a -> [Key]
assocs :: IntMap a -> [(Key, a)]
keysSet :: IntMap a -> IntSet
fromSet :: (Key -> a) -> IntSet -> IntMap a
toList :: IntMap a -> [(Key, a)]
fromList :: [(Key, a)] -> IntMap a
fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
toAscList :: IntMap a -> [(Key, a)]
toDescList :: IntMap a -> [(Key, a)]
fromAscList :: [(Key, a)] -> IntMap a
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
fromDistinctAscList :: forall a. [(Key, a)] -> IntMap a
filter :: (a -> Bool) -> IntMap a -> IntMap a
filterWithKey :: (Key -> a -> Bool) -> IntMap a -> IntMap a
restrictKeys :: IntMap a -> IntSet -> IntMap a
withoutKeys :: IntMap a -> IntSet -> IntMap a
partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
partitionWithKey :: (Key -> a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
mapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b
mapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
mapEitherWithKey :: (Key -> a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
split :: Key -> IntMap a -> (IntMap a, IntMap a)
splitLookup :: Key -> IntMap a -> (IntMap a, Maybe a, IntMap a)
splitRoot :: IntMap a -> [IntMap a]
isSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isProperSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
lookupMin :: IntMap a -> Maybe (Key, a)
lookupMax :: IntMap a -> Maybe (Key, a)
findMin :: IntMap a -> (Key, a)
findMax :: IntMap a -> (Key, a)
deleteMin :: IntMap a -> IntMap a
deleteMax :: IntMap a -> IntMap a
deleteFindMin :: IntMap a -> ((Key, a), IntMap a)
deleteFindMax :: IntMap a -> ((Key, a), IntMap a)
updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
updateMinWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a
updateMaxWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a
minView :: IntMap a -> Maybe (a, IntMap a)
maxView :: IntMap a -> Maybe (a, IntMap a)
minViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)
maxViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)
showTree :: Show a => IntMap a -> String
showTreeWith :: Show a => Bool -> Bool -> IntMap a -> String
type Mask = Int
type Prefix = Int
type Nat = Word
natFromInt :: Key -> Nat
intFromNat :: Nat -> Key
link :: Prefix -> IntMap a -> Prefix -> IntMap a -> IntMap a
bin :: Prefix -> Mask -> IntMap a -> IntMap a -> IntMap a
binCheckLeft :: Prefix -> Mask -> IntMap a -> IntMap a -> IntMap a
binCheckRight :: Prefix -> Mask -> IntMap a -> IntMap a -> IntMap a
zero :: Key -> Mask -> Bool
nomatch :: Key -> Prefix -> Mask -> Bool
match :: Key -> Prefix -> Mask -> Bool
mask :: Key -> Mask -> Prefix
maskW :: Nat -> Nat -> Prefix
shorter :: Mask -> Mask -> Bool
branchMask :: Prefix -> Prefix -> Mask
highestBitMask :: Word -> Word
mapWhenMissing :: (Applicative f, Monad f) => (a -> b) -> WhenMissing f x a -> WhenMissing f x b
mapWhenMatched :: Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b
lmapWhenMissing :: (b -> a) -> WhenMissing f a x -> WhenMissing f b x
contramapFirstWhenMatched :: (b -> a) -> WhenMatched f a y z -> WhenMatched f b y z
contramapSecondWhenMatched :: (b -> a) -> WhenMatched f x a z -> WhenMatched f x b z
mapGentlyWhenMissing :: Functor f => (a -> b) -> WhenMissing f x a -> WhenMissing f x b
mapGentlyWhenMatched :: Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b
instance GHC.Base.Functor f => GHC.Base.Functor (Data.IntMap.Internal.WhenMatched f x y)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => Control.Category.Category (Data.IntMap.Internal.WhenMatched f x)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => GHC.Base.Applicative (Data.IntMap.Internal.WhenMatched f x y)
instance (GHC.Base.Monad f, GHC.Base.Applicative f) => GHC.Base.Monad (Data.IntMap.Internal.WhenMatched f x y)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Functor (Data.IntMap.Internal.WhenMissing f x)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => Control.Category.Category (Data.IntMap.Internal.WhenMissing f)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Applicative (Data.IntMap.Internal.WhenMissing f x)
instance (GHC.Base.Applicative f, GHC.Base.Monad f) => GHC.Base.Monad (Data.IntMap.Internal.WhenMissing f x)
instance GHC.Base.Monoid (Data.IntMap.Internal.IntMap a)
instance GHC.Base.Semigroup (Data.IntMap.Internal.IntMap a)
instance Data.Foldable.Foldable Data.IntMap.Internal.IntMap
instance Data.Traversable.Traversable Data.IntMap.Internal.IntMap
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.IntMap.Internal.IntMap a)
instance Data.Data.Data a => Data.Data.Data (Data.IntMap.Internal.IntMap a)
instance GHC.Exts.IsList (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.IntMap.Internal.IntMap a)
instance Data.Functor.Classes.Eq1 Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.IntMap.Internal.IntMap a)
instance Data.Functor.Classes.Ord1 Data.IntMap.Internal.IntMap
instance GHC.Base.Functor Data.IntMap.Internal.IntMap
instance GHC.Show.Show a => GHC.Show.Show (Data.IntMap.Internal.IntMap a)
instance Data.Functor.Classes.Show1 Data.IntMap.Internal.IntMap
instance GHC.Read.Read e => GHC.Read.Read (Data.IntMap.Internal.IntMap e)
instance Data.Functor.Classes.Read1 Data.IntMap.Internal.IntMap
module Data.IntMap.Merge.Strict
type SimpleWhenMissing = WhenMissing Identity
type SimpleWhenMatched = WhenMatched Identity
merge :: SimpleWhenMissing a c -> SimpleWhenMissing b c -> SimpleWhenMatched a b c -> IntMap a -> IntMap b -> IntMap c
zipWithMaybeMatched :: Applicative f => (Key -> x -> y -> Maybe z) -> WhenMatched f x y z
zipWithMatched :: Applicative f => (Key -> x -> y -> z) -> WhenMatched f x y z
mapMaybeMissing :: Applicative f => (Key -> x -> Maybe y) -> WhenMissing f x y
dropMissing :: Applicative f => WhenMissing f x y
preserveMissing :: Applicative f => WhenMissing f x x
mapMissing :: Applicative f => (Key -> x -> y) -> WhenMissing f x y
filterMissing :: Applicative f => (Key -> x -> Bool) -> WhenMissing f x x
data WhenMissing f x y
data WhenMatched f x y z
mergeA :: (Applicative f) => WhenMissing f a c -> WhenMissing f b c -> WhenMatched f a b c -> IntMap a -> IntMap b -> f (IntMap c)
zipWithMaybeAMatched :: (Key -> x -> y -> f (Maybe z)) -> WhenMatched f x y z
zipWithAMatched :: Applicative f => (Key -> x -> y -> f z) -> WhenMatched f x y z
traverseMaybeMissing :: Applicative f => (Key -> x -> f (Maybe y)) -> WhenMissing f x y
traverseMissing :: Applicative f => (Key -> x -> f y) -> WhenMissing f x y
filterAMissing :: Applicative f => (Key -> x -> f Bool) -> WhenMissing f x x
mapWhenMissing :: (Applicative f, Monad f) => (a -> b) -> WhenMissing f x a -> WhenMissing f x b
mapWhenMatched :: Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b
runWhenMatched :: WhenMatched f x y z -> Key -> x -> y -> f (Maybe z)
runWhenMissing :: WhenMissing f x y -> Key -> x -> f (Maybe y)
module Data.IntMap.Merge.Lazy
type SimpleWhenMissing = WhenMissing Identity
type SimpleWhenMatched = WhenMatched Identity
merge :: SimpleWhenMissing a c -> SimpleWhenMissing b c -> SimpleWhenMatched a b c -> IntMap a -> IntMap b -> IntMap c
zipWithMaybeMatched :: Applicative f => (Key -> x -> y -> Maybe z) -> WhenMatched f x y z
zipWithMatched :: Applicative f => (Key -> x -> y -> z) -> WhenMatched f x y z
mapMaybeMissing :: Applicative f => (Key -> x -> Maybe y) -> WhenMissing f x y
dropMissing :: Applicative f => WhenMissing f x y
preserveMissing :: Applicative f => WhenMissing f x x
mapMissing :: Applicative f => (Key -> x -> y) -> WhenMissing f x y
filterMissing :: Applicative f => (Key -> x -> Bool) -> WhenMissing f x x
data WhenMissing f x y
data WhenMatched f x y z
mergeA :: (Applicative f) => WhenMissing f a c -> WhenMissing f b c -> WhenMatched f a b c -> IntMap a -> IntMap b -> f (IntMap c)
zipWithMaybeAMatched :: (Key -> x -> y -> f (Maybe z)) -> WhenMatched f x y z
zipWithAMatched :: Applicative f => (Key -> x -> y -> f z) -> WhenMatched f x y z
traverseMaybeMissing :: Applicative f => (Key -> x -> f (Maybe y)) -> WhenMissing f x y
traverseMissing :: Applicative f => (Key -> x -> f y) -> WhenMissing f x y
filterAMissing :: Applicative f => (Key -> x -> f Bool) -> WhenMissing f x x
mapWhenMissing :: (Applicative f, Monad f) => (a -> b) -> WhenMissing f x a -> WhenMissing f x b
mapWhenMatched :: Functor f => (a -> b) -> WhenMatched f x y a -> WhenMatched f x y b
lmapWhenMissing :: (b -> a) -> WhenMissing f a x -> WhenMissing f b x
contramapFirstWhenMatched :: (b -> a) -> WhenMatched f a y z -> WhenMatched f b y z
contramapSecondWhenMatched :: (b -> a) -> WhenMatched f x a z -> WhenMatched f x b z
runWhenMatched :: WhenMatched f x y z -> Key -> x -> y -> f (Maybe z)
runWhenMissing :: WhenMissing f x y -> Key -> x -> f (Maybe y)
module Data.IntMap.Internal.Debug
showTree :: Show a => IntMap a -> String
showTreeWith :: Show a => Bool -> Bool -> IntMap a -> String
module Data.Map.Strict.Internal
data Map k a
Bin :: {-# UNPACK #-} !Size -> !k -> a -> !(Map k a) -> !(Map k a) -> Map k a
Tip :: Map k a
type Size = Int
(!) :: Ord k => Map k a -> k -> a
infixl 9 !
(!?) :: Ord k => Map k a -> k -> Maybe a
infixl 9 !?
(\\) :: Ord k => Map k a -> Map k b -> Map k a
infixl 9 \\
null :: Map k a -> Bool
size :: Map k a -> Int
member :: Ord k => k -> Map k a -> Bool
notMember :: Ord k => k -> Map k a -> Bool
lookup :: Ord k => k -> Map k a -> Maybe a
findWithDefault :: Ord k => a -> k -> Map k a -> a
lookupLT :: Ord k => k -> Map k v -> Maybe (k, v)
lookupGT :: Ord k => k -> Map k v -> Maybe (k, v)
lookupLE :: Ord k => k -> Map k v -> Maybe (k, v)
lookupGE :: Ord k => k -> Map k v -> Maybe (k, v)
empty :: Map k a
singleton :: k -> a -> Map k a
insert :: Ord k => k -> a -> Map k a -> Map k a
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
delete :: Ord k => k -> Map k a -> Map k a
adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
alterF :: (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> Map k a -> f (Map k a)
union :: Ord k => Map k a -> Map k a -> Map k a
unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
unions :: (Foldable f, Ord k) => f (Map k a) -> Map k a
unionsWith :: (Foldable f, Ord k) => (a -> a -> a) -> f (Map k a) -> Map k a
difference :: Ord k => Map k a -> Map k b -> Map k a
differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
intersection :: Ord k => Map k a -> Map k b -> Map k a
intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
type SimpleWhenMissing = WhenMissing Identity
type SimpleWhenMatched = WhenMatched Identity
merge :: Ord k => SimpleWhenMissing k a c -> SimpleWhenMissing k b c -> SimpleWhenMatched k a b c -> Map k a -> Map k b -> Map k c
runWhenMatched :: WhenMatched f k x y z -> k -> x -> y -> f (Maybe z)
runWhenMissing :: WhenMissing f k x y -> k -> x -> f (Maybe y)
zipWithMaybeMatched :: Applicative f => (k -> x -> y -> Maybe z) -> WhenMatched f k x y z
zipWithMatched :: Applicative f => (k -> x -> y -> z) -> WhenMatched f k x y z
mapMaybeMissing :: Applicative f => (k -> x -> Maybe y) -> WhenMissing f k x y
dropMissing :: Applicative f => WhenMissing f k x y
preserveMissing :: Applicative f => WhenMissing f k x x
mapMissing :: Applicative f => (k -> x -> y) -> WhenMissing f k x y
filterMissing :: Applicative f => (k -> x -> Bool) -> WhenMissing f k x x
data WhenMissing f k x y
WhenMissing :: Map k x -> f (Map k y) -> k -> x -> f (Maybe y) -> WhenMissing f k x y
[missingSubtree] :: WhenMissing f k x y -> Map k x -> f (Map k y)
[missingKey] :: WhenMissing f k x y -> k -> x -> f (Maybe y)
newtype WhenMatched f k x y z
WhenMatched :: k -> x -> y -> f (Maybe z) -> WhenMatched f k x y z
[matchedKey] :: WhenMatched f k x y z -> k -> x -> y -> f (Maybe z)
mergeA :: (Applicative f, Ord k) => WhenMissing f k a c -> WhenMissing f k b c -> WhenMatched f k a b c -> Map k a -> Map k b -> f (Map k c)
zipWithMaybeAMatched :: Applicative f => (k -> x -> y -> f (Maybe z)) -> WhenMatched f k x y z
zipWithAMatched :: Applicative f => (k -> x -> y -> f z) -> WhenMatched f k x y z
traverseMaybeMissing :: Applicative f => (k -> x -> f (Maybe y)) -> WhenMissing f k x y
traverseMissing :: Applicative f => (k -> x -> f y) -> WhenMissing f k x y
filterAMissing :: Applicative f => (k -> x -> f Bool) -> WhenMissing f k x x
mapWhenMissing :: Functor f => (a -> b) -> WhenMissing f k x a -> WhenMissing f k x b
mapWhenMatched :: Functor f => (a -> b) -> WhenMatched f k x y a -> WhenMatched f k x y b
mergeWithKey :: Ord k => (k -> a -> b -> Maybe c) -> (Map k a -> Map k c) -> (Map k b -> Map k c) -> Map k a -> Map k b -> Map k c
map :: (a -> b) -> Map k a -> Map k b
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
traverseWithKey :: Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)
traverseMaybeWithKey :: Applicative f => (k -> a -> f (Maybe b)) -> Map k a -> f (Map k b)
mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
foldr :: (a -> b -> b) -> b -> Map k a -> b
foldl :: (a -> b -> a) -> a -> Map k b -> a
foldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
foldlWithKey :: (a -> k -> b -> a) -> a -> Map k b -> a
foldMapWithKey :: Monoid m => (k -> a -> m) -> Map k a -> m
foldr' :: (a -> b -> b) -> b -> Map k a -> b
foldl' :: (a -> b -> a) -> a -> Map k b -> a
foldrWithKey' :: (k -> a -> b -> b) -> b -> Map k a -> b
foldlWithKey' :: (a -> k -> b -> a) -> a -> Map k b -> a
elems :: Map k a -> [a]
keys :: Map k a -> [k]
assocs :: Map k a -> [(k, a)]
keysSet :: Map k a -> Set k
fromSet :: (k -> a) -> Set k -> Map k a
toList :: Map k a -> [(k, a)]
fromList :: Ord k => [(k, a)] -> Map k a
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
toAscList :: Map k a -> [(k, a)]
toDescList :: Map k a -> [(k, a)]
fromAscList :: Eq k => [(k, a)] -> Map k a
fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctAscList :: [(k, a)] -> Map k a
fromDescList :: Eq k => [(k, a)] -> Map k a
fromDescListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromDescListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctDescList :: [(k, a)] -> Map k a
filter :: (a -> Bool) -> Map k a -> Map k a
filterWithKey :: (k -> a -> Bool) -> Map k a -> Map k a
restrictKeys :: Ord k => Map k a -> Set k -> Map k a
withoutKeys :: Ord k => Map k a -> Set k -> Map k a
partition :: (a -> Bool) -> Map k a -> (Map k a, Map k a)
partitionWithKey :: (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)
takeWhileAntitone :: (k -> Bool) -> Map k a -> Map k a
dropWhileAntitone :: (k -> Bool) -> Map k a -> Map k a
spanAntitone :: (k -> Bool) -> Map k a -> (Map k a, Map k a)
mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
mapEither :: (a -> Either b c) -> Map k a -> (Map k b, Map k c)
mapEitherWithKey :: (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
split :: Ord k => k -> Map k a -> (Map k a, Map k a)
splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
splitRoot :: Map k b -> [Map k b]
isSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
isProperSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
lookupIndex :: Ord k => k -> Map k a -> Maybe Int
findIndex :: Ord k => k -> Map k a -> Int
elemAt :: Int -> Map k a -> (k, a)
updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
deleteAt :: Int -> Map k a -> Map k a
take :: Int -> Map k a -> Map k a
drop :: Int -> Map k a -> Map k a
splitAt :: Int -> Map k a -> (Map k a, Map k a)
lookupMin :: Map k a -> Maybe (k, a)
lookupMax :: Map k a -> Maybe (k, a)
findMin :: Map k a -> (k, a)
findMax :: Map k a -> (k, a)
deleteMin :: Map k a -> Map k a
deleteMax :: Map k a -> Map k a
deleteFindMin :: Map k a -> ((k, a), Map k a)
deleteFindMax :: Map k a -> ((k, a), Map k a)
updateMin :: (a -> Maybe a) -> Map k a -> Map k a
updateMax :: (a -> Maybe a) -> Map k a -> Map k a
updateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
minView :: Map k a -> Maybe (a, Map k a)
maxView :: Map k a -> Maybe (a, Map k a)
minViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
maxViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
showTree :: Whoops "showTree has moved to Data.Map.Internal.Debug.showTree." => Map k a -> String
showTreeWith :: Whoops "showTreeWith has moved to Data.Map.Internal.Debug.showTreeWith." => (k -> a -> String) -> Bool -> Bool -> Map k a -> String
valid :: Ord k => Map k a -> Bool
module Data.Map.Strict
data Map k a
empty :: Map k a
singleton :: k -> a -> Map k a
fromSet :: (k -> a) -> Set k -> Map k a
fromList :: Ord k => [(k, a)] -> Map k a
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromAscList :: Eq k => [(k, a)] -> Map k a
fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctAscList :: [(k, a)] -> Map k a
fromDescList :: Eq k => [(k, a)] -> Map k a
fromDescListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromDescListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctDescList :: [(k, a)] -> Map k a
insert :: Ord k => k -> a -> Map k a -> Map k a
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
delete :: Ord k => k -> Map k a -> Map k a
adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
alterF :: (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> Map k a -> f (Map k a)
lookup :: Ord k => k -> Map k a -> Maybe a
(!?) :: Ord k => Map k a -> k -> Maybe a
infixl 9 !?
(!) :: Ord k => Map k a -> k -> a
infixl 9 !
findWithDefault :: Ord k => a -> k -> Map k a -> a
member :: Ord k => k -> Map k a -> Bool
notMember :: Ord k => k -> Map k a -> Bool
lookupLT :: Ord k => k -> Map k v -> Maybe (k, v)
lookupGT :: Ord k => k -> Map k v -> Maybe (k, v)
lookupLE :: Ord k => k -> Map k v -> Maybe (k, v)
lookupGE :: Ord k => k -> Map k v -> Maybe (k, v)
null :: Map k a -> Bool
size :: Map k a -> Int
union :: Ord k => Map k a -> Map k a -> Map k a
unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
unions :: (Foldable f, Ord k) => f (Map k a) -> Map k a
unionsWith :: (Foldable f, Ord k) => (a -> a -> a) -> f (Map k a) -> Map k a
difference :: Ord k => Map k a -> Map k b -> Map k a
(\\) :: Ord k => Map k a -> Map k b -> Map k a
infixl 9 \\
differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
intersection :: Ord k => Map k a -> Map k b -> Map k a
intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
mergeWithKey :: Ord k => (k -> a -> b -> Maybe c) -> (Map k a -> Map k c) -> (Map k b -> Map k c) -> Map k a -> Map k b -> Map k c
map :: (a -> b) -> Map k a -> Map k b
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
traverseWithKey :: Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)
traverseMaybeWithKey :: Applicative f => (k -> a -> f (Maybe b)) -> Map k a -> f (Map k b)
mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
foldr :: (a -> b -> b) -> b -> Map k a -> b
foldl :: (a -> b -> a) -> a -> Map k b -> a
foldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
foldlWithKey :: (a -> k -> b -> a) -> a -> Map k b -> a
foldMapWithKey :: Monoid m => (k -> a -> m) -> Map k a -> m
foldr' :: (a -> b -> b) -> b -> Map k a -> b
foldl' :: (a -> b -> a) -> a -> Map k b -> a
foldrWithKey' :: (k -> a -> b -> b) -> b -> Map k a -> b
foldlWithKey' :: (a -> k -> b -> a) -> a -> Map k b -> a
elems :: Map k a -> [a]
keys :: Map k a -> [k]
assocs :: Map k a -> [(k, a)]
keysSet :: Map k a -> Set k
toList :: Map k a -> [(k, a)]
toAscList :: Map k a -> [(k, a)]
toDescList :: Map k a -> [(k, a)]
filter :: (a -> Bool) -> Map k a -> Map k a
filterWithKey :: (k -> a -> Bool) -> Map k a -> Map k a
restrictKeys :: Ord k => Map k a -> Set k -> Map k a
withoutKeys :: Ord k => Map k a -> Set k -> Map k a
partition :: (a -> Bool) -> Map k a -> (Map k a, Map k a)
partitionWithKey :: (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)
takeWhileAntitone :: (k -> Bool) -> Map k a -> Map k a
dropWhileAntitone :: (k -> Bool) -> Map k a -> Map k a
spanAntitone :: (k -> Bool) -> Map k a -> (Map k a, Map k a)
mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
mapEither :: (a -> Either b c) -> Map k a -> (Map k b, Map k c)
mapEitherWithKey :: (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
split :: Ord k => k -> Map k a -> (Map k a, Map k a)
splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
splitRoot :: Map k b -> [Map k b]
isSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
isProperSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
lookupIndex :: Ord k => k -> Map k a -> Maybe Int
findIndex :: Ord k => k -> Map k a -> Int
elemAt :: Int -> Map k a -> (k, a)
updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
deleteAt :: Int -> Map k a -> Map k a
take :: Int -> Map k a -> Map k a
drop :: Int -> Map k a -> Map k a
splitAt :: Int -> Map k a -> (Map k a, Map k a)
lookupMin :: Map k a -> Maybe (k, a)
lookupMax :: Map k a -> Maybe (k, a)
findMin :: Map k a -> (k, a)
findMax :: Map k a -> (k, a)
deleteMin :: Map k a -> Map k a
deleteMax :: Map k a -> Map k a
deleteFindMin :: Map k a -> ((k, a), Map k a)
deleteFindMax :: Map k a -> ((k, a), Map k a)
updateMin :: (a -> Maybe a) -> Map k a -> Map k a
updateMax :: (a -> Maybe a) -> Map k a -> Map k a
updateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
minView :: Map k a -> Maybe (a, Map k a)
maxView :: Map k a -> Maybe (a, Map k a)
minViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
maxViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
showTree :: Whoops "showTree has moved to Data.Map.Internal.Debug.showTree." => Map k a -> String
showTreeWith :: Whoops "showTreeWith has moved to Data.Map.Internal.Debug.showTreeWith." => (k -> a -> String) -> Bool -> Bool -> Map k a -> String
valid :: Ord k => Map k a -> Bool
module Data.Map.Merge.Strict
type SimpleWhenMissing = WhenMissing Identity
type SimpleWhenMatched = WhenMatched Identity
merge :: Ord k => SimpleWhenMissing k a c -> SimpleWhenMissing k b c -> SimpleWhenMatched k a b c -> Map k a -> Map k b -> Map k c
zipWithMaybeMatched :: Applicative f => (k -> x -> y -> Maybe z) -> WhenMatched f k x y z
zipWithMatched :: Applicative f => (k -> x -> y -> z) -> WhenMatched f k x y z
mapMaybeMissing :: Applicative f => (k -> x -> Maybe y) -> WhenMissing f k x y
dropMissing :: Applicative f => WhenMissing f k x y
preserveMissing :: Applicative f => WhenMissing f k x x
mapMissing :: Applicative f => (k -> x -> y) -> WhenMissing f k x y
filterMissing :: Applicative f => (k -> x -> Bool) -> WhenMissing f k x x
data WhenMissing f k x y
data WhenMatched f k x y z
mergeA :: (Applicative f, Ord k) => WhenMissing f k a c -> WhenMissing f k b c -> WhenMatched f k a b c -> Map k a -> Map k b -> f (Map k c)
zipWithMaybeAMatched :: Applicative f => (k -> x -> y -> f (Maybe z)) -> WhenMatched f k x y z
zipWithAMatched :: Applicative f => (k -> x -> y -> f z) -> WhenMatched f k x y z
traverseMaybeMissing :: Applicative f => (k -> x -> f (Maybe y)) -> WhenMissing f k x y
traverseMissing :: Applicative f => (k -> x -> f y) -> WhenMissing f k x y
filterAMissing :: Applicative f => (k -> x -> f Bool) -> WhenMissing f k x x
mapWhenMissing :: Functor f => (a -> b) -> WhenMissing f k x a -> WhenMissing f k x b
mapWhenMatched :: Functor f => (a -> b) -> WhenMatched f k x y a -> WhenMatched f k x y b
runWhenMatched :: WhenMatched f k x y z -> k -> x -> y -> f (Maybe z)
runWhenMissing :: WhenMissing f k x y -> k -> x -> f (Maybe y)
module Data.Map.Lazy
data Map k a
empty :: Map k a
singleton :: k -> a -> Map k a
fromSet :: (k -> a) -> Set k -> Map k a
fromList :: Ord k => [(k, a)] -> Map k a
fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromAscList :: Eq k => [(k, a)] -> Map k a
fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctAscList :: [(k, a)] -> Map k a
fromDescList :: Eq k => [(k, a)] -> Map k a
fromDescListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
fromDescListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
fromDistinctDescList :: [(k, a)] -> Map k a
insert :: Ord k => k -> a -> Map k a -> Map k a
insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
delete :: Ord k => k -> Map k a -> Map k a
adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
updateWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> Map k a
updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
alterF :: (Functor f, Ord k) => (Maybe a -> f (Maybe a)) -> k -> Map k a -> f (Map k a)
lookup :: Ord k => k -> Map k a -> Maybe a
(!?) :: Ord k => Map k a -> k -> Maybe a
infixl 9 !?
(!) :: Ord k => Map k a -> k -> a
infixl 9 !
findWithDefault :: Ord k => a -> k -> Map k a -> a
member :: Ord k => k -> Map k a -> Bool
notMember :: Ord k => k -> Map k a -> Bool
lookupLT :: Ord k => k -> Map k v -> Maybe (k, v)
lookupGT :: Ord k => k -> Map k v -> Maybe (k, v)
lookupLE :: Ord k => k -> Map k v -> Maybe (k, v)
lookupGE :: Ord k => k -> Map k v -> Maybe (k, v)
null :: Map k a -> Bool
size :: Map k a -> Int
union :: Ord k => Map k a -> Map k a -> Map k a
unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
unions :: (Foldable f, Ord k) => f (Map k a) -> Map k a
unionsWith :: (Foldable f, Ord k) => (a -> a -> a) -> f (Map k a) -> Map k a
difference :: Ord k => Map k a -> Map k b -> Map k a
(\\) :: Ord k => Map k a -> Map k b -> Map k a
infixl 9 \\
differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
differenceWithKey :: Ord k => (k -> a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
intersection :: Ord k => Map k a -> Map k b -> Map k a
intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
intersectionWithKey :: Ord k => (k -> a -> b -> c) -> Map k a -> Map k b -> Map k c
mergeWithKey :: Ord k => (k -> a -> b -> Maybe c) -> (Map k a -> Map k c) -> (Map k b -> Map k c) -> Map k a -> Map k b -> Map k c
map :: (a -> b) -> Map k a -> Map k b
mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
traverseWithKey :: Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)
traverseMaybeWithKey :: Applicative f => (k -> a -> f (Maybe b)) -> Map k a -> f (Map k b)
mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapAccumRWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
foldr :: (a -> b -> b) -> b -> Map k a -> b
foldl :: (a -> b -> a) -> a -> Map k b -> a
foldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b
foldlWithKey :: (a -> k -> b -> a) -> a -> Map k b -> a
foldMapWithKey :: Monoid m => (k -> a -> m) -> Map k a -> m
foldr' :: (a -> b -> b) -> b -> Map k a -> b
foldl' :: (a -> b -> a) -> a -> Map k b -> a
foldrWithKey' :: (k -> a -> b -> b) -> b -> Map k a -> b
foldlWithKey' :: (a -> k -> b -> a) -> a -> Map k b -> a
elems :: Map k a -> [a]
keys :: Map k a -> [k]
assocs :: Map k a -> [(k, a)]
keysSet :: Map k a -> Set k
toList :: Map k a -> [(k, a)]
toAscList :: Map k a -> [(k, a)]
toDescList :: Map k a -> [(k, a)]
filter :: (a -> Bool) -> Map k a -> Map k a
filterWithKey :: (k -> a -> Bool) -> Map k a -> Map k a
restrictKeys :: Ord k => Map k a -> Set k -> Map k a
withoutKeys :: Ord k => Map k a -> Set k -> Map k a
partition :: (a -> Bool) -> Map k a -> (Map k a, Map k a)
partitionWithKey :: (k -> a -> Bool) -> Map k a -> (Map k a, Map k a)
takeWhileAntitone :: (k -> Bool) -> Map k a -> Map k a
dropWhileAntitone :: (k -> Bool) -> Map k a -> Map k a
spanAntitone :: (k -> Bool) -> Map k a -> (Map k a, Map k a)
mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
mapEither :: (a -> Either b c) -> Map k a -> (Map k b, Map k c)
mapEitherWithKey :: (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
split :: Ord k => k -> Map k a -> (Map k a, Map k a)
splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
splitRoot :: Map k b -> [Map k b]
isSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
isProperSubmapOf :: (Ord k, Eq a) => Map k a -> Map k a -> Bool
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> Map k a -> Map k b -> Bool
lookupIndex :: Ord k => k -> Map k a -> Maybe Int
findIndex :: Ord k => k -> Map k a -> Int
elemAt :: Int -> Map k a -> (k, a)
updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
deleteAt :: Int -> Map k a -> Map k a
take :: Int -> Map k a -> Map k a
drop :: Int -> Map k a -> Map k a
splitAt :: Int -> Map k a -> (Map k a, Map k a)
lookupMin :: Map k a -> Maybe (k, a)
lookupMax :: Map k a -> Maybe (k, a)
findMin :: Map k a -> (k, a)
findMax :: Map k a -> (k, a)
deleteMin :: Map k a -> Map k a
deleteMax :: Map k a -> Map k a
deleteFindMin :: Map k a -> ((k, a), Map k a)
deleteFindMax :: Map k a -> ((k, a), Map k a)
updateMin :: (a -> Maybe a) -> Map k a -> Map k a
updateMax :: (a -> Maybe a) -> Map k a -> Map k a
updateMinWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
minView :: Map k a -> Maybe (a, Map k a)
maxView :: Map k a -> Maybe (a, Map k a)
minViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
maxViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
showTree :: Whoops "showTree has moved to Data.Map.Internal.Debug.showTree." => Map k a -> String
showTreeWith :: Whoops "showTreeWith has moved to Data.Map.Internal.Debug.showTreeWith." => (k -> a -> String) -> Bool -> Bool -> Map k a -> String
valid :: Ord k => Map k a -> Bool
module Data.Map
insertWith' :: Whoops "Data.Map.insertWith' is gone. Use Data.Map.Strict.insertWith." => (a -> a -> a) -> k -> a -> Map k a -> Map k a
insertWithKey' :: Whoops "Data.Map.insertWithKey' is gone. Use Data.Map.Strict.insertWithKey." => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
insertLookupWithKey' :: Whoops "Data.Map.insertLookupWithKey' is gone. Use Data.Map.Strict.insertLookupWithKey." => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
fold :: Whoops "Data.Map.fold is gone. Use foldr." => (a -> b -> b) -> b -> Map k a -> b
foldWithKey :: Whoops "Data.Map.foldWithKey is gone. Use foldrWithKey." => (k -> a -> b -> b) -> b -> Map k a -> b
module Data.IntMap.Strict
data IntMap a
type Key = Int
empty :: IntMap a
singleton :: Key -> a -> IntMap a
fromSet :: (Key -> a) -> IntSet -> IntMap a
fromList :: [(Key, a)] -> IntMap a
fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
fromAscList :: [(Key, a)] -> IntMap a
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
fromDistinctAscList :: [(Key, a)] -> IntMap a
insert :: Key -> a -> IntMap a -> IntMap a
insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
delete :: Key -> IntMap a -> IntMap a
adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
adjustWithKey :: (Key -> a -> a) -> Key -> IntMap a -> IntMap a
update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
alter :: (Maybe a -> Maybe a) -> Key -> IntMap a -> IntMap a
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)
lookup :: Key -> IntMap a -> Maybe a
(!?) :: IntMap a -> Key -> Maybe a
infixl 9 !?
(!) :: IntMap a -> Key -> a
findWithDefault :: a -> Key -> IntMap a -> a
member :: Key -> IntMap a -> Bool
notMember :: Key -> IntMap a -> Bool
lookupLT :: Key -> IntMap a -> Maybe (Key, a)
lookupGT :: Key -> IntMap a -> Maybe (Key, a)
lookupLE :: Key -> IntMap a -> Maybe (Key, a)
lookupGE :: Key -> IntMap a -> Maybe (Key, a)
null :: IntMap a -> Bool
size :: IntMap a -> Int
union :: IntMap a -> IntMap a -> IntMap a
unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unions :: Foldable f => f (IntMap a) -> IntMap a
unionsWith :: Foldable f => (a -> a -> a) -> f (IntMap a) -> IntMap a
difference :: IntMap a -> IntMap b -> IntMap a
(\\) :: IntMap a -> IntMap b -> IntMap a
infixl 9 \\
differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
differenceWithKey :: (Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
intersection :: IntMap a -> IntMap b -> IntMap a
intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
intersectionWithKey :: (Key -> a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (IntMap a -> IntMap c) -> (IntMap b -> IntMap c) -> IntMap a -> IntMap b -> IntMap c
map :: (a -> b) -> IntMap a -> IntMap b
mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
traverseWithKey :: Applicative t => (Key -> a -> t b) -> IntMap a -> t (IntMap b)
mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapKeys :: (Key -> Key) -> IntMap a -> IntMap a
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> IntMap a -> IntMap a
mapKeysMonotonic :: (Key -> Key) -> IntMap a -> IntMap a
foldr :: (a -> b -> b) -> b -> IntMap a -> b
foldl :: (a -> b -> a) -> a -> IntMap b -> a
foldrWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldlWithKey :: (a -> Key -> b -> a) -> a -> IntMap b -> a
foldMapWithKey :: Monoid m => (Key -> a -> m) -> IntMap a -> m
foldr' :: (a -> b -> b) -> b -> IntMap a -> b
foldl' :: (a -> b -> a) -> a -> IntMap b -> a
foldrWithKey' :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldlWithKey' :: (a -> Key -> b -> a) -> a -> IntMap b -> a
elems :: IntMap a -> [a]
keys :: IntMap a -> [Key]
assocs :: IntMap a -> [(Key, a)]
keysSet :: IntMap a -> IntSet
toList :: IntMap a -> [(Key, a)]
toAscList :: IntMap a -> [(Key, a)]
toDescList :: IntMap a -> [(Key, a)]
filter :: (a -> Bool) -> IntMap a -> IntMap a
filterWithKey :: (Key -> a -> Bool) -> IntMap a -> IntMap a
restrictKeys :: IntMap a -> IntSet -> IntMap a
withoutKeys :: IntMap a -> IntSet -> IntMap a
partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
partitionWithKey :: (Key -> a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
mapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b
mapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
mapEitherWithKey :: (Key -> a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
split :: Key -> IntMap a -> (IntMap a, IntMap a)
splitLookup :: Key -> IntMap a -> (IntMap a, Maybe a, IntMap a)
splitRoot :: IntMap a -> [IntMap a]
isSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isProperSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
lookupMin :: IntMap a -> Maybe (Key, a)
lookupMax :: IntMap a -> Maybe (Key, a)
findMin :: IntMap a -> (Key, a)
findMax :: IntMap a -> (Key, a)
deleteMin :: IntMap a -> IntMap a
deleteMax :: IntMap a -> IntMap a
deleteFindMin :: IntMap a -> ((Key, a), IntMap a)
deleteFindMax :: IntMap a -> ((Key, a), IntMap a)
updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
updateMinWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a
updateMaxWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a
minView :: IntMap a -> Maybe (a, IntMap a)
maxView :: IntMap a -> Maybe (a, IntMap a)
minViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)
maxViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)
showTree :: Whoops "Data.IntMap.showTree has moved to Data.IntMap.Internal.Debug.showTree" => IntMap a -> String
showTreeWith :: Whoops "Data.IntMap.showTreeWith has moved to Data.IntMap.Internal.Debug.showTreeWith" => Bool -> Bool -> IntMap a -> String
module Data.IntMap.Lazy
data IntMap a
type Key = Int
empty :: IntMap a
singleton :: Key -> a -> IntMap a
fromSet :: (Key -> a) -> IntSet -> IntMap a
fromList :: [(Key, a)] -> IntMap a
fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
fromAscList :: [(Key, a)] -> IntMap a
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
fromDistinctAscList :: forall a. [(Key, a)] -> IntMap a
insert :: Key -> a -> IntMap a -> IntMap a
insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
delete :: Key -> IntMap a -> IntMap a
adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
adjustWithKey :: (Key -> a -> a) -> Key -> IntMap a -> IntMap a
update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
alter :: (Maybe a -> Maybe a) -> Key -> IntMap a -> IntMap a
alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)
lookup :: Key -> IntMap a -> Maybe a
(!?) :: IntMap a -> Key -> Maybe a
infixl 9 !?
(!) :: IntMap a -> Key -> a
findWithDefault :: a -> Key -> IntMap a -> a
member :: Key -> IntMap a -> Bool
notMember :: Key -> IntMap a -> Bool
lookupLT :: Key -> IntMap a -> Maybe (Key, a)
lookupGT :: Key -> IntMap a -> Maybe (Key, a)
lookupLE :: Key -> IntMap a -> Maybe (Key, a)
lookupGE :: Key -> IntMap a -> Maybe (Key, a)
null :: IntMap a -> Bool
size :: IntMap a -> Int
union :: IntMap a -> IntMap a -> IntMap a
unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
unions :: Foldable f => f (IntMap a) -> IntMap a
unionsWith :: Foldable f => (a -> a -> a) -> f (IntMap a) -> IntMap a
difference :: IntMap a -> IntMap b -> IntMap a
(\\) :: IntMap a -> IntMap b -> IntMap a
infixl 9 \\
differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
differenceWithKey :: (Key -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
intersection :: IntMap a -> IntMap b -> IntMap a
intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
intersectionWithKey :: (Key -> a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
mergeWithKey :: (Key -> a -> b -> Maybe c) -> (IntMap a -> IntMap c) -> (IntMap b -> IntMap c) -> IntMap a -> IntMap b -> IntMap c
map :: (a -> b) -> IntMap a -> IntMap b
mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
traverseWithKey :: Applicative t => (Key -> a -> t b) -> IntMap a -> t (IntMap b)
mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapAccumRWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
mapKeys :: (Key -> Key) -> IntMap a -> IntMap a
mapKeysWith :: (a -> a -> a) -> (Key -> Key) -> IntMap a -> IntMap a
mapKeysMonotonic :: (Key -> Key) -> IntMap a -> IntMap a
foldr :: (a -> b -> b) -> b -> IntMap a -> b
foldl :: (a -> b -> a) -> a -> IntMap b -> a
foldrWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldlWithKey :: (a -> Key -> b -> a) -> a -> IntMap b -> a
foldMapWithKey :: Monoid m => (Key -> a -> m) -> IntMap a -> m
foldr' :: (a -> b -> b) -> b -> IntMap a -> b
foldl' :: (a -> b -> a) -> a -> IntMap b -> a
foldrWithKey' :: (Key -> a -> b -> b) -> b -> IntMap a -> b
foldlWithKey' :: (a -> Key -> b -> a) -> a -> IntMap b -> a
elems :: IntMap a -> [a]
keys :: IntMap a -> [Key]
assocs :: IntMap a -> [(Key, a)]
keysSet :: IntMap a -> IntSet
toList :: IntMap a -> [(Key, a)]
toAscList :: IntMap a -> [(Key, a)]
toDescList :: IntMap a -> [(Key, a)]
filter :: (a -> Bool) -> IntMap a -> IntMap a
filterWithKey :: (Key -> a -> Bool) -> IntMap a -> IntMap a
restrictKeys :: IntMap a -> IntSet -> IntMap a
withoutKeys :: IntMap a -> IntSet -> IntMap a
partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
partitionWithKey :: (Key -> a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
mapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b
mapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
mapEitherWithKey :: (Key -> a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
split :: Key -> IntMap a -> (IntMap a, IntMap a)
splitLookup :: Key -> IntMap a -> (IntMap a, Maybe a, IntMap a)
splitRoot :: IntMap a -> [IntMap a]
isSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
isProperSubmapOf :: Eq a => IntMap a -> IntMap a -> Bool
isProperSubmapOfBy :: (a -> b -> Bool) -> IntMap a -> IntMap b -> Bool
lookupMin :: IntMap a -> Maybe (Key, a)
lookupMax :: IntMap a -> Maybe (Key, a)
findMin :: IntMap a -> (Key, a)
findMax :: IntMap a -> (Key, a)
deleteMin :: IntMap a -> IntMap a
deleteMax :: IntMap a -> IntMap a
deleteFindMin :: IntMap a -> ((Key, a), IntMap a)
deleteFindMax :: IntMap a -> ((Key, a), IntMap a)
updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
updateMinWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a
updateMaxWithKey :: (Key -> a -> Maybe a) -> IntMap a -> IntMap a
minView :: IntMap a -> Maybe (a, IntMap a)
maxView :: IntMap a -> Maybe (a, IntMap a)
minViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)
maxViewWithKey :: IntMap a -> Maybe ((Key, a), IntMap a)
showTree :: Whoops "Data.IntMap.showTree has moved to Data.IntMap.Internal.Debug.showTree" => IntMap a -> String
showTreeWith :: Whoops "Data.IntMap.showTreeWith has moved to Data.IntMap.Internal.Debug.showTreeWith" => Bool -> Bool -> IntMap a -> String
module Data.IntMap
insertWith' :: Whoops "Data.IntMap.insertWith' is gone. Use Data.IntMap.Strict.insertWith." => (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
insertWithKey' :: Whoops "Data.IntMap.insertWithKey' is gone. Use Data.IntMap.Strict.insertWithKey." => (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
fold :: Whoops "Data.IntMap.fold' is gone. Use Data.IntMap.foldr or Prelude.foldr." => (a -> b -> b) -> b -> IntMap a -> b
foldWithKey :: Whoops "Data.IntMap.foldWithKey is gone. Use foldrWithKey." => (Key -> a -> b -> b) -> b -> IntMap a -> b
